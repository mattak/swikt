(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([[63],{

/***/ 895:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const Lexer_js_1 = __importDefault(__webpack_require__(4412));
const Interval_js_1 = __importDefault(__webpack_require__(4886));
const TokenStream_js_1 = __importDefault(__webpack_require__(7002));
/**
 * This implementation of {@link TokenStream} loads tokens from a
 * {@link TokenSource} on-demand, and places the tokens in a buffer to provide
 * access to any previous token by index.
 *
 * <p>
 * This token stream ignores the value of {@link Token//getChannel}. If your
 * parser requires the token stream filter tokens to only those on a particular
 * channel, such as {@link Token//DEFAULT_CHANNEL} or
 * {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a
 * {@link CommonTokenStream}.</p>
 */
class BufferedTokenStream extends TokenStream_js_1.default {
    constructor(tokenSource) {
        super();
        // The {@link TokenSource} from which tokens for this stream are fetched.
        this.tokenSource = tokenSource;
        /**
         * A collection of all tokens fetched from the token source. The list is
         * considered a complete view of the input once {@link //fetchedEOF} is set
         * to {@code true}.
         */
        this.tokens = [];
        /**
         * The index into {@link //tokens} of the current token (next token to
         * {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should
         * be
         * {@link //LT LT(1)}.
         *
         * <p>This field is set to -1 when the stream is first constructed or when
         * {@link //setTokenSource} is called, indicating that the first token has
         * not yet been fetched from the token source. For additional information,
         * see the documentation of {@link IntStream} for a description of
         * Initializing Methods.</p>
         */
        this.index = -1;
        /**
         * Indicates whether the {@link Token//EOF} token has been fetched from
         * {@link //tokenSource} and added to {@link //tokens}. This field improves
         * performance for the following cases:
         *
         * <ul>
         * <li>{@link //consume}: The lookahead check in {@link //consume} to
         * prevent
         * consuming the EOF symbol is optimized by checking the values of
         * {@link //fetchedEOF} and {@link //p} instead of calling {@link
         * //LA}.</li>
         * <li>{@link //fetch}: The check to prevent adding multiple EOF symbols
         * into
         * {@link //tokens} is trivial with this field.</li>
         * <ul>
         */
        this.fetchedEOF = false;
    }
    mark() {
        return 0;
    }
    release(marker) {
        // no resources to release
    }
    reset() {
        this.seek(0);
    }
    seek(index) {
        this.lazyInit();
        this.index = this.adjustSeekIndex(index);
    }
    get(index) {
        this.lazyInit();
        return this.tokens[index];
    }
    consume() {
        let skipEofCheck = false;
        if (this.index >= 0) {
            if (this.fetchedEOF) {
                // the last token in tokens is EOF. skip check if p indexes any
                // fetched token except the last.
                skipEofCheck = this.index < this.tokens.length - 1;
            }
            else {
                // no EOF token in tokens. skip check if p indexes a fetched token.
                skipEofCheck = this.index < this.tokens.length;
            }
        }
        else {
            // not yet initialized
            skipEofCheck = false;
        }
        if (!skipEofCheck && this.LA(1) === Token_js_1.default.EOF) {
            throw "cannot consume EOF";
        }
        if (this.sync(this.index + 1)) {
            this.index = this.adjustSeekIndex(this.index + 1);
        }
    }
    /**
     * Make sure index {@code i} in tokens has a token.
     *
     * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise
     * {@code false}.
     * @see //get(int i)
     */
    sync(i) {
        const n = i - this.tokens.length + 1; // how many more elements we need?
        if (n > 0) {
            const fetched = this.fetch(n);
            return fetched >= n;
        }
        return true;
    }
    /**
     * Add {@code n} elements to buffer.
     *
     * @return {Number} The actual number of elements added to the buffer.
     */
    fetch(n) {
        if (this.fetchedEOF) {
            return 0;
        }
        for (let i = 0; i < n; i++) {
            const t = this.tokenSource.nextToken();
            t.tokenIndex = this.tokens.length;
            this.tokens.push(t);
            if (t.type === Token_js_1.default.EOF) {
                this.fetchedEOF = true;
                return i + 1;
            }
        }
        return n;
    }
    // Get all tokens from start..stop inclusively///
    getTokens(start, stop, types) {
        if (types === undefined) {
            types = null;
        }
        if (start < 0 || stop < 0) {
            return null;
        }
        this.lazyInit();
        const subset = [];
        if (stop >= this.tokens.length) {
            stop = this.tokens.length - 1;
        }
        for (let i = start; i < stop; i++) {
            const t = this.tokens[i];
            if (t.type === Token_js_1.default.EOF) {
                break;
            }
            if (types === null || types.contains(t.type)) {
                subset.push(t);
            }
        }
        return subset;
    }
    LA(i) {
        return this.LT(i).type;
    }
    LB(k) {
        if (this.index - k < 0) {
            return null;
        }
        return this.tokens[this.index - k];
    }
    LT(k) {
        this.lazyInit();
        if (k === 0) {
            return null;
        }
        if (k < 0) {
            return this.LB(-k);
        }
        const i = this.index + k - 1;
        this.sync(i);
        if (i >= this.tokens.length) { // return EOF token
            // EOF must be last token
            return this.tokens[this.tokens.length - 1];
        }
        return this.tokens[i];
    }
    /**
     * Allowed derived classes to modify the behavior of operations which change
     * the current stream position by adjusting the target token index of a seek
     * operation. The default implementation simply returns {@code i}. If an
     * exception is thrown in this method, the current stream index should not be
     * changed.
     *
     * <p>For example, {@link CommonTokenStream} overrides this method to ensure
     * that
     * the seek target is always an on-channel token.</p>
     *
     * @param {Number} i The target token index.
     * @return {Number} The adjusted target token index.
     */
    adjustSeekIndex(i) {
        return i;
    }
    lazyInit() {
        if (this.index === -1) {
            this.setup();
        }
    }
    setup() {
        this.sync(0);
        this.index = this.adjustSeekIndex(0);
    }
    // Reset this token stream by setting its token source.///
    setTokenSource(tokenSource) {
        this.tokenSource = tokenSource;
        this.tokens = [];
        this.index = -1;
        this.fetchedEOF = false;
    }
    /**
     * Given a starting index, return the index of the next token on channel.
     * Return i if tokens[i] is on channel. Return -1 if there are no tokens
     * on channel between i and EOF.
     */
    nextTokenOnChannel(i, channel) {
        this.sync(i);
        if (i >= this.tokens.length) {
            return -1;
        }
        let token = this.tokens[i];
        while (token.channel !== this.channel) {
            if (token.type === Token_js_1.default.EOF) {
                return -1;
            }
            i += 1;
            this.sync(i);
            token = this.tokens[i];
        }
        return i;
    }
    /**
     * Given a starting index, return the index of the previous token on channel.
     * Return i if tokens[i] is on channel. Return -1 if there are no tokens
     * on channel between i and 0.
     */
    previousTokenOnChannel(i, channel) {
        while (i >= 0 && this.tokens[i].channel !== channel) {
            i -= 1;
        }
        return i;
    }
    /**
     * Collect all tokens on specified channel to the right of
     * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
     * EOF. If channel is -1, find any non default channel token.
     */
    getHiddenTokensToRight(tokenIndex, channel) {
        if (channel === undefined) {
            channel = -1;
        }
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
            throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
        }
        const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer_js_1.default.DEFAULT_TOKEN_CHANNEL);
        const from_ = tokenIndex + 1;
        // if none onchannel to right, nextOnChannel=-1 so set to = last token
        const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
        return this.filterForChannel(from_, to, channel);
    }
    /**
     * Collect all tokens on specified channel to the left of
     * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
     * If channel is -1, find any non default channel token.
     */
    getHiddenTokensToLeft(tokenIndex, channel) {
        if (channel === undefined) {
            channel = -1;
        }
        this.lazyInit();
        if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
            throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
        }
        const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer_js_1.default.DEFAULT_TOKEN_CHANNEL);
        if (prevOnChannel === tokenIndex - 1) {
            return null;
        }
        // if none on channel to left, prevOnChannel=-1 then from=0
        const from_ = prevOnChannel + 1;
        const to = tokenIndex - 1;
        return this.filterForChannel(from_, to, channel);
    }
    filterForChannel(left, right, channel) {
        const hidden = [];
        for (let i = left; i < right + 1; i++) {
            const t = this.tokens[i];
            if (channel === -1) {
                if (t.channel !== Lexer_js_1.default.DEFAULT_TOKEN_CHANNEL) {
                    hidden.push(t);
                }
            }
            else if (t.channel === channel) {
                hidden.push(t);
            }
        }
        if (hidden.length === 0) {
            return null;
        }
        return hidden;
    }
    getSourceName() {
        return this.tokenSource.getSourceName();
    }
    // Get the text of all tokens in this buffer.///
    getText(interval) {
        this.lazyInit();
        this.fill();
        if (interval === undefined || interval === null) {
            interval = new Interval_js_1.default(0, this.tokens.length - 1);
        }
        let start = interval.start;
        if (start instanceof Token_js_1.default) {
            start = start.tokenIndex;
        }
        let stop = interval.stop;
        if (stop instanceof Token_js_1.default) {
            stop = stop.tokenIndex;
        }
        if (start === null || stop === null || start < 0 || stop < 0) {
            return "";
        }
        if (stop >= this.tokens.length) {
            stop = this.tokens.length - 1;
        }
        let s = "";
        for (let i = start; i < stop + 1; i++) {
            const t = this.tokens[i];
            if (t.type === Token_js_1.default.EOF) {
                break;
            }
            s = s + t.text;
        }
        return s;
    }
    // Get all tokens from lexer until EOF///
    fill() {
        this.lazyInit();
        while (this.fetch(1000) === 1000) {
            continue;
        }
    }
}
exports["default"] = BufferedTokenStream;
//# sourceMappingURL=BufferedTokenStream.js.map

/***/ }),

/***/ 5689:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const InputStream_js_1 = __importDefault(__webpack_require__(2732));
const fs_1 = __importDefault(__webpack_require__(7816));
/**
 * Utility functions to create InputStreams from various sources.
 *
 * All returned InputStreams support the full range of Unicode
 * up to U+10FFFF (the default behavior of InputStream only supports
 * code points up to U+FFFF).
 */
exports["default"] = {
    // Creates an InputStream from a string.
    fromString: function (str) {
        return new InputStream_js_1.default(str, true);
    },
    /**
     * Asynchronously creates an InputStream from a blob given the
     * encoding of the bytes in that blob (defaults to 'utf8' if
     * encoding is null).
     *
     * Invokes onLoad(result) on success, onError(error) on
     * failure.
     */
    fromBlob: function (blob, encoding, onLoad, onError) {
        const reader = new window.FileReader();
        reader.onload = function (e) {
            const is = new InputStream_js_1.default(e.target.result, true);
            onLoad(is);
        };
        reader.onerror = onError;
        reader.readAsText(blob, encoding);
    },
    /**
     * Creates an InputStream from a Buffer given the
     * encoding of the bytes in that buffer (defaults to 'utf8' if
     * encoding is null).
     */
    fromBuffer: function (buffer, encoding) {
        return new InputStream_js_1.default(buffer.toString(encoding), true);
    },
    /** Asynchronously creates an InputStream from a file on disk given
     * the encoding of the bytes in that file (defaults to 'utf8' if
     * encoding is null).
     *
     * Invokes callback(error, result) on completion.
     */
    fromPath: function (path, encoding, callback) {
        fs_1.default.readFile(path, encoding, function (err, data) {
            let is = null;
            if (data !== null) {
                is = new InputStream_js_1.default(data, true);
            }
            callback(err, is);
        });
    },
    /**
     * Synchronously creates an InputStream given a path to a file
     * on disk and the encoding of the bytes in that file (defaults to
     * 'utf8' if encoding is null).
     */
    fromPathSync: function (path, encoding) {
        const data = fs_1.default.readFileSync(path, encoding);
        return new InputStream_js_1.default(data, true);
    }
};
//# sourceMappingURL=CharStreams.js.map

/***/ }),

/***/ 1368:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
class CommonToken extends Token_js_1.default {
    constructor(source, type, channel, start, stop) {
        super();
        this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;
        this.type = type !== undefined ? type : null;
        this.channel = channel !== undefined ? channel : Token_js_1.default.DEFAULT_CHANNEL;
        this.start = start !== undefined ? start : -1;
        this.stop = stop !== undefined ? stop : -1;
        this.tokenIndex = -1;
        if (this.source[0] !== null) {
            this.line = source[0].line;
            this.column = source[0].column;
        }
        else {
            this.column = -1;
        }
    }
    /**
     * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
     *
     * <p>
     * If {@code oldToken} is also a {@link CommonToken} instance, the newly
     * constructed token will share a reference to the {@link //text} field and
     * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
     * be assigned the result of calling {@link //getText}, and {@link //source}
     * will be constructed from the result of {@link Token//getTokenSource} and
     * {@link Token//getInputStream}.</p>
     *
     * @param oldToken The token to copy.
     */
    clone() {
        const t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);
        t.tokenIndex = this.tokenIndex;
        t.line = this.line;
        t.column = this.column;
        t.text = this.text;
        return t;
    }
    toString() {
        let txt = this.text;
        if (txt !== null) {
            txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
        }
        else {
            txt = "<no text>";
        }
        return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" +
            txt + "',<" + this.type + ">" +
            (this.channel > 0 ? ",channel=" + this.channel : "") + "," +
            this.line + ":" + this.column + "]";
    }
    get text() {
        if (this._text !== null) {
            return this._text;
        }
        const input = this.getInputStream();
        if (input === null) {
            return null;
        }
        const n = input.size;
        if (this.start < n && this.stop < n) {
            return input.getText(this.start, this.stop);
        }
        else {
            return "<EOF>";
        }
    }
    set text(text) {
        this._text = text;
    }
}
exports["default"] = CommonToken;
/**
 * An empty {@link Pair} which is used as the default value of
 * {@link //source} for tokens that do not have a source.
 */
CommonToken.EMPTY_SOURCE = [null, null];
//# sourceMappingURL=CommonToken.js.map

/***/ }),

/***/ 2058:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const CommonToken_js_1 = __importDefault(__webpack_require__(1368));
class TokenFactory {
}
/**
 * This default implementation of {@link TokenFactory} creates
 * {@link CommonToken} objects.
 */
class CommonTokenFactory extends TokenFactory {
    constructor(copyText) {
        super();
        /**
         * Indicates whether {@link CommonToken//setText} should be called after
         * constructing tokens to explicitly set the text. This is useful for cases
         * where the input stream might not be able to provide arbitrary substrings
         * of text from the input after the lexer creates a token (e.g. the
         * implementation of {@link CharStream//getText} in
         * {@link UnbufferedCharStream} throws an
         * {@link UnsupportedOperationException}). Explicitly setting the token text
         * allows {@link Token//getText} to be called at any time regardless of the
         * input stream implementation.
         *
         * <p>
         * The default value is {@code false} to avoid the performance and memory
         * overhead of copying text for every token unless explicitly requested.</p>
         */
        this.copyText = copyText === undefined ? false : copyText;
    }
    create(source, type, text, channel, start, stop, line, column) {
        const t = new CommonToken_js_1.default(source, type, channel, start, stop);
        t.line = line;
        t.column = column;
        if (text !== null) {
            t.text = text;
        }
        else if (this.copyText && source[1] !== null) {
            t.text = source[1].getText(start, stop);
        }
        return t;
    }
    createThin(type, text) {
        const t = new CommonToken_js_1.default(null, type);
        t.text = text;
        return t;
    }
}
exports["default"] = CommonTokenFactory;
/**
 * The default {@link CommonTokenFactory} instance.
 *
 * <p>
 * This token factory does not explicitly copy token text when constructing
 * tokens.</p>
 */
CommonTokenFactory.DEFAULT = new CommonTokenFactory();
//# sourceMappingURL=CommonTokenFactory.js.map

/***/ }),

/***/ 1259:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const BufferedTokenStream_js_1 = __importDefault(__webpack_require__(895));
/**
 * This class extends {@link BufferedTokenStream} with functionality to filter
 * token streams to tokens on a particular channel (tokens where
 * {@link Token//getChannel} returns a particular value).
 *
 * <p>
 * This token stream provides access to all tokens by index or when calling
 * methods like {@link //getText}. The channel filtering is only used for code
 * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and
 * {@link //LB}.</p>
 *
 * <p>
 * By default, tokens are placed on the default channel
 * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the
 * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to
 * call {@link Lexer//setChannel}.
 * </p>
 *
 * <p>
 * Note: lexer rules which use the {@code ->skip} lexer command or call
 * {@link Lexer//skip} do not produce tokens at all, so input text matched by
 * such a rule will not be available as part of the token stream, regardless of
 * channel.</p>
 */
class CommonTokenStream extends BufferedTokenStream_js_1.default {
    constructor(lexer, channel) {
        super(lexer);
        this.channel = channel === undefined ? Token_js_1.default.DEFAULT_CHANNEL : channel;
    }
    adjustSeekIndex(i) {
        return this.nextTokenOnChannel(i, this.channel);
    }
    LB(k) {
        if (k === 0 || this.index - k < 0) {
            return null;
        }
        let i = this.index;
        let n = 1;
        // find k good tokens looking backwards
        while (n <= k) {
            // skip off-channel tokens
            i = this.previousTokenOnChannel(i - 1, this.channel);
            n += 1;
        }
        if (i < 0) {
            return null;
        }
        return this.tokens[i];
    }
    LT(k) {
        this.lazyInit();
        if (k === 0) {
            return null;
        }
        if (k < 0) {
            return this.LB(-k);
        }
        let i = this.index;
        let n = 1; // we know tokens[pos] is a good one
        // find k good tokens
        while (n < k) {
            // skip off-channel tokens, but make sure to not look past EOF
            if (this.sync(i + 1)) {
                i = this.nextTokenOnChannel(i + 1, this.channel);
            }
            n += 1;
        }
        return this.tokens[i];
    }
    // Count EOF just once.
    getNumberOfOnChannelTokens() {
        let n = 0;
        this.fill();
        for (let i = 0; i < this.tokens.length; i++) {
            const t = this.tokens[i];
            if (t.channel === this.channel) {
                n += 1;
            }
            if (t.type === Token_js_1.default.EOF) {
                break;
            }
        }
        return n;
    }
}
exports["default"] = CommonTokenStream;
//# sourceMappingURL=CommonTokenStream.js.map

/***/ }),

/***/ 654:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const InputStream_js_1 = __importDefault(__webpack_require__(2732));
const fs_1 = __importDefault(__webpack_require__(7816));
/**
 * This is an InputStream that is loaded from a file all at once
 * when you construct the object.
 */
class FileStream extends InputStream_js_1.default {
    constructor(fileName, decodeToUnicodeCodePoints) {
        const data = fs_1.default.readFileSync(fileName, "utf8");
        super(data, decodeToUnicodeCodePoints);
        this.fileName = fileName;
    }
}
exports["default"] = FileStream;
//# sourceMappingURL=FileStream.js.map

/***/ }),

/***/ 2732:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
__webpack_require__(5034);
__webpack_require__(2085);
/**
 * If decodeToUnicodeCodePoints is true, the input is treated
 * as a series of Unicode code points.
 *
 * Otherwise, the input is treated as a series of 16-bit UTF-16 code
 * units.
 */
class InputStream {
    constructor(data, decodeToUnicodeCodePoints) {
        this.name = "<empty>";
        this.strdata = data;
        this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false;
        // _loadString - Vacuum all input from a string and then treat it like a buffer.
        this._index = 0;
        this.data = [];
        if (this.decodeToUnicodeCodePoints) {
            for (let i = 0; i < this.strdata.length;) {
                const codePoint = this.strdata.codePointAt(i);
                this.data.push(codePoint);
                i += codePoint <= 0xFFFF ? 1 : 2;
            }
        }
        else {
            this.data = new Array(this.strdata.length);
            for (let i = 0; i < this.strdata.length; i++) {
                const codeUnit = this.strdata.charCodeAt(i);
                this.data[i] = codeUnit;
            }
        }
        this._size = this.data.length;
    }
    /**
     * Reset the stream so that it's in the same state it was
     * when the object was created *except* the data array is not
     * touched.
     */
    reset() {
        this._index = 0;
    }
    consume() {
        if (this._index >= this._size) {
            // assert this.LA(1) == Token.EOF
            throw ("cannot consume EOF");
        }
        this._index += 1;
    }
    LA(offset) {
        if (offset === 0) {
            return 0; // undefined
        }
        if (offset < 0) {
            offset += 1; // e.g., translate LA(-1) to use offset=0
        }
        const pos = this._index + offset - 1;
        if (pos < 0 || pos >= this._size) { // invalid
            return Token_js_1.default.EOF;
        }
        return this.data[pos];
    }
    LT(offset) {
        return this.LA(offset);
    }
    // mark/release do nothing; we have entire buffer
    mark() {
        return -1;
    }
    release(marker) {
    }
    /**
     * consume() ahead until p==_index; can't just set p=_index as we must
     * update line and column. If we seek backwards, just set p
     */
    seek(_index) {
        if (_index <= this._index) {
            this._index = _index; // just jump; don't update stream state (line,
            // ...)
            return;
        }
        // seek forward
        this._index = Math.min(_index, this._size);
    }
    getText(start, stop) {
        if (stop >= this._size) {
            stop = this._size - 1;
        }
        if (start >= this._size) {
            return "";
        }
        else {
            if (this.decodeToUnicodeCodePoints) {
                let result = "";
                for (let i = start; i <= stop; i++) {
                    result += String.fromCodePoint(this.data[i]);
                }
                return result;
            }
            else {
                return this.strdata.slice(start, stop + 1);
            }
        }
    }
    toString() {
        return this.strdata;
    }
    get index() {
        return this._index;
    }
    get size() {
        return this._size;
    }
}
exports["default"] = InputStream;
//# sourceMappingURL=InputStream.js.map

/***/ }),

/***/ 4412:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const Recognizer_js_1 = __importDefault(__webpack_require__(4489));
const CommonTokenFactory_js_1 = __importDefault(__webpack_require__(2058));
const RecognitionException_js_1 = __importDefault(__webpack_require__(5000));
const LexerNoViableAltException_js_1 = __importDefault(__webpack_require__(313));
/**
 * A lexer is recognizer that draws input symbols from a character stream.
 * lexer grammars result in a subclass of this object. A Lexer object
 * uses simplified match() and error recovery mechanisms in the interest of speed.
 */
class Lexer extends Recognizer_js_1.default {
    constructor(input) {
        super();
        this._input = input;
        this._factory = CommonTokenFactory_js_1.default.DEFAULT;
        this._tokenFactorySourcePair = [this, input];
        this._interp = null; // child classes must populate this
        /**
         * The goal of all lexer rules/methods is to create a token object.
         * this is an instance variable as multiple rules may collaborate to
         * create a single token. nextToken will return this object after
         * matching lexer rule(s). If you subclass to allow multiple token
         * emissions, then set this to the last token to be matched or
         * something nonnull so that the auto token emit mechanism will not
         * emit another token.
         */
        this._token = null;
        /**
         * What character index in the stream did the current token start at?
         * Needed, for example, to get the text for current token. Set at
         * the start of nextToken.
         */
        this._tokenStartCharIndex = -1;
        // The line on which the first character of the token resides///
        this._tokenStartLine = -1;
        // The character position of first character within the line///
        this._tokenStartColumn = -1;
        // Once we see EOF on char stream, next token will be EOF.
        // If you have DONE : EOF ; then you see DONE EOF.
        this._hitEOF = false;
        // The channel number for the current token///
        this._channel = Token_js_1.default.DEFAULT_CHANNEL;
        // The token type for the current token///
        this._type = Token_js_1.default.INVALID_TYPE;
        this._modeStack = [];
        this._mode = Lexer.DEFAULT_MODE;
        /**
         * You can set the text for the current token to override what is in
         * the input char buffer. Use setText() or can set this instance var.
         */
        this._text = null;
    }
    reset() {
        // wack Lexer state variables
        if (this._input !== null) {
            this._input.seek(0); // rewind the input
        }
        this._token = null;
        this._type = Token_js_1.default.INVALID_TYPE;
        this._channel = Token_js_1.default.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = -1;
        this._tokenStartColumn = -1;
        this._tokenStartLine = -1;
        this._text = null;
        this._hitEOF = false;
        this._mode = Lexer.DEFAULT_MODE;
        this._modeStack = [];
        this._interp.reset();
    }
    // Return a token from this source; i.e., match a token on the char stream.
    nextToken() {
        if (this._input === null) {
            throw "nextToken requires a non-null input stream.";
        }
        /**
         * Mark start location in char stream so unbuffered streams are
         * guaranteed at least have text of current token
         */
        const tokenStartMarker = this._input.mark();
        try {
            for (;;) {
                if (this._hitEOF) {
                    this.emitEOF();
                    return this._token;
                }
                this._token = null;
                this._channel = Token_js_1.default.DEFAULT_CHANNEL;
                this._tokenStartCharIndex = this._input.index;
                this._tokenStartColumn = this._interp.column;
                this._tokenStartLine = this._interp.line;
                this._text = null;
                let continueOuter = false;
                for (;;) {
                    this._type = Token_js_1.default.INVALID_TYPE;
                    let ttype = Lexer.SKIP;
                    try {
                        ttype = this._interp.match(this._input, this._mode);
                    }
                    catch (e) {
                        if (e instanceof RecognitionException_js_1.default) {
                            this.notifyListeners(e); // report error
                            this.recover(e);
                        }
                        else {
                            console.log(e.stack);
                            throw e;
                        }
                    }
                    if (this._input.LA(1) === Token_js_1.default.EOF) {
                        this._hitEOF = true;
                    }
                    if (this._type === Token_js_1.default.INVALID_TYPE) {
                        this._type = ttype;
                    }
                    if (this._type === Lexer.SKIP) {
                        continueOuter = true;
                        break;
                    }
                    if (this._type !== Lexer.MORE) {
                        break;
                    }
                }
                if (continueOuter) {
                    continue;
                }
                if (this._token === null) {
                    this.emit();
                }
                return this._token;
            }
        }
        finally {
            // make sure we release marker after match or
            // unbuffered char stream will keep buffering
            this._input.release(tokenStartMarker);
        }
    }
    /**
     * Instruct the lexer to skip creating a token for current lexer rule
     * and look for another token. nextToken() knows to keep looking when
     * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
     * if token==null at end of any token rule, it creates one for you
     * and emits it.
     */
    skip() {
        this._type = Lexer.SKIP;
    }
    more() {
        this._type = Lexer.MORE;
    }
    mode(m) {
        this._mode = m;
    }
    pushMode(m) {
        if (this._interp.debug) {
            console.log("pushMode " + m);
        }
        this._modeStack.push(this._mode);
        this.mode(m);
    }
    popMode() {
        if (this._modeStack.length === 0) {
            throw "Empty Stack";
        }
        if (this._interp.debug) {
            console.log("popMode back to " + this._modeStack.slice(0, -1));
        }
        this.mode(this._modeStack.pop());
        return this._mode;
    }
    /**
     * By default does not support multiple emits per nextToken invocation
     * for efficiency reasons. Subclass and override this method, nextToken,
     * and getToken (to push tokens into a list and pull from that list
     * rather than a single variable as this implementation does).
     */
    emitToken(token) {
        this._token = token;
    }
    /**
     * The standard method called to automatically emit a token at the
     * outermost lexical rule. The token object should point into the
     * char buffer start..stop. If there is a text override in 'text',
     * use that to set the token's text. Override this method to emit
     * custom Token objects or provide a new factory.
     */
    emit() {
        const t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this
            .getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
        this.emitToken(t);
        return t;
    }
    emitEOF() {
        const cpos = this.column;
        const lpos = this.line;
        const eof = this._factory.create(this._tokenFactorySourcePair, Token_js_1.default.EOF, null, Token_js_1.default.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, lpos, cpos);
        this.emitToken(eof);
        return eof;
    }
    // What is the index of the current character of lookahead?///
    getCharIndex() {
        return this._input.index;
    }
    /**
     * Return a list of all Token objects in input char stream.
     * Forces load of all tokens. Does not include EOF token.
     */
    getAllTokens() {
        const tokens = [];
        let t = this.nextToken();
        while (t.type !== Token_js_1.default.EOF) {
            tokens.push(t);
            t = this.nextToken();
        }
        return tokens;
    }
    notifyListeners(e) {
        const start = this._tokenStartCharIndex;
        const stop = this._input.index;
        const text = this._input.getText(start, stop);
        const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
        const listener = this.getErrorListenerDispatch();
        listener.syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, msg, e);
    }
    getErrorDisplay(s) {
        const d = [];
        for (let i = 0; i < s.length; i++) {
            d.push(s[i]);
        }
        return d.join('');
    }
    getErrorDisplayForChar(c) {
        if (c.charCodeAt(0) === Token_js_1.default.EOF) {
            return "<EOF>";
        }
        else if (c === '\n') {
            return "\\n";
        }
        else if (c === '\t') {
            return "\\t";
        }
        else if (c === '\r') {
            return "\\r";
        }
        else {
            return c;
        }
    }
    getCharErrorDisplay(c) {
        return "'" + this.getErrorDisplayForChar(c) + "'";
    }
    /**
     * Lexers can normally match any char in it's vocabulary after matching
     * a token, so do the easy thing and just kill a character and hope
     * it all works out. You can instead use the rule invocation stack
     * to do sophisticated error recovery if you are in a fragment rule.
     */
    recover(re) {
        if (this._input.LA(1) !== Token_js_1.default.EOF) {
            if (re instanceof LexerNoViableAltException_js_1.default) {
                // skip a char and try again
                this._interp.consume(this._input);
            }
            else {
                // TODO: Do we lose character or line position information?
                this._input.consume();
            }
        }
    }
    get inputStream() {
        return this._input;
    }
    set inputStream(input) {
        this._input = null;
        this._tokenFactorySourcePair = [this, this._input];
        this.reset();
        this._input = input;
        this._tokenFactorySourcePair = [this, this._input];
    }
    get sourceName() {
        return this._input.sourceName;
    }
    get type() {
        return this._type;
    }
    set type(type) {
        this._type = type;
    }
    get line() {
        return this._interp.line;
    }
    set line(line) {
        this._interp.line = line;
    }
    get column() {
        return this._interp.column;
    }
    set column(column) {
        this._interp.column = column;
    }
    get text() {
        if (this._text !== null) {
            return this._text;
        }
        else {
            return this._interp.getText(this._input);
        }
    }
    set text(text) {
        this._text = text;
    }
}
exports["default"] = Lexer;
Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;
Lexer.DEFAULT_TOKEN_CHANNEL = Token_js_1.default.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token_js_1.default.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0x0000;
Lexer.MAX_CHAR_VALUE = 0x10FFFF;
//# sourceMappingURL=Lexer.js.map

/***/ }),

/***/ 3709:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const TerminalNode_js_1 = __importDefault(__webpack_require__(7022));
const ErrorNode_js_1 = __importDefault(__webpack_require__(7747));
const Recognizer_js_1 = __importDefault(__webpack_require__(4489));
const DefaultErrorStrategy_js_1 = __importDefault(__webpack_require__(838));
const ATNDeserializer_js_1 = __importDefault(__webpack_require__(8833));
const ATNDeserializationOptions_js_1 = __importDefault(__webpack_require__(6477));
const TraceListener_js_1 = __importDefault(__webpack_require__(1812));
class Parser extends Recognizer_js_1.default {
    /**
     * this is all the parsing support code essentially; most of it is error
     * recovery stuff.
     */
    constructor(input) {
        super();
        // The input stream.
        this._input = null;
        /**
         * The error handling strategy for the parser. The default value is a new
         * instance of {@link DefaultErrorStrategy}.
         */
        this._errHandler = new DefaultErrorStrategy_js_1.default();
        this._precedenceStack = [];
        this._precedenceStack.push(0);
        /**
         * The {@link ParserRuleContext} object for the currently executing rule.
         * this is always non-null during the parsing process.
         */
        this._ctx = null;
        /**
         * Specifies whether or not the parser should construct a parse tree during
         * the parsing process. The default value is {@code true}.
         */
        this.buildParseTrees = true;
        /**
         * When {@link //setTrace}{@code (true)} is called, a reference to the
         * {@link TraceListener} is stored here so it can be easily removed in a
         * later call to {@link //setTrace}{@code (false)}. The listener itself is
         * implemented as a parser listener so this field is not directly used by
         * other parser methods.
         */
        this._tracer = null;
        /**
         * The list of {@link ParseTreeListener} listeners registered to receive
         * events during the parse.
         */
        this._parseListeners = null;
        /**
         * The number of syntax errors reported during parsing. this value is
         * incremented each time {@link //notifyErrorListeners} is called.
         */
        this._syntaxErrors = 0;
        this.setInputStream(input);
    }
    // reset the parser's state
    reset() {
        if (this._input !== null) {
            this._input.seek(0);
        }
        this._errHandler.reset(this);
        this._ctx = null;
        this._syntaxErrors = 0;
        this.setTrace(false);
        this._precedenceStack = [];
        this._precedenceStack.push(0);
        if (this._interp !== null) {
            this._interp.reset();
        }
    }
    /**
     * Match current input symbol against {@code ttype}. If the symbol type
     * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
     * called to complete the match process.
     *
     * <p>If the symbol type does not match,
     * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
     * strategy to attempt recovery. If {@link //getBuildParseTree} is
     * {@code true} and the token index of the symbol returned by
     * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
     * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
     *
     * @param ttype the token type to match
     * @return the matched symbol
     * @throws RecognitionException if the current input symbol did not match
     * {@code ttype} and the error strategy could not recover from the
     * mismatched symbol
     */
    match(ttype) {
        let t = this.getCurrentToken();
        if (t.type === ttype) {
            this._errHandler.reportMatch(this);
            this.consume();
        }
        else {
            t = this._errHandler.recoverInline(this);
            if (this.buildParseTrees && t.tokenIndex === -1) {
                // we must have conjured up a new token during single token
                // insertion
                // if it's not the current symbol
                this._ctx.addErrorNode(t);
            }
        }
        return t;
    }
    /**
     * Match current input symbol as a wildcard. If the symbol type matches
     * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
     * and {@link //consume} are called to complete the match process.
     *
     * <p>If the symbol type does not match,
     * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
     * strategy to attempt recovery. If {@link //getBuildParseTree} is
     * {@code true} and the token index of the symbol returned by
     * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
     * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
     *
     * @return the matched symbol
     * @throws RecognitionException if the current input symbol did not match
     * a wildcard and the error strategy could not recover from the mismatched
     * symbol
     */
    matchWildcard() {
        let t = this.getCurrentToken();
        if (t.type > 0) {
            this._errHandler.reportMatch(this);
            this.consume();
        }
        else {
            t = this._errHandler.recoverInline(this);
            if (this._buildParseTrees && t.tokenIndex === -1) {
                // we must have conjured up a new token during single token
                // insertion
                // if it's not the current symbol
                this._ctx.addErrorNode(t);
            }
        }
        return t;
    }
    getParseListeners() {
        return this._parseListeners || [];
    }
    /**
     * Registers {@code listener} to receive events during the parsing process.
     *
     * <p>To support output-preserving grammar transformations (including but not
     * limited to left-recursion removal, automated left-factoring, and
     * optimized code generation), calls to listener methods during the parse
     * may differ substantially from calls made by
     * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
     * particular, rule entry and exit events may occur in a different order
     * during the parse than after the parser. In addition, calls to certain
     * rule entry methods may be omitted.</p>
     *
     * <p>With the following specific exceptions, calls to listener events are
     * <em>deterministic</em>, i.e. for identical input the calls to listener
     * methods will be the same.</p>
     *
     * <ul>
     * <li>Alterations to the grammar used to generate code may change the
     * behavior of the listener calls.</li>
     * <li>Alterations to the command line options passed to ANTLR 4 when
     * generating the parser may change the behavior of the listener calls.</li>
     * <li>Changing the version of the ANTLR Tool used to generate the parser
     * may change the behavior of the listener calls.</li>
     * </ul>
     *
     * @param listener the listener to add
     *
     * @throws NullPointerException if {@code} listener is {@code null}
     */
    addParseListener(listener) {
        if (listener === null) {
            throw "listener";
        }
        if (this._parseListeners === null) {
            this._parseListeners = [];
        }
        this._parseListeners.push(listener);
    }
    /**
     * Remove {@code listener} from the list of parse listeners.
     *
     * <p>If {@code listener} is {@code null} or has not been added as a parse
     * listener, this method does nothing.</p>
     * @param listener the listener to remove
     */
    removeParseListener(listener) {
        if (this._parseListeners !== null) {
            const idx = this._parseListeners.indexOf(listener);
            if (idx >= 0) {
                this._parseListeners.splice(idx, 1);
            }
            if (this._parseListeners.length === 0) {
                this._parseListeners = null;
            }
        }
    }
    // Remove all parse listeners.
    removeParseListeners() {
        this._parseListeners = null;
    }
    // Notify any parse listeners of an enter rule event.
    triggerEnterRuleEvent() {
        if (this._parseListeners !== null) {
            const ctx = this._ctx;
            this._parseListeners.forEach(function (listener) {
                listener.enterEveryRule(ctx);
                ctx.enterRule(listener);
            });
        }
    }
    /**
     * Notify any parse listeners of an exit rule event.
     * @see //addParseListener
     */
    triggerExitRuleEvent() {
        if (this._parseListeners !== null) {
            // reverse order walk of listeners
            const ctx = this._ctx;
            this._parseListeners.slice(0).reverse().forEach(function (listener) {
                ctx.exitRule(listener);
                listener.exitEveryRule(ctx);
            });
        }
    }
    getTokenFactory() {
        return this._input.tokenSource._factory;
    }
    // Tell our token source and error strategy about a new way to create tokens.
    setTokenFactory(factory) {
        this._input.tokenSource._factory = factory;
    }
    /**
     * The ATN with bypass alternatives is expensive to create so we create it
     * lazily.
     *
     * @throws UnsupportedOperationException if the current parser does not
     * implement the {@link //getSerializedATN()} method.
     */
    getATNWithBypassAlts() {
        const serializedAtn = this.getSerializedATN();
        if (serializedAtn === null) {
            throw "The current parser does not support an ATN with bypass alternatives.";
        }
        let result = this.bypassAltsAtnCache[serializedAtn];
        if (result === null) {
            const deserializationOptions = new ATNDeserializationOptions_js_1.default();
            deserializationOptions.generateRuleBypassTransitions = true;
            result = new ATNDeserializer_js_1.default(deserializationOptions)
                .deserialize(serializedAtn);
            this.bypassAltsAtnCache[serializedAtn] = result;
        }
        return result;
    }
    getInputStream() {
        return this.getTokenStream();
    }
    setInputStream(input) {
        this.setTokenStream(input);
    }
    getTokenStream() {
        return this._input;
    }
    // Set the token stream and reset the parser.
    setTokenStream(input) {
        this._input = null;
        this.reset();
        this._input = input;
    }
    /**
     * Match needs to return the current input symbol, which gets put
     * into the label for the associated token ref; e.g., x=ID.
     */
    getCurrentToken() {
        return this._input.LT(1);
    }
    notifyErrorListeners(msg, offendingToken, err) {
        offendingToken = offendingToken || null;
        err = err || null;
        if (offendingToken === null) {
            offendingToken = this.getCurrentToken();
        }
        this._syntaxErrors += 1;
        const line = offendingToken.line;
        const column = offendingToken.column;
        const listener = this.getErrorListenerDispatch();
        listener.syntaxError(this, offendingToken, line, column, msg, err);
    }
    /**
     * Consume and return the {@linkplain //getCurrentToken current symbol}.
     *
     * <p>E.g., given the following input with {@code A} being the current
     * lookahead symbol, this function moves the cursor to {@code B} and returns
     * {@code A}.</p>
     *
     * <pre>
     * A B
     * ^
     * </pre>
     *
     * If the parser is not in error recovery mode, the consumed symbol is added
     * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
     * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
     * If the parser <em>is</em> in error recovery mode, the consumed symbol is
     * added to the parse tree using
     * {@link ParserRuleContext//addErrorNode(Token)}, and
     * {@link ParseTreeListener//visitErrorNode} is called on any parse
     * listeners.
     */
    consume() {
        const o = this.getCurrentToken();
        if (o.type !== Token_js_1.default.EOF) {
            this.getInputStream().consume();
        }
        const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;
        if (this.buildParseTrees || hasListener) {
            let node;
            if (this._errHandler.inErrorRecoveryMode(this)) {
                node = this._ctx.addErrorNode(o);
            }
            else {
                node = this._ctx.addTokenNode(o);
            }
            node.invokingState = this.state;
            if (hasListener) {
                this._parseListeners.forEach(function (listener) {
                    if (node instanceof ErrorNode_js_1.default || (node.isErrorNode !== undefined && node.isErrorNode())) {
                        listener.visitErrorNode(node);
                    }
                    else if (node instanceof TerminalNode_js_1.default) {
                        listener.visitTerminal(node);
                    }
                });
            }
        }
        return o;
    }
    addContextToParseTree() {
        // add current context to parent if we have a parent
        if (this._ctx.parentCtx !== null) {
            this._ctx.parentCtx.addChild(this._ctx);
        }
    }
    /**
     * Always called by generated parsers upon entry to a rule. Access field
     * {@link //_ctx} get the current context.
     */
    enterRule(localctx, state, ruleIndex) {
        this.state = state;
        this._ctx = localctx;
        this._ctx.start = this._input.LT(1);
        if (this.buildParseTrees) {
            this.addContextToParseTree();
        }
        this.triggerEnterRuleEvent();
    }
    exitRule() {
        this._ctx.stop = this._input.LT(-1);
        // trigger event on _ctx, before it reverts to parent
        this.triggerExitRuleEvent();
        this.state = this._ctx.invokingState;
        this._ctx = this._ctx.parentCtx;
    }
    enterOuterAlt(localctx, altNum) {
        localctx.setAltNumber(altNum);
        // if we have new localctx, make sure we replace existing ctx
        // that is previous child of parse tree
        if (this.buildParseTrees && this._ctx !== localctx) {
            if (this._ctx.parentCtx !== null) {
                this._ctx.parentCtx.removeLastChild();
                this._ctx.parentCtx.addChild(localctx);
            }
        }
        this._ctx = localctx;
    }
    /**
     * Get the precedence level for the top-most precedence rule.
     *
     * @return The precedence level for the top-most precedence rule, or -1 if
     * the parser context is not nested within a precedence rule.
     */
    getPrecedence() {
        if (this._precedenceStack.length === 0) {
            return -1;
        }
        else {
            return this._precedenceStack[this._precedenceStack.length - 1];
        }
    }
    enterRecursionRule(localctx, state, ruleIndex, precedence) {
        this.state = state;
        this._precedenceStack.push(precedence);
        this._ctx = localctx;
        this._ctx.start = this._input.LT(1);
        this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
    }
    // Like {@link //enterRule} but for recursive rules.
    pushNewRecursionContext(localctx, state, ruleIndex) {
        const previous = this._ctx;
        previous.parentCtx = localctx;
        previous.invokingState = state;
        previous.stop = this._input.LT(-1);
        this._ctx = localctx;
        this._ctx.start = previous.start;
        if (this.buildParseTrees) {
            this._ctx.addChild(previous);
        }
        this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
    }
    unrollRecursionContexts(parentCtx) {
        this._precedenceStack.pop();
        this._ctx.stop = this._input.LT(-1);
        const retCtx = this._ctx; // save current ctx (return value)
        // unroll so _ctx is as it was before call to recursive method
        const parseListeners = this.getParseListeners();
        if (parseListeners !== null && parseListeners.length > 0) {
            while (this._ctx !== parentCtx) {
                this.triggerExitRuleEvent();
                this._ctx = this._ctx.parentCtx;
            }
        }
        else {
            this._ctx = parentCtx;
        }
        // hook into tree
        retCtx.parentCtx = parentCtx;
        if (this.buildParseTrees && parentCtx !== null) {
            // add return ctx into invoking rule's tree
            parentCtx.addChild(retCtx);
        }
    }
    getInvokingContext(ruleIndex) {
        let ctx = this._ctx;
        while (ctx !== null) {
            if (ctx.ruleIndex === ruleIndex) {
                return ctx;
            }
            ctx = ctx.parentCtx;
        }
        return null;
    }
    precpred(localctx, precedence) {
        return precedence >= this._precedenceStack[this._precedenceStack.length - 1];
    }
    inContext(context) {
        // TODO: useful in parser?
        return false;
    }
    /**
     * Checks whether or not {@code symbol} can follow the current state in the
     * ATN. The behavior of this method is equivalent to the following, but is
     * implemented such that the complete context-sensitive follow set does not
     * need to be explicitly constructed.
     *
     * <pre>
     * return getExpectedTokens().contains(symbol);
     * </pre>
     *
     * @param symbol the symbol type to check
     * @return {@code true} if {@code symbol} can follow the current state in
     * the ATN, otherwise {@code false}.
     */
    isExpectedToken(symbol) {
        const atn = this._interp.atn;
        let ctx = this._ctx;
        const s = atn.states[this.state];
        let following = atn.nextTokens(s);
        if (following.contains(symbol)) {
            return true;
        }
        if (!following.contains(Token_js_1.default.EPSILON)) {
            return false;
        }
        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token_js_1.default.EPSILON)) {
            const invokingState = atn.states[ctx.invokingState];
            const rt = invokingState.transitions[0];
            following = atn.nextTokens(rt.followState);
            if (following.contains(symbol)) {
                return true;
            }
            ctx = ctx.parentCtx;
        }
        if (following.contains(Token_js_1.default.EPSILON) && symbol === Token_js_1.default.EOF) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Computes the set of input symbols which could follow the current parser
     * state and context, as given by {@link //getState} and {@link //getContext},
     * respectively.
     *
     * @see ATN//getExpectedTokens(int, RuleContext)
     */
    getExpectedTokens() {
        return this._interp.atn.getExpectedTokens(this.state, this._ctx);
    }
    getExpectedTokensWithinCurrentRule() {
        const atn = this._interp.atn;
        const s = atn.states[this.state];
        return atn.nextTokens(s);
    }
    // Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.
    getRuleIndex(ruleName) {
        const ruleIndex = this.getRuleIndexMap()[ruleName];
        if (ruleIndex !== null) {
            return ruleIndex;
        }
        else {
            return -1;
        }
    }
    /**
     * Return List&lt;String&gt; of the rule names in your parser instance
     * leading up to a call to the current rule. You could override if
     * you want more details such as the file/line info of where
     * in the ATN a rule is invoked.
     *
     * this is very useful for error messages.
     */
    getRuleInvocationStack(p) {
        p = p || null;
        if (p === null) {
            p = this._ctx;
        }
        const stack = [];
        while (p !== null) {
            // compute what follows who invoked us
            const ruleIndex = p.ruleIndex;
            if (ruleIndex < 0) {
                stack.push("n/a");
            }
            else {
                stack.push(this.ruleNames[ruleIndex]);
            }
            p = p.parentCtx;
        }
        return stack;
    }
    // For debugging and other purposes.
    getDFAStrings() {
        return this._interp.decisionToDFA.toString();
    }
    // For debugging and other purposes.
    dumpDFA() {
        let seenOne = false;
        for (let i = 0; i < this._interp.decisionToDFA.length; i++) {
            const dfa = this._interp.decisionToDFA[i];
            if (dfa.states.length > 0) {
                if (seenOne) {
                    console.log();
                }
                this.printer.println("Decision " + dfa.decision + ":");
                this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
                seenOne = true;
            }
        }
    }
    /*
        "			printer = function() {\r\n" +
        "				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
        "				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
        "			};\r\n" +
        */
    getSourceName() {
        return this._input.sourceName;
    }
    /**
     * During a parse is sometimes useful to listen in on the rule entry and exit
     * events as well as token matches. this is for quick and dirty debugging.
     */
    setTrace(trace) {
        if (!trace) {
            this.removeParseListener(this._tracer);
            this._tracer = null;
        }
        else {
            if (this._tracer !== null) {
                this.removeParseListener(this._tracer);
            }
            this._tracer = new TraceListener_js_1.default(this);
            this.addParseListener(this._tracer);
        }
    }
}
exports["default"] = Parser;
/**
 * this field maps from the serialized ATN string to the deserialized {@link
    * ATN} with
 * bypass alternatives.
 *
 * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
 */
Parser.bypassAltsAtnCache = {};
//# sourceMappingURL=Parser.js.map

/***/ }),

/***/ 4489:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const ConsoleErrorListener_js_1 = __importDefault(__webpack_require__(3640));
const ProxyErrorListener_js_1 = __importDefault(__webpack_require__(1163));
class Recognizer {
    constructor() {
        this._listeners = [ConsoleErrorListener_js_1.default.INSTANCE];
        this._interp = null;
        this._stateNumber = -1;
    }
    checkVersion(toolVersion) {
        const runtimeVersion = "4.10.1";
        if (runtimeVersion !== toolVersion) {
            console.log("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
        }
    }
    addErrorListener(listener) {
        this._listeners.push(listener);
    }
    removeErrorListeners() {
        this._listeners = [];
    }
    getLiteralNames() {
        return Object.getPrototypeOf(this).constructor.literalNames || [];
    }
    getSymbolicNames() {
        return Object.getPrototypeOf(this).constructor.symbolicNames || [];
    }
    getTokenNames() {
        if (!this.tokenNames) {
            const literalNames = this.getLiteralNames();
            const symbolicNames = this.getSymbolicNames();
            const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;
            this.tokenNames = [];
            for (let i = 0; i < length; i++) {
                this.tokenNames[i] = literalNames[i] || symbolicNames[i] || "<INVALID";
            }
        }
        return this.tokenNames;
    }
    getTokenTypeMap() {
        const tokenNames = this.getTokenNames();
        if (tokenNames === null) {
            throw ("The current recognizer does not provide a list of token names.");
        }
        let result = this.tokenTypeMapCache[tokenNames];
        if (result === undefined) {
            result = tokenNames.reduce(function (o, k, i) { o[k] = i; });
            result.EOF = Token_js_1.default.EOF;
            this.tokenTypeMapCache[tokenNames] = result;
        }
        return result;
    }
    /**
     * Get a map from rule names to rule indexes.
     * <p>Used for XPath and tree pattern compilation.</p>
     */
    getRuleIndexMap() {
        const ruleNames = this.ruleNames;
        if (ruleNames === null) {
            throw ("The current recognizer does not provide a list of rule names.");
        }
        let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?
        if (result === undefined) {
            result = ruleNames.reduce(function (o, k, i) { o[k] = i; });
            this.ruleIndexMapCache[ruleNames] = result;
        }
        return result;
    }
    getTokenType(tokenName) {
        const ttype = this.getTokenTypeMap()[tokenName];
        if (ttype !== undefined) {
            return ttype;
        }
        else {
            return Token_js_1.default.INVALID_TYPE;
        }
    }
    // What is the error header, normally line/character position information?
    getErrorHeader(e) {
        const line = e.getOffendingToken().line;
        const column = e.getOffendingToken().column;
        return "line " + line + ":" + column;
    }
    /**
     * How should a token be displayed in an error message? The default
     * is to display just the text, but during development you might
     * want to have a lot of information spit out.  Override in that case
     * to use t.toString() (which, for CommonToken, dumps everything about
     * the token). This is better than forcing you to override a method in
     * your token objects because you don't have to go modify your lexer
     * so that it creates a new Java type.
     *
     * @deprecated This method is not called by the ANTLR 4 Runtime. Specific
     * implementations of {@link ANTLRErrorStrategy} may provide a similar
     * feature when necessary. For example, see
     * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/
    getTokenErrorDisplay(t) {
        if (t === null) {
            return "<no token>";
        }
        let s = t.text;
        if (s === null) {
            if (t.type === Token_js_1.default.EOF) {
                s = "<EOF>";
            }
            else {
                s = "<" + t.type + ">";
            }
        }
        s = s.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
        return "'" + s + "'";
    }
    getErrorListenerDispatch() {
        return new ProxyErrorListener_js_1.default(this._listeners);
    }
    /**
     * subclass needs to override these if there are sempreds or actions
     * that the ATN interp needs to execute
     */
    sempred(localctx, ruleIndex, actionIndex) {
        return true;
    }
    precpred(localctx, precedence) {
        return true;
    }
    get state() {
        return this._stateNumber;
    }
    set state(state) {
        this._stateNumber = state;
    }
}
exports["default"] = Recognizer;
Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};
//# sourceMappingURL=Recognizer.js.map

/***/ }),

/***/ 5319:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * A token has properties: text, type, line, character position in the line
 * (so we can ignore tabs), token channel, index, and source from which
 * we obtained this token.
 */
class Token {
    constructor() {
        this.source = null;
        this.type = null; // token type of the token
        this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL
        this.start = null; // optional; return -1 if not implemented.
        this.stop = null; // optional; return -1 if not implemented.
        this.tokenIndex = null; // from 0..n-1 of the token object in the input stream
        this.line = null; // line=1..n of the 1st character
        this.column = null; // beginning of the line at which it occurs, 0..n-1
        this._text = null; // text of the token.
    }
    getTokenSource() {
        return this.source[0];
    }
    getInputStream() {
        return this.source[1];
    }
    get text() {
        return this._text;
    }
    set text(text) {
        this._text = text;
    }
}
exports["default"] = Token;
Token.INVALID_TYPE = 0;
/**
 * During lookahead operations, this "token" signifies we hit rule end ATN state
 * and did not follow it despite needing to.
 */
Token.EPSILON = -2;
Token.MIN_USER_TOKEN_TYPE = 1;
Token.EOF = -1;
/**
 * All tokens go to the parser (unless skip() is called in that rule)
 * on a particular "channel". The parser tunes to a particular channel
 * so that whitespace etc... can go to the parser on a "hidden" channel.
 */
Token.DEFAULT_CHANNEL = 0;
/**
 * Anything on different channel than DEFAULT_CHANNEL is not parsed
 * by parser.
 */
Token.HIDDEN_CHANNEL = 1;
//# sourceMappingURL=Token.js.map

/***/ }),

/***/ 7002:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
// this is just to keep meaningful parameter types to Parser
class TokenStream {
}
exports["default"] = TokenStream;
//# sourceMappingURL=TokenStream.js.map

/***/ }),

/***/ 1812:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ParseTreeListener_js_1 = __importDefault(__webpack_require__(7648));
class TraceListener extends ParseTreeListener_js_1.default {
    constructor(parser) {
        super();
        this.parser = parser;
    }
    enterEveryRule(ctx) {
        console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
    visitTerminal(node) {
        console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
    }
    exitEveryRule(ctx) {
        console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
    }
}
exports["default"] = TraceListener;
//# sourceMappingURL=TraceListener.js.map

/***/ }),

/***/ 2673:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class LexerAction {
    constructor(action) {
        this.actionType = action;
        this.isPositionDependent = false;
    }
    hashCode() {
        const hash = new HashCode_js_1.default();
        this.updateHashCode(hash);
        return hash.finish();
    }
    updateHashCode(hash) {
        hash.update(this.actionType);
    }
    equals(other) {
        return this === other;
    }
}
exports["default"] = LexerAction;
//# sourceMappingURL=LexerAction.js.map

/***/ }),

/***/ 481:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
/**
 * Implements the {@code channel} lexer action by calling
 * {@link Lexer//setChannel} with the assigned channel.
 * Constructs a new {@code channel} action with the specified channel value.
 * @param channel The channel value to pass to {@link Lexer//setChannel}
 */
class LexerChannelAction extends LexerAction_js_1.default {
    constructor(channel) {
        super(LexerActionType_js_1.default.CHANNEL);
        this.channel = channel;
    }
    /**
     * <p>This action is implemented by calling {@link Lexer//setChannel} with the
     * value provided by {@link //getChannel}.</p>
     */
    execute(lexer) {
        lexer._channel = this.channel;
    }
    updateHashCode(hash) {
        hash.update(this.actionType, this.channel);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof LexerChannelAction)) {
            return false;
        }
        else {
            return this.channel === other.channel;
        }
    }
    toString() {
        return "channel(" + this.channel + ")";
    }
}
exports["default"] = LexerChannelAction;
//# sourceMappingURL=LexerChannelAction.js.map

/***/ }),

/***/ 8281:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
/**
 * Executes a custom lexer action by calling {@link Recognizer//action} with the
 * rule and action indexes assigned to the custom action. The implementation of
 * a custom action is added to the generated code for the lexer in an override
 * of {@link Recognizer//action} when the grammar is compiled.
 *
 * <p>This class may represent embedded actions created with the <code>{...}</code>
 * syntax in ANTLR 4, as well as actions created for lexer commands where the
 * command argument could not be evaluated when the grammar was compiled.</p>
 */
class LexerCustomAction extends LexerAction_js_1.default {
    /**
     * Constructs a custom lexer action with the specified rule and action
     * indexes.
     *
     * @param ruleIndex The rule index to use for calls to
     * {@link Recognizer//action}.
     * @param actionIndex The action index to use for calls to
     * {@link Recognizer//action}.
     */
    constructor(ruleIndex, actionIndex) {
        super(LexerActionType_js_1.default.CUSTOM);
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex;
        this.isPositionDependent = true;
    }
    /**
     * <p>Custom actions are implemented by calling {@link Lexer//action} with the
     * appropriate rule and action indexes.</p>
     */
    execute(lexer) {
        lexer.action(null, this.ruleIndex, this.actionIndex);
    }
    updateHashCode(hash) {
        hash.update(this.actionType, this.ruleIndex, this.actionIndex);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof LexerCustomAction)) {
            return false;
        }
        else {
            return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
        }
    }
}
exports["default"] = LexerCustomAction;
//# sourceMappingURL=LexerCustomAction.js.map

/***/ }),

/***/ 6844:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/**
 * This implementation of {@link LexerAction} is used for tracking input offsets
 * for position-dependent actions within a {@link LexerActionExecutor}.
 *
 * <p>This action is not serialized as part of the ATN, and is only required for
 * position-dependent lexer actions which appear at a location other than the
 * end of a rule. For more information about DFA optimizations employed for
 * lexer actions, see {@link LexerActionExecutor//append} and
 * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>
 *
 * Constructs a new indexed custom action by associating a character offset
 * with a {@link LexerAction}.
 *
 * <p>Note: This class is only required for lexer actions for which
 * {@link LexerAction//isPositionDependent} returns {@code true}.</p>
 *
 * @param offset The offset into the input {@link CharStream}, relative to
 * the token start index, at which the specified lexer action should be
 * executed.
 * @param action The lexer action to execute at a particular offset in the
 * input {@link CharStream}.
 */
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
class LexerIndexedCustomAction extends LexerAction_js_1.default {
    constructor(offset, action) {
        super(action.actionType);
        this.offset = offset;
        this.action = action;
        this.isPositionDependent = true;
    }
    /**
     * <p>This method calls {@link //execute} on the result of {@link //getAction}
     * using the provided {@code lexer}.</p>
     */
    execute(lexer) {
        // assume the input stream position was properly set by the calling code
        this.action.execute(lexer);
    }
    updateHashCode(hash) {
        hash.update(this.actionType, this.offset, this.action);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof LexerIndexedCustomAction)) {
            return false;
        }
        else {
            return this.offset === other.offset && this.action === other.action;
        }
    }
}
exports["default"] = LexerIndexedCustomAction;
//# sourceMappingURL=LexerIndexedCustomAction.js.map

/***/ }),

/***/ 7643:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
/**
 * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
 * the assigned mode
 */
class LexerModeAction extends LexerAction_js_1.default {
    constructor(mode) {
        super(LexerActionType_js_1.default.MODE);
        this.mode = mode;
    }
    /**
     * <p>This action is implemented by calling {@link Lexer//mode} with the
     * value provided by {@link //getMode}.</p>
     */
    execute(lexer) {
        lexer.mode(this.mode);
    }
    updateHashCode(hash) {
        hash.update(this.actionType, this.mode);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof LexerModeAction)) {
            return false;
        }
        else {
            return this.mode === other.mode;
        }
    }
    toString() {
        return "mode(" + this.mode + ")";
    }
}
exports["default"] = LexerModeAction;
//# sourceMappingURL=LexerModeAction.js.map

/***/ }),

/***/ 2593:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
/**
 * Implements the {@code more} lexer action by calling {@link Lexer//more}.
 *
 * <p>The {@code more} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerMoreAction extends LexerAction_js_1.default {
    constructor() {
        super(LexerActionType_js_1.default.MORE);
    }
    /**
     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
     */
    execute(lexer) {
        lexer.more();
    }
    toString() {
        return "more";
    }
}
exports["default"] = LexerMoreAction;
LexerMoreAction.INSTANCE = new LexerMoreAction();
//# sourceMappingURL=LexerMoreAction.js.map

/***/ }),

/***/ 3818:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
/**
 * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
 *
 * <p>The {@code popMode} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerPopModeAction extends LexerAction_js_1.default {
    constructor() {
        super(LexerActionType_js_1.default.POP_MODE);
    }
    /**
     * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
     */
    execute(lexer) {
        lexer.popMode();
    }
    toString() {
        return "popMode";
    }
}
exports["default"] = LexerPopModeAction;
LexerPopModeAction.INSTANCE = new LexerPopModeAction();
//# sourceMappingURL=LexerPopModeAction.js.map

/***/ }),

/***/ 8938:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
/**
 * Implements the {@code pushMode} lexer action by calling
 * {@link Lexer//pushMode} with the assigned mode
 */
class LexerPushModeAction extends LexerAction_js_1.default {
    constructor(mode) {
        super(LexerActionType_js_1.default.PUSH_MODE);
        this.mode = mode;
    }
    /**
     * <p>This action is implemented by calling {@link Lexer//pushMode} with the
     * value provided by {@link //getMode}.</p>
     */
    execute(lexer) {
        lexer.pushMode(this.mode);
    }
    updateHashCode(hash) {
        hash.update(this.actionType, this.mode);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof LexerPushModeAction)) {
            return false;
        }
        else {
            return this.mode === other.mode;
        }
    }
    toString() {
        return "pushMode(" + this.mode + ")";
    }
}
exports["default"] = LexerPushModeAction;
//# sourceMappingURL=LexerPushModeAction.js.map

/***/ }),

/***/ 6421:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
/**
 * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.
 *
 * <p>The {@code skip} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */
class LexerSkipAction extends LexerAction_js_1.default {
    constructor() {
        super(LexerActionType_js_1.default.SKIP);
    }
    execute(lexer) {
        lexer.skip();
    }
    toString() {
        return "skip";
    }
}
exports["default"] = LexerSkipAction;
// Provides a singleton instance of this parameterless lexer action.
LexerSkipAction.INSTANCE = new LexerSkipAction();
//# sourceMappingURL=LexerSkipAction.js.map

/***/ }),

/***/ 8446:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerAction_js_1 = __importDefault(__webpack_require__(2673));
/**
 * Implements the {@code type} lexer action by calling {@link Lexer//setType}
 * with the assigned type
 */
class LexerTypeAction extends LexerAction_js_1.default {
    constructor(type) {
        super(LexerActionType_js_1.default.TYPE);
        this.type = type;
    }
    execute(lexer) {
        lexer.type = this.type;
    }
    updateHashCode(hash) {
        hash.update(this.actionType, this.type);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof LexerTypeAction)) {
            return false;
        }
        else {
            return this.type === other.type;
        }
    }
    toString() {
        return "type(" + this.type + ")";
    }
}
exports["default"] = LexerTypeAction;
//# sourceMappingURL=LexerTypeAction.js.map

/***/ }),

/***/ 3600:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LL1Analyzer_js_1 = __importDefault(__webpack_require__(2367));
const IntervalSet_js_1 = __importDefault(__webpack_require__(619));
const Token_js_1 = __importDefault(__webpack_require__(5319));
class ATN {
    constructor(grammarType, maxTokenType) {
        /**
         * Used for runtime deserialization of ATNs from strings
         * The type of the ATN.
        */
        this.grammarType = grammarType;
        // The maximum value for any symbol recognized by a transition in the ATN.
        this.maxTokenType = maxTokenType;
        this.states = [];
        /**
         * Each subrule/rule is a decision point and we must track them so we
         * can go back later and build DFA predictors for them.  This includes
         * all the rules, subrules, optional blocks, ()+, ()* etc...
         */
        this.decisionToState = [];
        // Maps from rule index to starting state number.
        this.ruleToStartState = [];
        // Maps from rule index to stop state number.
        this.ruleToStopState = null;
        this.modeNameToStartState = {};
        /**
         * For lexer ATNs, this maps the rule index to the resulting token type.
         * For parser ATNs, this maps the rule index to the generated bypass token
         * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
         * deserialization option was specified; otherwise, this is {@code null}
         */
        this.ruleToTokenType = null;
        /**
         * For lexer ATNs, this is an array of {@link LexerAction} objects which may
         * be referenced by action transitions in the ATN
         */
        this.lexerActions = null;
        this.modeToStartState = [];
    }
    /**
     * Compute the set of valid tokens that can occur starting in state {@code s}.
     * If {@code ctx} is null, the set of tokens will not include what can follow
     * the rule surrounding {@code s}. In other words, the set will be
     * restricted to tokens reachable staying within {@code s}'s rule
     */
    nextTokensInContext(s, ctx) {
        const anal = new LL1Analyzer_js_1.default(this);
        return anal.LOOK(s, null, ctx);
    }
    /**
     * Compute the set of valid tokens that can occur starting in {@code s} and
     * staying in same rule. {@link Token//EPSILON} is in set if we reach end of
     * rule
     */
    nextTokensNoContext(s) {
        if (s.nextTokenWithinRule !== null) {
            return s.nextTokenWithinRule;
        }
        s.nextTokenWithinRule = this.nextTokensInContext(s, null);
        s.nextTokenWithinRule.readOnly = true;
        return s.nextTokenWithinRule;
    }
    nextTokens(s, ctx) {
        if (ctx === undefined) {
            return this.nextTokensNoContext(s);
        }
        else {
            return this.nextTokensInContext(s, ctx);
        }
    }
    addState(state) {
        if (state !== null) {
            state.atn = this;
            state.stateNumber = this.states.length;
        }
        this.states.push(state);
    }
    removeState(state) {
        this.states[state.stateNumber] = null; // just free mem, don't shift states in list
    }
    defineDecisionState(s) {
        this.decisionToState.push(s);
        s.decision = this.decisionToState.length - 1;
        return s.decision;
    }
    getDecisionState(decision) {
        if (this.decisionToState.length === 0) {
            return null;
        }
        else {
            return this.decisionToState[decision];
        }
    }
    /**
     * Computes the set of input symbols which could follow ATN state number
     * {@code stateNumber} in the specified full {@code context}. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token//EOF} is added to the returned set.
     *
     * <p>If {@code context} is {@code null}, it is treated as
     * {@link ParserRuleContext//EMPTY}.</p>
     *
     * @param stateNumber the ATN state number
     * @param ctx the full parse context
     *
     * @return {IntervalSet} The set of potentially valid input symbols which could follow the
     * specified state in the specified context.
     *
     * @throws IllegalArgumentException if the ATN does not contain a state with
     * number {@code stateNumber}
     */
    getExpectedTokens(stateNumber, ctx) {
        if (stateNumber < 0 || stateNumber >= this.states.length) {
            throw ("Invalid state number.");
        }
        const s = this.states[stateNumber];
        let following = this.nextTokens(s);
        if (!following.contains(Token_js_1.default.EPSILON)) {
            return following;
        }
        const expected = new IntervalSet_js_1.default();
        expected.addSet(following);
        expected.removeOne(Token_js_1.default.EPSILON);
        while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token_js_1.default.EPSILON)) {
            const invokingState = this.states[ctx.invokingState];
            const rt = invokingState.transitions[0];
            following = this.nextTokens(rt.followState);
            expected.addSet(following);
            expected.removeOne(Token_js_1.default.EPSILON);
            ctx = ctx.parentCtx;
        }
        if (following.contains(Token_js_1.default.EPSILON)) {
            expected.addOne(Token_js_1.default.EOF);
        }
        return expected;
    }
}
exports["default"] = ATN;
ATN.INVALID_ALT_NUMBER = 0;
//# sourceMappingURL=ATN.js.map

/***/ }),

/***/ 3864:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const SemanticContext_js_1 = __importDefault(__webpack_require__(2105));
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
function checkParams(params, isCfg) {
    if (params === null) {
        const result = { state: null, alt: null, context: null, semanticContext: null };
        if (isCfg) {
            result.reachesIntoOuterContext = 0;
        }
        return result;
    }
    else {
        const props = {};
        props.state = params.state || null;
        props.alt = (params.alt === undefined) ? null : params.alt;
        props.context = params.context || null;
        props.semanticContext = params.semanticContext || null;
        if (isCfg) {
            props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
            props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
        }
        return props;
    }
}
class ATNConfig {
    /**
     * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).
     * The syntactic context is a graph-structured stack node whose
     * path(s) to the root is the rule invocation(s)
     * chain used to arrive at the state.  The semantic context is
     * the tree of semantic predicates encountered before reaching
     * an ATN state
     */
    constructor(params, config) {
        this.checkContext(params, config);
        params = checkParams(params);
        config = checkParams(config, true);
        // The ATN state associated with this configuration///
        this.state = params.state !== null ? params.state : config.state;
        // What alt (or lexer rule) is predicted by this configuration///
        this.alt = params.alt !== null ? params.alt : config.alt;
        /**
         * The stack of invoking states leading to the rule/states associated
         * with this config.  We track only those contexts pushed during
         * execution of the ATN simulator
         */
        this.context = params.context !== null ? params.context : config.context;
        this.semanticContext = params.semanticContext !== null ? params.semanticContext :
            (config.semanticContext !== null ? config.semanticContext : SemanticContext_js_1.default.NONE);
        // TODO: make it a boolean then
        /**
         * We cannot execute predicates dependent upon local context unless
         * we know for sure we are in the correct context. Because there is
         * no way to do this efficiently, we simply cannot evaluate
         * dependent predicates unless we are in the rule that initially
         * invokes the ATN simulator.
         * closure() tracks the depth of how far we dip into the
         * outer context: depth &gt; 0.  Note that it may not be totally
         * accurate depth since I don't ever decrement
         */
        this.reachesIntoOuterContext = config.reachesIntoOuterContext;
        this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
    }
    checkContext(params, config) {
        if ((params.context === null || params.context === undefined) &&
            (config === null || config.context === null || config.context === undefined)) {
            this.context = null;
        }
    }
    hashCode() {
        const hash = new HashCode_js_1.default();
        this.updateHashCode(hash);
        return hash.finish();
    }
    updateHashCode(hash) {
        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
    }
    /**
     * An ATN configuration is equal to another if both have
     * the same state, they predict the same alternative, and
     * syntactic/semantic contexts are the same
     */
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof ATNConfig)) {
            return false;
        }
        else {
            return this.state.stateNumber === other.state.stateNumber &&
                this.alt === other.alt &&
                (this.context === null ? other.context === null : this.context.equals(other.context)) &&
                this.semanticContext.equals(other.semanticContext) &&
                this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
        }
    }
    hashCodeForConfigSet() {
        const hash = new HashCode_js_1.default();
        hash.update(this.state.stateNumber, this.alt, this.semanticContext);
        return hash.finish();
    }
    equalsForConfigSet(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof ATNConfig)) {
            return false;
        }
        else {
            return this.state.stateNumber === other.state.stateNumber &&
                this.alt === other.alt &&
                this.semanticContext.equals(other.semanticContext);
        }
    }
    toString() {
        return "(" + this.state + "," + this.alt +
            (this.context !== null ? ",[" + this.context.toString() + "]" : "") +
            (this.semanticContext !== SemanticContext_js_1.default.NONE ?
                ("," + this.semanticContext.toString())
                : "") +
            (this.reachesIntoOuterContext > 0 ?
                (",up=" + this.reachesIntoOuterContext)
                : "") + ")";
    }
}
exports["default"] = ATNConfig;
//# sourceMappingURL=ATNConfig.js.map

/***/ }),

/***/ 8254:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ATN_js_1 = __importDefault(__webpack_require__(3600));
const SemanticContext_js_1 = __importDefault(__webpack_require__(2105));
const PredictionContextUtils_js_1 = __webpack_require__(4747);
const arrayToString_js_1 = __importDefault(__webpack_require__(1324));
const HashSet_js_1 = __importDefault(__webpack_require__(5563));
const equalArrays_js_1 = __importDefault(__webpack_require__(1267));
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
function hashATNConfig(c) {
    return c.hashCodeForConfigSet();
}
function equalATNConfigs(a, b) {
    if (a === b) {
        return true;
    }
    else if (a === null || b === null) {
        return false;
    }
    else
        return a.equalsForConfigSet(b);
}
/**
 * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track
 * info about the set, with support for combining similar configurations using a
 * graph-structured stack
 */
class ATNConfigSet {
    constructor(fullCtx) {
        /**
         * The reason that we need this is because we don't want the hash map to use
         * the standard hash code and equals. We need all configurations with the
         * same
         * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively
         * doubles
         * the number of objects associated with ATNConfigs. The other solution is
         * to
         * use a hash table that lets us specify the equals/hashcode operation.
         * All configs but hashed by (s, i, _, pi) not including context. Wiped out
         * when we go readonly as this set becomes a DFA state
         */
        this.configLookup = new HashSet_js_1.default(hashATNConfig, equalATNConfigs);
        /**
         * Indicates that this configuration set is part of a full context
         * LL prediction. It will be used to determine how to merge $. With SLL
         * it's a wildcard whereas it is not for LL context merge
         */
        this.fullCtx = fullCtx === undefined ? true : fullCtx;
        /**
         * Indicates that the set of configurations is read-only. Do not
         * allow any code to manipulate the set; DFA states will point at
         * the sets and they must not change. This does not protect the other
         * fields; in particular, conflictingAlts is set after
         * we've made this readonly
         */
        this.readOnly = false;
        // Track the elements as they are added to the set; supports get(i)///
        this.configs = [];
        // TODO: these fields make me pretty uncomfortable but nice to pack up info
        // together, saves recomputation
        // TODO: can we track conflicts as they are added to save scanning configs
        // later?
        this.uniqueAlt = 0;
        this.conflictingAlts = null;
        /**
         * Used in parser and lexer. In lexer, it indicates we hit a pred
         * while computing a closure operation. Don't make a DFA state from this
         */
        this.hasSemanticContext = false;
        this.dipsIntoOuterContext = false;
        this.cachedHashCode = -1;
    }
    /**
     * Adding a new config means merging contexts with existing configs for
     * {@code (s, i, pi, _)}, where {@code s} is the
     * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
     * {@code pi} is the {@link ATNConfig//semanticContext}. We use
     * {@code (s,i,pi)} as key.
     *
     * <p>This method updates {@link //dipsIntoOuterContext} and
     * {@link //hasSemanticContext} when necessary.</p>
     */
    add(config, mergeCache) {
        if (mergeCache === undefined) {
            mergeCache = null;
        }
        if (this.readOnly) {
            throw "This set is readonly";
        }
        if (config.semanticContext !== SemanticContext_js_1.default.NONE) {
            this.hasSemanticContext = true;
        }
        if (config.reachesIntoOuterContext > 0) {
            this.dipsIntoOuterContext = true;
        }
        const existing = this.configLookup.add(config);
        if (existing === config) {
            this.cachedHashCode = -1;
            this.configs.push(config); // track order here
            return true;
        }
        // a previous (s,i,pi,_), merge with it and save result
        const rootIsWildcard = !this.fullCtx;
        const merged = (0, PredictionContextUtils_js_1.merge)(existing.context, config.context, rootIsWildcard, mergeCache);
        /**
         * no need to check for existing.context, config.context in cache
         * since only way to create new graphs is "call rule" and here. We
         * cache at both places
         */
        existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext);
        // make sure to preserve the precedence filter suppression during the merge
        if (config.precedenceFilterSuppressed) {
            existing.precedenceFilterSuppressed = true;
        }
        existing.context = merged; // replace context; no need to alt mapping
        return true;
    }
    getStates() {
        const states = new HashSet_js_1.default();
        for (let i = 0; i < this.configs.length; i++) {
            states.add(this.configs[i].state);
        }
        return states;
    }
    getPredicates() {
        const preds = [];
        for (let i = 0; i < this.configs.length; i++) {
            const c = this.configs[i].semanticContext;
            if (c !== SemanticContext_js_1.default.NONE) {
                preds.push(c.semanticContext);
            }
        }
        return preds;
    }
    optimizeConfigs(interpreter) {
        if (this.readOnly) {
            throw "This set is readonly";
        }
        if (this.configLookup.length === 0) {
            return;
        }
        for (let i = 0; i < this.configs.length; i++) {
            const config = this.configs[i];
            config.context = interpreter.getCachedContext(config.context);
        }
    }
    addAll(coll) {
        for (let i = 0; i < coll.length; i++) {
            this.add(coll[i]);
        }
        return false;
    }
    equals(other) {
        return this === other ||
            (other instanceof ATNConfigSet &&
                (0, equalArrays_js_1.default)(this.configs, other.configs) &&
                this.fullCtx === other.fullCtx &&
                this.uniqueAlt === other.uniqueAlt &&
                this.conflictingAlts === other.conflictingAlts &&
                this.hasSemanticContext === other.hasSemanticContext &&
                this.dipsIntoOuterContext === other.dipsIntoOuterContext);
    }
    hashCode() {
        const hash = new HashCode_js_1.default();
        hash.update(this.configs);
        return hash.finish();
    }
    updateHashCode(hash) {
        if (this.readOnly) {
            if (this.cachedHashCode === -1) {
                this.cachedHashCode = this.hashCode();
            }
            hash.update(this.cachedHashCode);
        }
        else {
            hash.update(this.hashCode());
        }
    }
    isEmpty() {
        return this.configs.length === 0;
    }
    contains(item) {
        if (this.configLookup === null) {
            throw "This method is not implemented for readonly sets.";
        }
        return this.configLookup.contains(item);
    }
    containsFast(item) {
        if (this.configLookup === null) {
            throw "This method is not implemented for readonly sets.";
        }
        return this.configLookup.containsFast(item);
    }
    clear() {
        if (this.readOnly) {
            throw "This set is readonly";
        }
        this.configs = [];
        this.cachedHashCode = -1;
        this.configLookup = new HashSet_js_1.default();
    }
    setReadonly(readOnly) {
        this.readOnly = readOnly;
        if (readOnly) {
            this.configLookup = null; // can't mod, no need for lookup cache
        }
    }
    toString() {
        return (0, arrayToString_js_1.default)(this.configs) +
            (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") +
            (this.uniqueAlt !== ATN_js_1.default.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") +
            (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") +
            (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
    }
    get items() {
        return this.configs;
    }
    get length() {
        return this.configs.length;
    }
}
exports["default"] = ATNConfigSet;
//# sourceMappingURL=ATNConfigSet.js.map

/***/ }),

/***/ 6477:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
class ATNDeserializationOptions {
    constructor(copyFrom) {
        if (copyFrom === undefined) {
            copyFrom = null;
        }
        this.readOnly = false;
        this.verifyATN = copyFrom === null ? true : copyFrom.verifyATN;
        this.generateRuleBypassTransitions = copyFrom === null ? false : copyFrom.generateRuleBypassTransitions;
    }
}
exports["default"] = ATNDeserializationOptions;
ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true;
//# sourceMappingURL=ATNDeserializationOptions.js.map

/***/ }),

/***/ 8833:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const ATN_js_1 = __importDefault(__webpack_require__(3600));
const ATNType_js_1 = __importDefault(__webpack_require__(1463));
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
const BasicState_js_1 = __importDefault(__webpack_require__(5518));
const DecisionState_js_1 = __importDefault(__webpack_require__(8923));
const BlockStartState_js_1 = __importDefault(__webpack_require__(4762));
const BlockEndState_js_1 = __importDefault(__webpack_require__(7064));
const LoopEndState_js_1 = __importDefault(__webpack_require__(4635));
const RuleStartState_js_1 = __importDefault(__webpack_require__(2240));
const RuleStopState_js_1 = __importDefault(__webpack_require__(1385));
const TokensStartState_js_1 = __importDefault(__webpack_require__(9705));
const PlusLoopbackState_js_1 = __importDefault(__webpack_require__(335));
const StarLoopbackState_js_1 = __importDefault(__webpack_require__(2184));
const StarLoopEntryState_js_1 = __importDefault(__webpack_require__(6832));
const PlusBlockStartState_js_1 = __importDefault(__webpack_require__(4926));
const StarBlockStartState_js_1 = __importDefault(__webpack_require__(8394));
const BasicBlockStartState_js_1 = __importDefault(__webpack_require__(5895));
const Transition_js_1 = __importDefault(__webpack_require__(738));
const AtomTransition_js_1 = __importDefault(__webpack_require__(6696));
const SetTransition_js_1 = __importDefault(__webpack_require__(3823));
const NotSetTransition_js_1 = __importDefault(__webpack_require__(5571));
const RuleTransition_js_1 = __importDefault(__webpack_require__(9128));
const RangeTransition_js_1 = __importDefault(__webpack_require__(5719));
const ActionTransition_js_1 = __importDefault(__webpack_require__(1580));
const EpsilonTransition_js_1 = __importDefault(__webpack_require__(6107));
const WildcardTransition_js_1 = __importDefault(__webpack_require__(9646));
const PredicateTransition_js_1 = __importDefault(__webpack_require__(6614));
const PrecedencePredicateTransition_js_1 = __importDefault(__webpack_require__(7571));
const IntervalSet_js_1 = __importDefault(__webpack_require__(619));
const ATNDeserializationOptions_js_1 = __importDefault(__webpack_require__(6477));
const LexerActionType_js_1 = __importDefault(__webpack_require__(4273));
const LexerSkipAction_js_1 = __importDefault(__webpack_require__(6421));
const LexerChannelAction_js_1 = __importDefault(__webpack_require__(481));
const LexerCustomAction_js_1 = __importDefault(__webpack_require__(8281));
const LexerMoreAction_js_1 = __importDefault(__webpack_require__(2593));
const LexerTypeAction_js_1 = __importDefault(__webpack_require__(8446));
const LexerPushModeAction_js_1 = __importDefault(__webpack_require__(8938));
const LexerPopModeAction_js_1 = __importDefault(__webpack_require__(3818));
const LexerModeAction_js_1 = __importDefault(__webpack_require__(7643));
const SERIALIZED_VERSION = 4;
function initArray(length, value) {
    const tmp = [];
    tmp[length - 1] = value;
    return tmp.map(function (i) { return value; });
}
class ATNDeserializer {
    constructor(options) {
        if (options === undefined || options === null) {
            options = ATNDeserializationOptions_js_1.default.defaultOptions;
        }
        this.deserializationOptions = options;
        this.stateFactories = null;
        this.actionFactories = null;
    }
    deserialize(data) {
        const legacy = this.reset(data);
        this.checkVersion(legacy);
        if (legacy)
            this.skipUUID();
        const atn = this.readATN();
        this.readStates(atn, legacy);
        this.readRules(atn, legacy);
        this.readModes(atn);
        const sets = [];
        this.readSets(atn, sets, this.readInt.bind(this));
        if (legacy)
            this.readSets(atn, sets, this.readInt32.bind(this));
        this.readEdges(atn, sets);
        this.readDecisions(atn);
        this.readLexerActions(atn, legacy);
        this.markPrecedenceDecisions(atn);
        this.verifyATN(atn);
        if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType_js_1.default.PARSER) {
            this.generateRuleBypassTransitions(atn);
            // re-verify after modification
            this.verifyATN(atn);
        }
        return atn;
    }
    reset(data) {
        const version = data.charCodeAt ? data.charCodeAt(0) : data[0];
        if (version === SERIALIZED_VERSION - 1) {
            const adjust = function (c) {
                const v = c.charCodeAt(0);
                return v > 1 ? v - 2 : v + 65534;
            };
            const temp = data.split("").map(adjust);
            // don't adjust the first value since that's the version number
            temp[0] = data.charCodeAt(0);
            this.data = temp;
            this.pos = 0;
            return true;
        }
        else {
            this.data = data;
            this.pos = 0;
            return false;
        }
    }
    skipUUID() {
        let count = 0;
        while (count++ < 8)
            this.readInt();
    }
    checkVersion(legacy) {
        const version = this.readInt();
        if (!legacy && version !== SERIALIZED_VERSION) {
            throw ("Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").");
        }
    }
    readATN() {
        const grammarType = this.readInt();
        const maxTokenType = this.readInt();
        return new ATN_js_1.default(grammarType, maxTokenType);
    }
    readStates(atn, legacy) {
        let j, pair, stateNumber;
        const loopBackStateNumbers = [];
        const endStateNumbers = [];
        const nstates = this.readInt();
        for (let i = 0; i < nstates; i++) {
            const stype = this.readInt();
            // ignore bad type of states
            if (stype === ATNState_js_1.default.INVALID_TYPE) {
                atn.addState(null);
                continue;
            }
            let ruleIndex = this.readInt();
            if (legacy && ruleIndex === 0xFFFF) {
                ruleIndex = -1;
            }
            const s = this.stateFactory(stype, ruleIndex);
            if (stype === ATNState_js_1.default.LOOP_END) { // special case
                const loopBackStateNumber = this.readInt();
                loopBackStateNumbers.push([s, loopBackStateNumber]);
            }
            else if (s instanceof BlockStartState_js_1.default) {
                const endStateNumber = this.readInt();
                endStateNumbers.push([s, endStateNumber]);
            }
            atn.addState(s);
        }
        // delay the assignment of loop back and end states until we know all the
        // state instances have been initialized
        for (j = 0; j < loopBackStateNumbers.length; j++) {
            pair = loopBackStateNumbers[j];
            pair[0].loopBackState = atn.states[pair[1]];
        }
        for (j = 0; j < endStateNumbers.length; j++) {
            pair = endStateNumbers[j];
            pair[0].endState = atn.states[pair[1]];
        }
        let numNonGreedyStates = this.readInt();
        for (j = 0; j < numNonGreedyStates; j++) {
            stateNumber = this.readInt();
            atn.states[stateNumber].nonGreedy = true;
        }
        let numPrecedenceStates = this.readInt();
        for (j = 0; j < numPrecedenceStates; j++) {
            stateNumber = this.readInt();
            atn.states[stateNumber].isPrecedenceRule = true;
        }
    }
    readRules(atn, legacy) {
        let i;
        const nrules = this.readInt();
        if (atn.grammarType === ATNType_js_1.default.LEXER) {
            atn.ruleToTokenType = initArray(nrules, 0);
        }
        atn.ruleToStartState = initArray(nrules, 0);
        for (i = 0; i < nrules; i++) {
            const s = this.readInt();
            atn.ruleToStartState[i] = atn.states[s];
            if (atn.grammarType === ATNType_js_1.default.LEXER) {
                let tokenType = this.readInt();
                if (legacy && tokenType === 0xFFFF) {
                    tokenType = Token_js_1.default.EOF;
                }
                atn.ruleToTokenType[i] = tokenType;
            }
        }
        atn.ruleToStopState = initArray(nrules, 0);
        for (i = 0; i < atn.states.length; i++) {
            const state = atn.states[i];
            if (!(state instanceof RuleStopState_js_1.default)) {
                continue;
            }
            atn.ruleToStopState[state.ruleIndex] = state;
            atn.ruleToStartState[state.ruleIndex].stopState = state;
        }
    }
    readModes(atn) {
        const nmodes = this.readInt();
        for (let i = 0; i < nmodes; i++) {
            let s = this.readInt();
            atn.modeToStartState.push(atn.states[s]);
        }
    }
    readSets(atn, sets, reader) {
        const m = this.readInt();
        for (let i = 0; i < m; i++) {
            const iset = new IntervalSet_js_1.default();
            sets.push(iset);
            const n = this.readInt();
            const containsEof = this.readInt();
            if (containsEof !== 0) {
                iset.addOne(-1);
            }
            for (let j = 0; j < n; j++) {
                const i1 = reader();
                const i2 = reader();
                iset.addRange(i1, i2);
            }
        }
    }
    readEdges(atn, sets) {
        let i, j, state, trans, target;
        const nedges = this.readInt();
        for (i = 0; i < nedges; i++) {
            const src = this.readInt();
            const trg = this.readInt();
            const ttype = this.readInt();
            const arg1 = this.readInt();
            const arg2 = this.readInt();
            const arg3 = this.readInt();
            trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
            const srcState = atn.states[src];
            srcState.addTransition(trans);
        }
        // edges for rule stop states can be derived, so they aren't serialized
        for (i = 0; i < atn.states.length; i++) {
            state = atn.states[i];
            for (j = 0; j < state.transitions.length; j++) {
                const t = state.transitions[j];
                if (!(t instanceof RuleTransition_js_1.default)) {
                    continue;
                }
                let outermostPrecedenceReturn = -1;
                if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
                    if (t.precedence === 0) {
                        outermostPrecedenceReturn = t.target.ruleIndex;
                    }
                }
                trans = new EpsilonTransition_js_1.default(t.followState, outermostPrecedenceReturn);
                atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
            }
        }
        for (i = 0; i < atn.states.length; i++) {
            state = atn.states[i];
            if (state instanceof BlockStartState_js_1.default) {
                // we need to know the end state to set its start state
                if (state.endState === null) {
                    throw ("IllegalState");
                }
                // block end states can only be associated to a single block start
                // state
                if (state.endState.startState !== null) {
                    throw ("IllegalState");
                }
                state.endState.startState = state;
            }
            if (state instanceof PlusLoopbackState_js_1.default) {
                for (j = 0; j < state.transitions.length; j++) {
                    target = state.transitions[j].target;
                    if (target instanceof PlusBlockStartState_js_1.default) {
                        target.loopBackState = state;
                    }
                }
            }
            else if (state instanceof StarLoopbackState_js_1.default) {
                for (j = 0; j < state.transitions.length; j++) {
                    target = state.transitions[j].target;
                    if (target instanceof StarLoopEntryState_js_1.default) {
                        target.loopBackState = state;
                    }
                }
            }
        }
    }
    readDecisions(atn) {
        const ndecisions = this.readInt();
        for (let i = 0; i < ndecisions; i++) {
            const s = this.readInt();
            const decState = atn.states[s];
            atn.decisionToState.push(decState);
            decState.decision = i;
        }
    }
    readLexerActions(atn, legacy) {
        if (atn.grammarType === ATNType_js_1.default.LEXER) {
            const count = this.readInt();
            atn.lexerActions = initArray(count, null);
            for (let i = 0; i < count; i++) {
                const actionType = this.readInt();
                let data1 = this.readInt();
                if (legacy && data1 === 0xFFFF) {
                    data1 = -1;
                }
                let data2 = this.readInt();
                if (legacy && data2 === 0xFFFF) {
                    data2 = -1;
                }
                atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);
            }
        }
    }
    generateRuleBypassTransitions(atn) {
        let i;
        const count = atn.ruleToStartState.length;
        for (i = 0; i < count; i++) {
            atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
        }
        for (i = 0; i < count; i++) {
            this.generateRuleBypassTransition(atn, i);
        }
    }
    generateRuleBypassTransition(atn, idx) {
        let i, state;
        const bypassStart = new BasicBlockStartState_js_1.default();
        bypassStart.ruleIndex = idx;
        atn.addState(bypassStart);
        const bypassStop = new BlockEndState_js_1.default();
        bypassStop.ruleIndex = idx;
        atn.addState(bypassStop);
        bypassStart.endState = bypassStop;
        atn.defineDecisionState(bypassStart);
        bypassStop.startState = bypassStart;
        let excludeTransition = null;
        let endState = null;
        if (atn.ruleToStartState[idx].isPrecedenceRule) {
            // wrap from the beginning of the rule to the StarLoopEntryState
            endState = null;
            for (i = 0; i < atn.states.length; i++) {
                state = atn.states[i];
                if (this.stateIsEndStateFor(state, idx)) {
                    endState = state;
                    excludeTransition = state.loopBackState.transitions[0];
                    break;
                }
            }
            if (excludeTransition === null) {
                throw ("Couldn't identify final state of the precedence rule prefix section.");
            }
        }
        else {
            endState = atn.ruleToStopState[idx];
        }
        // all non-excluded transitions that currently target end state need to
        // target blockEnd instead
        for (i = 0; i < atn.states.length; i++) {
            state = atn.states[i];
            for (let j = 0; j < state.transitions.length; j++) {
                const transition = state.transitions[j];
                if (transition === excludeTransition) {
                    continue;
                }
                if (transition.target === endState) {
                    transition.target = bypassStop;
                }
            }
        }
        // all transitions leaving the rule start state need to leave blockStart
        // instead
        const ruleToStartState = atn.ruleToStartState[idx];
        const count = ruleToStartState.transitions.length;
        while (count > 0) {
            bypassStart.addTransition(ruleToStartState.transitions[count - 1]);
            ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
        }
        // link the new states
        atn.ruleToStartState[idx].addTransition(new EpsilonTransition_js_1.default(bypassStart));
        bypassStop.addTransition(new EpsilonTransition_js_1.default(endState));
        const matchState = new BasicState_js_1.default();
        atn.addState(matchState);
        matchState.addTransition(new AtomTransition_js_1.default(bypassStop, atn.ruleToTokenType[idx]));
        bypassStart.addTransition(new EpsilonTransition_js_1.default(matchState));
    }
    stateIsEndStateFor(state, idx) {
        if (state.ruleIndex !== idx) {
            return null;
        }
        if (!(state instanceof StarLoopEntryState_js_1.default)) {
            return null;
        }
        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
        if (!(maybeLoopEndState instanceof LoopEndState_js_1.default)) {
            return null;
        }
        if (maybeLoopEndState.epsilonOnlyTransitions &&
            (maybeLoopEndState.transitions[0].target instanceof RuleStopState_js_1.default)) {
            return state;
        }
        else {
            return null;
        }
    }
    /**
     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
     * the {@link StarLoopEntryState//isPrecedenceDecision} field to the
     * correct value.
     * @param atn The ATN.
     */
    markPrecedenceDecisions(atn) {
        for (let i = 0; i < atn.states.length; i++) {
            const state = atn.states[i];
            if (!(state instanceof StarLoopEntryState_js_1.default)) {
                continue;
            }
            // We analyze the ATN to determine if this ATN decision state is the
            // decision for the closure block that determines whether a
            // precedence rule should continue or complete.
            if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
                const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;
                if (maybeLoopEndState instanceof LoopEndState_js_1.default) {
                    if (maybeLoopEndState.epsilonOnlyTransitions &&
                        (maybeLoopEndState.transitions[0].target instanceof RuleStopState_js_1.default)) {
                        state.isPrecedenceDecision = true;
                    }
                }
            }
        }
    }
    verifyATN(atn) {
        if (!this.deserializationOptions.verifyATN) {
            return;
        }
        // verify assumptions
        for (let i = 0; i < atn.states.length; i++) {
            const state = atn.states[i];
            if (state === null) {
                continue;
            }
            this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);
            if (state instanceof PlusBlockStartState_js_1.default) {
                this.checkCondition(state.loopBackState !== null);
            }
            else if (state instanceof StarLoopEntryState_js_1.default) {
                this.checkCondition(state.loopBackState !== null);
                this.checkCondition(state.transitions.length === 2);
                if (state.transitions[0].target instanceof StarBlockStartState_js_1.default) {
                    this.checkCondition(state.transitions[1].target instanceof LoopEndState_js_1.default);
                    this.checkCondition(!state.nonGreedy);
                }
                else if (state.transitions[0].target instanceof LoopEndState_js_1.default) {
                    this.checkCondition(state.transitions[1].target instanceof StarBlockStartState_js_1.default);
                    this.checkCondition(state.nonGreedy);
                }
                else {
                    throw ("IllegalState");
                }
            }
            else if (state instanceof StarLoopbackState_js_1.default) {
                this.checkCondition(state.transitions.length === 1);
                this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState_js_1.default);
            }
            else if (state instanceof LoopEndState_js_1.default) {
                this.checkCondition(state.loopBackState !== null);
            }
            else if (state instanceof RuleStartState_js_1.default) {
                this.checkCondition(state.stopState !== null);
            }
            else if (state instanceof BlockStartState_js_1.default) {
                this.checkCondition(state.endState !== null);
            }
            else if (state instanceof BlockEndState_js_1.default) {
                this.checkCondition(state.startState !== null);
            }
            else if (state instanceof DecisionState_js_1.default) {
                this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
            }
            else {
                this.checkCondition(state.transitions.length <= 1 || (state instanceof RuleStopState_js_1.default));
            }
        }
    }
    checkCondition(condition, message) {
        if (!condition) {
            if (message === undefined || message === null) {
                message = "IllegalState";
            }
            throw (message);
        }
    }
    readInt() {
        return this.data[this.pos++];
    }
    readInt32() {
        const low = this.readInt();
        const high = this.readInt();
        return low | (high << 16);
    }
    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
        const target = atn.states[trg];
        switch (type) {
            case Transition_js_1.default.EPSILON:
                return new EpsilonTransition_js_1.default(target);
            case Transition_js_1.default.RANGE:
                return arg3 !== 0 ? new RangeTransition_js_1.default(target, Token_js_1.default.EOF, arg2) : new RangeTransition_js_1.default(target, arg1, arg2);
            case Transition_js_1.default.RULE:
                return new RuleTransition_js_1.default(atn.states[arg1], arg2, arg3, target);
            case Transition_js_1.default.PREDICATE:
                return new PredicateTransition_js_1.default(target, arg1, arg2, arg3 !== 0);
            case Transition_js_1.default.PRECEDENCE:
                return new PrecedencePredicateTransition_js_1.default(target, arg1);
            case Transition_js_1.default.ATOM:
                return arg3 !== 0 ? new AtomTransition_js_1.default(target, Token_js_1.default.EOF) : new AtomTransition_js_1.default(target, arg1);
            case Transition_js_1.default.ACTION:
                return new ActionTransition_js_1.default(target, arg1, arg2, arg3 !== 0);
            case Transition_js_1.default.SET:
                return new SetTransition_js_1.default(target, sets[arg1]);
            case Transition_js_1.default.NOT_SET:
                return new NotSetTransition_js_1.default(target, sets[arg1]);
            case Transition_js_1.default.WILDCARD:
                return new WildcardTransition_js_1.default(target);
            default:
                throw "The specified transition type: " + type + " is not valid.";
        }
    }
    stateFactory(type, ruleIndex) {
        if (this.stateFactories === null) {
            const sf = [];
            sf[ATNState_js_1.default.INVALID_TYPE] = null;
            sf[ATNState_js_1.default.BASIC] = () => new BasicState_js_1.default();
            sf[ATNState_js_1.default.RULE_START] = () => new RuleStartState_js_1.default();
            sf[ATNState_js_1.default.BLOCK_START] = () => new BasicBlockStartState_js_1.default();
            sf[ATNState_js_1.default.PLUS_BLOCK_START] = () => new PlusBlockStartState_js_1.default();
            sf[ATNState_js_1.default.STAR_BLOCK_START] = () => new StarBlockStartState_js_1.default();
            sf[ATNState_js_1.default.TOKEN_START] = () => new TokensStartState_js_1.default();
            sf[ATNState_js_1.default.RULE_STOP] = () => new RuleStopState_js_1.default();
            sf[ATNState_js_1.default.BLOCK_END] = () => new BlockEndState_js_1.default();
            sf[ATNState_js_1.default.STAR_LOOP_BACK] = () => new StarLoopbackState_js_1.default();
            sf[ATNState_js_1.default.STAR_LOOP_ENTRY] = () => new StarLoopEntryState_js_1.default();
            sf[ATNState_js_1.default.PLUS_LOOP_BACK] = () => new PlusLoopbackState_js_1.default();
            sf[ATNState_js_1.default.LOOP_END] = () => new LoopEndState_js_1.default();
            this.stateFactories = sf;
        }
        if (type > this.stateFactories.length || this.stateFactories[type] === null) {
            throw ("The specified state type " + type + " is not valid.");
        }
        else {
            const s = this.stateFactories[type]();
            if (s !== null) {
                s.ruleIndex = ruleIndex;
                return s;
            }
        }
    }
    lexerActionFactory(type, data1, data2) {
        if (this.actionFactories === null) {
            const af = [];
            af[LexerActionType_js_1.default.CHANNEL] = (data1, data2) => new LexerChannelAction_js_1.default(data1);
            af[LexerActionType_js_1.default.CUSTOM] = (data1, data2) => new LexerCustomAction_js_1.default(data1, data2);
            af[LexerActionType_js_1.default.MODE] = (data1, data2) => new LexerModeAction_js_1.default(data1);
            af[LexerActionType_js_1.default.MORE] = (data1, data2) => LexerMoreAction_js_1.default.INSTANCE;
            af[LexerActionType_js_1.default.POP_MODE] = (data1, data2) => LexerPopModeAction_js_1.default.INSTANCE;
            af[LexerActionType_js_1.default.PUSH_MODE] = (data1, data2) => new LexerPushModeAction_js_1.default(data1);
            af[LexerActionType_js_1.default.SKIP] = (data1, data2) => LexerSkipAction_js_1.default.INSTANCE;
            af[LexerActionType_js_1.default.TYPE] = (data1, data2) => new LexerTypeAction_js_1.default(data1);
            this.actionFactories = af;
        }
        if (type > this.actionFactories.length || this.actionFactories[type] === null) {
            throw ("The specified lexer action type " + type + " is not valid.");
        }
        else {
            return this.actionFactories[type](data1, data2);
        }
    }
}
exports["default"] = ATNDeserializer;
//# sourceMappingURL=ATNDeserializer.js.map

/***/ }),

/***/ 1332:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const DFAState_js_1 = __importDefault(__webpack_require__(2603));
const ATNConfigSet_js_1 = __importDefault(__webpack_require__(8254));
const PredictionContextUtils_js_1 = __webpack_require__(4747);
const HashMap_js_1 = __importDefault(__webpack_require__(1935));
class ATNSimulator {
    constructor(atn, sharedContextCache) {
        /**
         * The context cache maps all PredictionContext objects that are ==
         * to a single cached copy. This cache is shared across all contexts
         * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
         * to use only cached nodes/graphs in addDFAState(). We don't want to
         * fill this during closure() since there are lots of contexts that
         * pop up but are not used ever again. It also greatly slows down closure().
         *
         * <p>This cache makes a huge difference in memory and a little bit in speed.
         * For the Java grammar on java.*, it dropped the memory requirements
         * at the end from 25M to 16M. We don't store any of the full context
         * graphs in the DFA because they are limited to local context only,
         * but apparently there's a lot of repetition there as well. We optimize
         * the config contexts before storing the config set in the DFA states
         * by literally rebuilding them with cached subgraphs only.</p>
         *
         * <p>I tried a cache for use during closure operations, that was
         * whacked after each adaptivePredict(). It cost a little bit
         * more time I think and doesn't save on the overall footprint
         * so it's not worth the complexity.</p>
         */
        this.atn = atn;
        this.sharedContextCache = sharedContextCache;
        return this;
    }
    getCachedContext(context) {
        if (this.sharedContextCache === null) {
            return context;
        }
        const visited = new HashMap_js_1.default();
        return (0, PredictionContextUtils_js_1.getCachedPredictionContext)(context, this.sharedContextCache, visited);
    }
}
exports["default"] = ATNSimulator;
// Must distinguish between missing edge and edge we know leads nowhere///
ATNSimulator.ERROR = new DFAState_js_1.default(0x7FFFFFFF, new ATNConfigSet_js_1.default());
//# sourceMappingURL=ATNSimulator.js.map

/***/ }),

/***/ 1463:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Represents the type of recognizer an ATN applies to
 */
exports["default"] = {
    LEXER: 0,
    PARSER: 1
};
//# sourceMappingURL=ATNType.js.map

/***/ }),

/***/ 3468:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Transition_js_1 = __importDefault(__webpack_require__(738));
class AbstractPredicateTransition extends Transition_js_1.default {
    constructor(target) {
        super(target);
    }
}
exports["default"] = AbstractPredicateTransition;
//# sourceMappingURL=AbstractPredicateTransition.js.map

/***/ }),

/***/ 2367:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const ATNConfig_js_1 = __importDefault(__webpack_require__(3864));
const IntervalSet_js_1 = __importDefault(__webpack_require__(619));
const RuleStopState_js_1 = __importDefault(__webpack_require__(1385));
const RuleTransition_js_1 = __importDefault(__webpack_require__(9128));
const NotSetTransition_js_1 = __importDefault(__webpack_require__(5571));
const WildcardTransition_js_1 = __importDefault(__webpack_require__(9646));
const AbstractPredicateTransition_js_1 = __importDefault(__webpack_require__(3468));
const PredictionContextUtils_js_1 = __webpack_require__(4747);
const PredictionContext_js_1 = __importDefault(__webpack_require__(748));
const SingletonPredictionContext_js_1 = __importDefault(__webpack_require__(292));
const BitSet_js_1 = __importDefault(__webpack_require__(7149));
const HashSet_js_1 = __importDefault(__webpack_require__(5563));
class LL1Analyzer {
    constructor(atn) {
        this.atn = atn;
    }
    /**
     * Calculates the SLL(1) expected lookahead set for each outgoing transition
     * of an {@link ATNState}. The returned array has one element for each
     * outgoing transition in {@code s}. If the closure from transition
     * <em>i</em> leads to a semantic predicate before matching a symbol, the
     * element at index <em>i</em> of the result will be {@code null}.
     *
     * @param s the ATN state
     * @return the expected symbols for each outgoing transition of {@code s}.
     */
    getDecisionLookahead(s) {
        if (s === null) {
            return null;
        }
        const count = s.transitions.length;
        const look = [];
        for (let alt = 0; alt < count; alt++) {
            look[alt] = new IntervalSet_js_1.default();
            const lookBusy = new HashSet_js_1.default();
            const seeThruPreds = false; // fail to get lookahead upon pred
            this._LOOK(s.transition(alt).target, null, PredictionContext_js_1.default.EMPTY, look[alt], lookBusy, new BitSet_js_1.default(), seeThruPreds, false);
            // Wipe out lookahead for this alternative if we found nothing
            // or we had a predicate when we !seeThruPreds
            if (look[alt].length === 0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
                look[alt] = null;
            }
        }
        return look;
    }
    /**
     * Compute set of tokens that can follow {@code s} in the ATN in the
     * specified {@code ctx}.
     *
     * <p>If {@code ctx} is {@code null} and the end of the rule containing
     * {@code s} is reached, {@link Token//EPSILON} is added to the result set.
     * If {@code ctx} is not {@code null} and the end of the outermost rule is
     * reached, {@link Token//EOF} is added to the result set.</p>
     *
     * @param s the ATN state
     * @param stopState the ATN state to stop at. This can be a
     * {@link BlockEndState} to detect epsilon paths through a closure.
     * @param ctx the complete parser context, or {@code null} if the context
     * should be ignored
     *
     * @return The set of tokens that can follow {@code s} in the ATN in the
     * specified {@code ctx}.
     */
    LOOK(s, stopState, ctx) {
        const r = new IntervalSet_js_1.default();
        const seeThruPreds = true; // ignore preds; get all lookahead
        ctx = ctx || null;
        const lookContext = ctx !== null ? (0, PredictionContextUtils_js_1.predictionContextFromRuleContext)(s.atn, ctx) : null;
        this._LOOK(s, stopState, lookContext, r, new HashSet_js_1.default(), new BitSet_js_1.default(), seeThruPreds, true);
        return r;
    }
    /**
     * Compute set of tokens that can follow {@code s} in the ATN in the
     * specified {@code ctx}.
     *
     * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
     * rule containing {@code s} is reached, {@link Token//EPSILON} is added to
     * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
     * {@code true} and {@code stopState} or the end of the outermost rule is
     * reached, {@link Token//EOF} is added to the result set.</p>
     *
     * @param s the ATN state.
     * @param stopState the ATN state to stop at. This can be a
     * {@link BlockEndState} to detect epsilon paths through a closure.
     * @param ctx The outer context, or {@code null} if the outer context should
     * not be used.
     * @param look The result lookahead set.
     * @param lookBusy A set used for preventing epsilon closures in the ATN
     * from causing a stack overflow. Outside code should pass
     * {@code new CustomizedSet<ATNConfig>} for this argument.
     * @param calledRuleStack A set used for preventing left recursion in the
     * ATN from causing a stack overflow. Outside code should pass
     * {@code new BitSet()} for this argument.
     * @param seeThruPreds {@code true} to true semantic predicates as
     * implicitly {@code true} and "see through them", otherwise {@code false}
     * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
     * result if one is encountered.
     * @param addEOF Add {@link Token//EOF} to the result if the end of the
     * outermost context is reached. This parameter has no effect if {@code ctx}
     * is {@code null}.
     */
    _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
        const c = new ATNConfig_js_1.default({ state: s, alt: 0, context: ctx }, null);
        if (lookBusy.has(c)) {
            return;
        }
        lookBusy.add(c);
        if (s === stopState) {
            if (ctx === null) {
                look.addOne(Token_js_1.default.EPSILON);
                return;
            }
            else if (ctx.isEmpty() && addEOF) {
                look.addOne(Token_js_1.default.EOF);
                return;
            }
        }
        if (s instanceof RuleStopState_js_1.default) {
            if (ctx === null) {
                look.addOne(Token_js_1.default.EPSILON);
                return;
            }
            else if (ctx.isEmpty() && addEOF) {
                look.addOne(Token_js_1.default.EOF);
                return;
            }
            if (ctx !== PredictionContext_js_1.default.EMPTY) {
                const removed = calledRuleStack.has(s.ruleIndex);
                try {
                    calledRuleStack.remove(s.ruleIndex);
                    // run thru all possible stack tops in ctx
                    for (let i = 0; i < ctx.length; i++) {
                        const returnState = this.atn.states[ctx.getReturnState(i)];
                        this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                    }
                }
                finally {
                    if (removed) {
                        calledRuleStack.add(s.ruleIndex);
                    }
                }
                return;
            }
        }
        for (let j = 0; j < s.transitions.length; j++) {
            const t = s.transitions[j];
            if (t.constructor === RuleTransition_js_1.default) {
                if (calledRuleStack.has(t.target.ruleIndex)) {
                    continue;
                }
                const newContext = SingletonPredictionContext_js_1.default.create(ctx, t.followState.stateNumber);
                try {
                    calledRuleStack.add(t.target.ruleIndex);
                    this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                }
                finally {
                    calledRuleStack.remove(t.target.ruleIndex);
                }
            }
            else if (t instanceof AbstractPredicateTransition_js_1.default) {
                if (seeThruPreds) {
                    this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
                }
                else {
                    look.addOne(LL1Analyzer.HIT_PRED);
                }
            }
            else if (t.isEpsilon) {
                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
            }
            else if (t.constructor === WildcardTransition_js_1.default) {
                look.addRange(Token_js_1.default.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
            }
            else {
                let set = t.label;
                if (set !== null) {
                    if (t instanceof NotSetTransition_js_1.default) {
                        set = set.complement(Token_js_1.default.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                    }
                    look.addSet(set);
                }
            }
        }
    }
}
exports["default"] = LL1Analyzer;
/**
 * Special value added to the lookahead sets to indicate that we hit
 * a predicate during analysis if {@code seeThruPreds==false}.
 */
LL1Analyzer.HIT_PRED = Token_js_1.default.INVALID_TYPE;
//# sourceMappingURL=LL1Analyzer.js.map

/***/ }),

/***/ 4446:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const DecisionState_js_1 = __importDefault(__webpack_require__(8923));
const ATNConfig_js_1 = __importDefault(__webpack_require__(3864));
class LexerATNConfig extends ATNConfig_js_1.default {
    constructor(params, config) {
        super(params, config);
        // This is the backing field for {@link //getLexerActionExecutor}.
        const lexerActionExecutor = params.lexerActionExecutor || null;
        this.lexerActionExecutor = lexerActionExecutor || (config !== null ? config.lexerActionExecutor : null);
        this.passedThroughNonGreedyDecision = config !== null ? this.checkNonGreedyDecision(config, this.state) : false;
        this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;
        this.equalsForConfigSet = LexerATNConfig.prototype.equals;
        return this;
    }
    updateHashCode(hash) {
        hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
    }
    equals(other) {
        return this === other ||
            (other instanceof LexerATNConfig &&
                this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision &&
                (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) &&
                super.equals(other));
    }
    checkNonGreedyDecision(source, target) {
        return source.passedThroughNonGreedyDecision ||
            (target instanceof DecisionState_js_1.default) && target.nonGreedy;
    }
}
exports["default"] = LexerATNConfig;
//# sourceMappingURL=LexerATNConfig.js.map

/***/ }),

/***/ 5145:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const Lexer_js_1 = __importDefault(__webpack_require__(4412));
const ATN_js_1 = __importDefault(__webpack_require__(3600));
const ATNSimulator_js_1 = __importDefault(__webpack_require__(1332));
const DFAState_js_1 = __importDefault(__webpack_require__(2603));
const OrderedATNConfigSet_js_1 = __importDefault(__webpack_require__(7779));
const PredictionContext_js_1 = __importDefault(__webpack_require__(748));
const SingletonPredictionContext_js_1 = __importDefault(__webpack_require__(292));
const RuleStopState_js_1 = __importDefault(__webpack_require__(1385));
const LexerATNConfig_js_1 = __importDefault(__webpack_require__(4446));
const Transition_js_1 = __importDefault(__webpack_require__(738));
const LexerActionExecutor_js_1 = __importDefault(__webpack_require__(5934));
const LexerNoViableAltException_js_1 = __importDefault(__webpack_require__(313));
function resetSimState(sim) {
    sim.index = -1;
    sim.line = 0;
    sim.column = -1;
    sim.dfaState = null;
}
class SimState {
    constructor() {
        resetSimState(this);
    }
    reset() {
        resetSimState(this);
    }
}
class LexerATNSimulator extends ATNSimulator_js_1.default {
    /**
     * When we hit an accept state in either the DFA or the ATN, we
     * have to notify the character stream to start buffering characters
     * via {@link IntStream//mark} and record the current state. The current sim state
     * includes the current index into the input, the current line,
     * and current character position in that line. Note that the Lexer is
     * tracking the starting line and characterization of the token. These
     * variables track the "state" of the simulator when it hits an accept state.
     *
     * <p>We track these variables separately for the DFA and ATN simulation
     * because the DFA simulation often has to fail over to the ATN
     * simulation. If the ATN simulation fails, we need the DFA to fall
     * back to its previously accepted state, if any. If the ATN succeeds,
     * then the ATN does the accept and the DFA simulator that invoked it
     * can simply return the predicted token type.</p>
     */
    constructor(recog, atn, decisionToDFA, sharedContextCache) {
        super(atn, sharedContextCache);
        this.decisionToDFA = decisionToDFA;
        this.recog = recog;
        /**
         * The current token's starting index into the character stream.
         * Shared across DFA to ATN simulation in case the ATN fails and the
         * DFA did not have a previous accept state. In this case, we use the
         * ATN-generated exception object
         */
        this.startIndex = -1;
        // line number 1..n within the input///
        this.line = 1;
        /**
         * The index of the character relative to the beginning of the line
         * 0..n-1
         */
        this.column = 0;
        this.mode = Lexer_js_1.default.DEFAULT_MODE;
        /**
         * Used during DFA/ATN exec to record the most recent accept configuration
         * info
         */
        this.prevAccept = new SimState();
    }
    copyState(simulator) {
        this.column = simulator.column;
        this.line = simulator.line;
        this.mode = simulator.mode;
        this.startIndex = simulator.startIndex;
    }
    match(input, mode) {
        this.mode = mode;
        const mark = input.mark();
        try {
            this.startIndex = input.index;
            this.prevAccept.reset();
            const dfa = this.decisionToDFA[mode];
            if (dfa.s0 === null) {
                return this.matchATN(input);
            }
            else {
                return this.execATN(input, dfa.s0);
            }
        }
        finally {
            input.release(mark);
        }
    }
    reset() {
        this.prevAccept.reset();
        this.startIndex = -1;
        this.line = 1;
        this.column = 0;
        this.mode = Lexer_js_1.default.DEFAULT_MODE;
    }
    matchATN(input) {
        const startState = this.atn.modeToStartState[this.mode];
        if (LexerATNSimulator.debug) {
            console.log("matchATN mode " + this.mode + " start: " + startState);
        }
        const old_mode = this.mode;
        const s0_closure = this.computeStartState(input, startState);
        const suppressEdge = s0_closure.hasSemanticContext;
        s0_closure.hasSemanticContext = false;
        const next = this.addDFAState(s0_closure);
        if (!suppressEdge) {
            this.decisionToDFA[this.mode].s0 = next;
        }
        const predict = this.execATN(input, next);
        if (LexerATNSimulator.debug) {
            console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
        }
        return predict;
    }
    execATN(input, ds0) {
        if (LexerATNSimulator.debug) {
            console.log("start state closure=" + ds0.configs);
        }
        if (ds0.isAcceptState) {
            // allow zero-length tokens
            this.captureSimState(this.prevAccept, input, ds0);
        }
        let t = input.LA(1);
        let s = ds0; // s is current/from DFA state
        for (;;) { // while more work
            if (LexerATNSimulator.debug) {
                console.log("execATN loop starting closure: " + s.configs);
            }
            /**
             * As we move src->trg, src->trg, we keep track of the previous trg to
             * avoid looking up the DFA state again, which is expensive.
             * If the previous target was already part of the DFA, we might
             * be able to avoid doing a reach operation upon t. If s!=null,
             * it means that semantic predicates didn't prevent us from
             * creating a DFA state. Once we know s!=null, we check to see if
             * the DFA state has an edge already for t. If so, we can just reuse
             * it's configuration set; there's no point in re-computing it.
             * This is kind of like doing DFA simulation within the ATN
             * simulation because DFA simulation is really just a way to avoid
             * computing reach/closure sets. Technically, once we know that
             * we have a previously added DFA state, we could jump over to
             * the DFA simulator. But, that would mean popping back and forth
             * a lot and making things more complicated algorithmically.
             * This optimization makes a lot of sense for loops within DFA.
             * A character will take us back to an existing DFA state
             * that already has lots of edges out of it. e.g., .* in comments.
             * print("Target for:" + str(s) + " and:" + str(t))
             */
            let target = this.getExistingTargetState(s, t);
            // print("Existing:" + str(target))
            if (target === null) {
                target = this.computeTargetState(input, s, t);
                // print("Computed:" + str(target))
            }
            if (target === ATNSimulator_js_1.default.ERROR) {
                break;
            }
            // If this is a consumable input element, make sure to consume before
            // capturing the accept state so the input index, line, and char
            // position accurately reflect the state of the interpreter at the
            // end of the token.
            if (t !== Token_js_1.default.EOF) {
                this.consume(input);
            }
            if (target.isAcceptState) {
                this.captureSimState(this.prevAccept, input, target);
                if (t === Token_js_1.default.EOF) {
                    break;
                }
            }
            t = input.LA(1);
            s = target; // flip; current DFA target becomes new src/from state
        }
        return this.failOrAccept(this.prevAccept, input, s.configs, t);
    }
    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns {@code null}.
     *
     * @param s The current DFA state
     * @param t The next input symbol
     * @return The existing target DFA state for the given input symbol
     * {@code t}, or {@code null} if the target state for this edge is not
     * already cached
     */
    getExistingTargetState(s, t) {
        if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
            return null;
        }
        let target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];
        if (target === undefined) {
            target = null;
        }
        if (LexerATNSimulator.debug && target !== null) {
            console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
        }
        return target;
    }
    /**
     * Compute a target state for an edge in the DFA, and attempt to add the
     * computed state and corresponding edge to the DFA.
     *
     * @param input The input stream
     * @param s The current DFA state
     * @param t The next input symbol
     *
     * @return The computed target DFA state for the given input symbol
     * {@code t}. If {@code t} does not lead to a valid DFA state, this method
     * returns {@link //ERROR}.
     */
    computeTargetState(input, s, t) {
        const reach = new OrderedATNConfigSet_js_1.default();
        // if we don't find an existing DFA state
        // Fill reach starting from closure, following t transitions
        this.getReachableConfigSet(input, s.configs, reach, t);
        if (reach.items.length === 0) { // we got nowhere on t from s
            if (!reach.hasSemanticContext) {
                // we got nowhere on t, don't throw out this knowledge; it'd
                // cause a failover from DFA later.
                this.addDFAEdge(s, t, ATNSimulator_js_1.default.ERROR);
            }
            // stop when we can't match any more char
            return ATNSimulator_js_1.default.ERROR;
        }
        // Add an edge from s to target DFA found/created for reach
        return this.addDFAEdge(s, t, null, reach);
    }
    failOrAccept(prevAccept, input, reach, t) {
        if (this.prevAccept.dfaState !== null) {
            const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
            this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.column);
            return prevAccept.dfaState.prediction;
        }
        else {
            // if no accept and EOF is first char, return EOF
            if (t === Token_js_1.default.EOF && input.index === this.startIndex) {
                return Token_js_1.default.EOF;
            }
            throw new LexerNoViableAltException_js_1.default(this.recog, input, this.startIndex, reach);
        }
    }
    /**
     * Given a starting configuration set, figure out all ATN configurations
     * we can reach upon input {@code t}. Parameter {@code reach} is a return
     * parameter.
     */
    getReachableConfigSet(input, closure, reach, t) {
        // this is used to skip processing for configs which have a lower priority
        // than a config that already reached an accept state for the same rule
        let skipAlt = ATN_js_1.default.INVALID_ALT_NUMBER;
        for (let i = 0; i < closure.items.length; i++) {
            const cfg = closure.items[i];
            const currentAltReachedAcceptState = (cfg.alt === skipAlt);
            if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
                continue;
            }
            if (LexerATNSimulator.debug) {
                console.log("testing %s at %s\n", this.getTokenName(t), cfg
                    .toString(this.recog, true));
            }
            for (let j = 0; j < cfg.state.transitions.length; j++) {
                const trans = cfg.state.transitions[j]; // for each transition
                const target = this.getReachableTarget(trans, t);
                if (target !== null) {
                    let lexerActionExecutor = cfg.lexerActionExecutor;
                    if (lexerActionExecutor !== null) {
                        lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
                    }
                    const treatEofAsEpsilon = (t === Token_js_1.default.EOF);
                    const config = new LexerATNConfig_js_1.default({ state: target, lexerActionExecutor: lexerActionExecutor }, cfg);
                    if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
                        // any remaining configs for this alt have a lower priority
                        // than the one that just reached an accept state.
                        skipAlt = cfg.alt;
                    }
                }
            }
        }
    }
    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
        if (LexerATNSimulator.debug) {
            console.log("ACTION %s\n", lexerActionExecutor);
        }
        // seek to after last char in token
        input.seek(index);
        this.line = line;
        this.column = charPos;
        if (lexerActionExecutor !== null && this.recog !== null) {
            lexerActionExecutor.execute(this.recog, input, startIndex);
        }
    }
    getReachableTarget(trans, t) {
        if (trans.matches(t, 0, Lexer_js_1.default.MAX_CHAR_VALUE)) {
            return trans.target;
        }
        else {
            return null;
        }
    }
    computeStartState(input, p) {
        const initialContext = PredictionContext_js_1.default.EMPTY;
        const configs = new OrderedATNConfigSet_js_1.default();
        for (let i = 0; i < p.transitions.length; i++) {
            const target = p.transitions[i].target;
            const cfg = new LexerATNConfig_js_1.default({ state: target, alt: i + 1, context: initialContext }, null);
            this.closure(input, cfg, configs, false, false, false);
        }
        return configs;
    }
    /**
     * Since the alternatives within any lexer decision are ordered by
     * preference, this method stops pursuing the closure as soon as an accept
     * state is reached. After the first accept state is reached by depth-first
     * search from {@code config}, all other (potentially reachable) states for
     * this rule would have a lower priority.
     *
     * @return {Boolean} {@code true} if an accept state is reached, otherwise
     * {@code false}.
     */
    closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
        let cfg = null;
        if (LexerATNSimulator.debug) {
            console.log("closure(" + config.toString(this.recog, true) + ")");
        }
        if (config.state instanceof RuleStopState_js_1.default) {
            if (LexerATNSimulator.debug) {
                if (this.recog !== null) {
                    console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
                }
                else {
                    console.log("closure at rule stop %s\n", config);
                }
            }
            if (config.context === null || config.context.hasEmptyPath()) {
                if (config.context === null || config.context.isEmpty()) {
                    configs.add(config);
                    return true;
                }
                else {
                    configs.add(new LexerATNConfig_js_1.default({ state: config.state, context: PredictionContext_js_1.default.EMPTY }, config));
                    currentAltReachedAcceptState = true;
                }
            }
            if (config.context !== null && !config.context.isEmpty()) {
                for (let i = 0; i < config.context.length; i++) {
                    if (config.context.getReturnState(i) !== PredictionContext_js_1.default.EMPTY_RETURN_STATE) {
                        const newContext = config.context.getParent(i); // "pop" return state
                        const returnState = this.atn.states[config.context.getReturnState(i)];
                        cfg = new LexerATNConfig_js_1.default({ state: returnState, context: newContext }, config);
                        currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
                    }
                }
            }
            return currentAltReachedAcceptState;
        }
        // optimization
        if (!config.state.epsilonOnlyTransitions) {
            if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
                configs.add(config);
            }
        }
        for (let j = 0; j < config.state.transitions.length; j++) {
            const trans = config.state.transitions[j];
            cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);
            if (cfg !== null) {
                currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
            }
        }
        return currentAltReachedAcceptState;
    }
    // side-effect: can alter configs.hasSemanticContext
    getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {
        let cfg = null;
        if (trans.serializationType === Transition_js_1.default.RULE) {
            const newContext = SingletonPredictionContext_js_1.default.create(config.context, trans.followState.stateNumber);
            cfg = new LexerATNConfig_js_1.default({ state: trans.target, context: newContext }, config);
        }
        else if (trans.serializationType === Transition_js_1.default.PRECEDENCE) {
            throw "Precedence predicates are not supported in lexers.";
        }
        else if (trans.serializationType === Transition_js_1.default.PREDICATE) {
            // Track traversing semantic predicates. If we traverse,
            // we cannot add a DFA state for this "reach" computation
            // because the DFA would not test the predicate again in the
            // future. Rather than creating collections of semantic predicates
            // like v3 and testing them on prediction, v4 will test them on the
            // fly all the time using the ATN not the DFA. This is slower but
            // semantically it's not used that often. One of the key elements to
            // this predicate mechanism is not adding DFA states that see
            // predicates immediately afterwards in the ATN. For example,
            // a : ID {p1}? | ID {p2}? ;
            // should create the start state for rule 'a' (to save start state
            // competition), but should not create target of ID state. The
            // collection of ATN states the following ID references includes
            // states reached by traversing predicates. Since this is when we
            // test them, we cannot cash the DFA state target of ID.
            if (LexerATNSimulator.debug) {
                console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
            }
            configs.hasSemanticContext = true;
            if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
                cfg = new LexerATNConfig_js_1.default({ state: trans.target }, config);
            }
        }
        else if (trans.serializationType === Transition_js_1.default.ACTION) {
            if (config.context === null || config.context.hasEmptyPath()) {
                // execute actions anywhere in the start rule for a token.
                //
                // TODO: if the entry rule is invoked recursively, some
                // actions may be executed during the recursive call. The
                // problem can appear when hasEmptyPath() is true but
                // isEmpty() is false. In this case, the config needs to be
                // split into two contexts - one with just the empty path
                // and another with everything but the empty path.
                // Unfortunately, the current algorithm does not allow
                // getEpsilonTarget to return two configurations, so
                // additional modifications are needed before we can support
                // the split operation.
                const lexerActionExecutor = LexerActionExecutor_js_1.default.append(config.lexerActionExecutor, this.atn.lexerActions[trans.actionIndex]);
                cfg = new LexerATNConfig_js_1.default({ state: trans.target, lexerActionExecutor: lexerActionExecutor }, config);
            }
            else {
                // ignore actions in referenced rules
                cfg = new LexerATNConfig_js_1.default({ state: trans.target }, config);
            }
        }
        else if (trans.serializationType === Transition_js_1.default.EPSILON) {
            cfg = new LexerATNConfig_js_1.default({ state: trans.target }, config);
        }
        else if (trans.serializationType === Transition_js_1.default.ATOM ||
            trans.serializationType === Transition_js_1.default.RANGE ||
            trans.serializationType === Transition_js_1.default.SET) {
            if (treatEofAsEpsilon) {
                if (trans.matches(Token_js_1.default.EOF, 0, Lexer_js_1.default.MAX_CHAR_VALUE)) {
                    cfg = new LexerATNConfig_js_1.default({ state: trans.target }, config);
                }
            }
        }
        return cfg;
    }
    /**
     * Evaluate a predicate specified in the lexer.
     *
     * <p>If {@code speculative} is {@code true}, this method was called before
     * {@link //consume} for the matched character. This method should call
     * {@link //consume} before evaluating the predicate to ensure position
     * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
     * and {@link Lexer//getcolumn}, properly reflect the current
     * lexer state. This method should restore {@code input} and the simulator
     * to the original state before returning (i.e. undo the actions made by the
     * call to {@link //consume}.</p>
     *
     * @param input The input stream.
     * @param ruleIndex The rule containing the predicate.
     * @param predIndex The index of the predicate within the rule.
     * @param speculative {@code true} if the current index in {@code input} is
     * one character before the predicate's location.
     *
     * @return {@code true} if the specified predicate evaluates to
     * {@code true}.
     */
    evaluatePredicate(input, ruleIndex, predIndex, speculative) {
        // assume true if no recognizer was provided
        if (this.recog === null) {
            return true;
        }
        if (!speculative) {
            return this.recog.sempred(null, ruleIndex, predIndex);
        }
        const savedcolumn = this.column;
        const savedLine = this.line;
        const index = input.index;
        const marker = input.mark();
        try {
            this.consume(input);
            return this.recog.sempred(null, ruleIndex, predIndex);
        }
        finally {
            this.column = savedcolumn;
            this.line = savedLine;
            input.seek(index);
            input.release(marker);
        }
    }
    captureSimState(settings, input, dfaState) {
        settings.index = input.index;
        settings.line = this.line;
        settings.column = this.column;
        settings.dfaState = dfaState;
    }
    addDFAEdge(from_, tk, to, cfgs) {
        if (to === undefined) {
            to = null;
        }
        if (cfgs === undefined) {
            cfgs = null;
        }
        if (to === null && cfgs !== null) {
            // leading to this call, ATNConfigSet.hasSemanticContext is used as a
            // marker indicating dynamic predicate evaluation makes this edge
            // dependent on the specific input sequence, so the static edge in the
            // DFA should be omitted. The target DFAState is still created since
            // execATN has the ability to resynchronize with the DFA state cache
            // following the predicate evaluation step.
            //
            // TJP notes: next time through the DFA, we see a pred again and eval.
            // If that gets us to a previously created (but dangling) DFA
            // state, we can continue in pure DFA mode from there.
            // /
            const suppressEdge = cfgs.hasSemanticContext;
            cfgs.hasSemanticContext = false;
            to = this.addDFAState(cfgs);
            if (suppressEdge) {
                return to;
            }
        }
        // add the edge
        if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
            // Only track edges within the DFA bounds
            return to;
        }
        if (LexerATNSimulator.debug) {
            console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
        }
        if (from_.edges === null) {
            // make room for tokens 1..n and -1 masquerading as index 0
            from_.edges = [];
        }
        from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect
        return to;
    }
    /**
     * Add a new DFA state if there isn't one with this set of
     * configurations already. This method also detects the first
     * configuration containing an ATN rule stop state. Later, when
     * traversing the DFA, we will know which rule to accept.
     */
    addDFAState(configs) {
        const proposed = new DFAState_js_1.default(null, configs);
        let firstConfigWithRuleStopState = null;
        for (let i = 0; i < configs.items.length; i++) {
            const cfg = configs.items[i];
            if (cfg.state instanceof RuleStopState_js_1.default) {
                firstConfigWithRuleStopState = cfg;
                break;
            }
        }
        if (firstConfigWithRuleStopState !== null) {
            proposed.isAcceptState = true;
            proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
            proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
        }
        const dfa = this.decisionToDFA[this.mode];
        const existing = dfa.states.get(proposed);
        if (existing !== null) {
            return existing;
        }
        const newState = proposed;
        newState.stateNumber = dfa.states.length;
        configs.setReadonly(true);
        newState.configs = configs;
        dfa.states.add(newState);
        return newState;
    }
    getDFA(mode) {
        return this.decisionToDFA[mode];
    }
    // Get the text matched so far for the current token.
    getText(input) {
        // index is first lookahead char, don't include.
        return input.getText(this.startIndex, input.index - 1);
    }
    consume(input) {
        const curChar = input.LA(1);
        if (curChar === "\n".charCodeAt(0)) {
            this.line += 1;
            this.column = 0;
        }
        else {
            this.column += 1;
        }
        input.consume();
    }
    getTokenName(tt) {
        if (tt === -1) {
            return "EOF";
        }
        else {
            return "'" + String.fromCharCode(tt) + "'";
        }
    }
}
exports["default"] = LexerATNSimulator;
LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;
LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN
//# sourceMappingURL=LexerATNSimulator.js.map

/***/ }),

/***/ 5934:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const LexerIndexedCustomAction_js_1 = __importDefault(__webpack_require__(6844));
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
class LexerActionExecutor {
    /**
     * Represents an executor for a sequence of lexer actions which traversed during
     * the matching operation of a lexer rule (token).
     *
     * <p>The executor tracks position information for position-dependent lexer actions
     * efficiently, ensuring that actions appearing only at the end of the rule do
     * not cause bloating of the {@link DFA} created for the lexer.</p>
     */
    constructor(lexerActions) {
        this.lexerActions = lexerActions === null ? [] : lexerActions;
        /**
         * Caches the result of {@link //hashCode} since the hash code is an element
         * of the performance-critical {@link LexerATNConfig//hashCode} operation
         */
        this.cachedHashCode = HashCode_js_1.default.hashStuff(lexerActions); // "".join([str(la) for la in
        // lexerActions]))
        return this;
    }
    /**
     * Creates a {@link LexerActionExecutor} which encodes the current offset
     * for position-dependent lexer actions.
     *
     * <p>Normally, when the executor encounters lexer actions where
     * {@link LexerAction//isPositionDependent} returns {@code true}, it calls
     * {@link IntStream//seek} on the input {@link CharStream} to set the input
     * position to the <em>end</em> of the current token. This behavior provides
     * for efficient DFA representation of lexer actions which appear at the end
     * of a lexer rule, even when the lexer rule matches a variable number of
     * characters.</p>
     *
     * <p>Prior to traversing a match transition in the ATN, the current offset
     * from the token start index is assigned to all position-dependent lexer
     * actions which have not already been assigned a fixed offset. By storing
     * the offsets relative to the token start index, the DFA representation of
     * lexer actions which appear in the middle of tokens remains efficient due
     * to sharing among tokens of the same length, regardless of their absolute
     * position in the input stream.</p>
     *
     * <p>If the current executor already has offsets assigned to all
     * position-dependent lexer actions, the method returns {@code this}.</p>
     *
     * @param offset The current offset to assign to all position-dependent
     * lexer actions which do not already have offsets assigned.
     *
     * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
     * for all position-dependent lexer actions.
     */
    fixOffsetBeforeMatch(offset) {
        let updatedLexerActions = null;
        for (let i = 0; i < this.lexerActions.length; i++) {
            if (this.lexerActions[i].isPositionDependent &&
                !(this.lexerActions[i] instanceof LexerIndexedCustomAction_js_1.default)) {
                if (updatedLexerActions === null) {
                    updatedLexerActions = this.lexerActions.concat([]);
                }
                updatedLexerActions[i] = new LexerIndexedCustomAction_js_1.default(offset, this.lexerActions[i]);
            }
        }
        if (updatedLexerActions === null) {
            return this;
        }
        else {
            return new LexerActionExecutor(updatedLexerActions);
        }
    }
    /**
     * Execute the actions encapsulated by this executor within the context of a
     * particular {@link Lexer}.
     *
     * <p>This method calls {@link IntStream//seek} to set the position of the
     * {@code input} {@link CharStream} prior to calling
     * {@link LexerAction//execute} on a position-dependent action. Before the
     * method returns, the input position will be restored to the same position
     * it was in when the method was invoked.</p>
     *
     * @param lexer The lexer instance.
     * @param input The input stream which is the source for the current token.
     * When this method is called, the current {@link IntStream//index} for
     * {@code input} should be the start of the following token, i.e. 1
     * character past the end of the current token.
     * @param startIndex The token start index. This value may be passed to
     * {@link IntStream//seek} to set the {@code input} position to the beginning
     * of the token.
     */
    execute(lexer, input, startIndex) {
        let requiresSeek = false;
        const stopIndex = input.index;
        try {
            for (let i = 0; i < this.lexerActions.length; i++) {
                let lexerAction = this.lexerActions[i];
                if (lexerAction instanceof LexerIndexedCustomAction_js_1.default) {
                    const offset = lexerAction.offset;
                    input.seek(startIndex + offset);
                    lexerAction = lexerAction.action;
                    requiresSeek = (startIndex + offset) !== stopIndex;
                }
                else if (lexerAction.isPositionDependent) {
                    input.seek(stopIndex);
                    requiresSeek = false;
                }
                lexerAction.execute(lexer);
            }
        }
        finally {
            if (requiresSeek) {
                input.seek(stopIndex);
            }
        }
    }
    hashCode() {
        return this.cachedHashCode;
    }
    updateHashCode(hash) {
        hash.update(this.cachedHashCode);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof LexerActionExecutor)) {
            return false;
        }
        else if (this.cachedHashCode != other.cachedHashCode) {
            return false;
        }
        else if (this.lexerActions.length != other.lexerActions.length) {
            return false;
        }
        else {
            const numActions = this.lexerActions.length;
            for (let idx = 0; idx < numActions; ++idx) {
                if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
                    return false;
                }
            }
            return true;
        }
    }
    /**
     * Creates a {@link LexerActionExecutor} which executes the actions for
     * the input {@code lexerActionExecutor} followed by a specified
     * {@code lexerAction}.
     *
     * @param lexerActionExecutor The executor for actions already traversed by
     * the lexer while matching a token within a particular
     * {@link LexerATNConfig}. If this is {@code null}, the method behaves as
     * though it were an empty executor.
     * @param lexerAction The lexer action to execute after the actions
     * specified in {@code lexerActionExecutor}.
     *
     * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
     * of {@code lexerActionExecutor} and {@code lexerAction}.
     */
    static append(lexerActionExecutor, lexerAction) {
        if (lexerActionExecutor === null) {
            return new LexerActionExecutor([lexerAction]);
        }
        const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
        return new LexerActionExecutor(lexerActions);
    }
}
exports["default"] = LexerActionExecutor;
//# sourceMappingURL=LexerActionExecutor.js.map

/***/ }),

/***/ 4273:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
exports["default"] = {
    // The type of a {@link LexerChannelAction} action.
    CHANNEL: 0,
    // The type of a {@link LexerCustomAction} action
    CUSTOM: 1,
    // The type of a {@link LexerModeAction} action.
    MODE: 2,
    //The type of a {@link LexerMoreAction} action.
    MORE: 3,
    //The type of a {@link LexerPopModeAction} action.
    POP_MODE: 4,
    //The type of a {@link LexerPushModeAction} action.
    PUSH_MODE: 5,
    //The type of a {@link LexerSkipAction} action.
    SKIP: 6,
    //The type of a {@link LexerTypeAction} action.
    TYPE: 7
};
//# sourceMappingURL=LexerActionType.js.map

/***/ }),

/***/ 7779:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNConfigSet_js_1 = __importDefault(__webpack_require__(8254));
const HashSet_js_1 = __importDefault(__webpack_require__(5563));
class OrderedATNConfigSet extends ATNConfigSet_js_1.default {
    constructor() {
        super();
        this.configLookup = new HashSet_js_1.default();
    }
}
exports["default"] = OrderedATNConfigSet;
//# sourceMappingURL=OrderedATNConfigSet.js.map

/***/ }),

/***/ 1807:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ATN_js_1 = __importDefault(__webpack_require__(3600));
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
const RuleStopState_js_1 = __importDefault(__webpack_require__(1385));
const ATNConfig_js_1 = __importDefault(__webpack_require__(3864));
const ATNConfigSet_js_1 = __importDefault(__webpack_require__(8254));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const DFAState_js_1 = __importDefault(__webpack_require__(2603));
const PredPrediction_js_1 = __importDefault(__webpack_require__(8875));
const ATNSimulator_js_1 = __importDefault(__webpack_require__(1332));
const PredictionMode_js_1 = __importDefault(__webpack_require__(8895));
const RuleContext_js_1 = __importDefault(__webpack_require__(4673));
const SemanticContext_js_1 = __importDefault(__webpack_require__(2105));
const PredictionContext_js_1 = __importDefault(__webpack_require__(748));
const Interval_js_1 = __importDefault(__webpack_require__(4886));
const Transition_js_1 = __importDefault(__webpack_require__(738));
const SetTransition_js_1 = __importDefault(__webpack_require__(3823));
const NotSetTransition_js_1 = __importDefault(__webpack_require__(5571));
const RuleTransition_js_1 = __importDefault(__webpack_require__(9128));
const ActionTransition_js_1 = __importDefault(__webpack_require__(1580));
const NoViableAltException_js_1 = __importDefault(__webpack_require__(1454));
const SingletonPredictionContext_js_1 = __importDefault(__webpack_require__(292));
const PredictionContextUtils_js_1 = __webpack_require__(4747);
const AtomTransition_js_1 = __importDefault(__webpack_require__(6696));
const arrayToString_js_1 = __importDefault(__webpack_require__(1324));
const BitSet_js_1 = __importDefault(__webpack_require__(7149));
const DoubleDict_js_1 = __importDefault(__webpack_require__(1148));
const HashSet_js_1 = __importDefault(__webpack_require__(5563));
/**
 * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
 *
 * <p>
 * The basic complexity of the adaptive strategy makes it harder to understand.
 * We begin with ATN simulation to build paths in a DFA. Subsequent prediction
 * requests go through the DFA first. If they reach a state without an edge for
 * the current symbol, the algorithm fails over to the ATN simulation to
 * complete the DFA path for the current input (until it finds a conflict state
 * or uniquely predicting state).</p>
 *
 * <p>
 * All of that is done without using the outer context because we want to create
 * a DFA that is not dependent upon the rule invocation stack when we do a
 * prediction. One DFA works in all contexts. We avoid using context not
 * necessarily because it's slower, although it can be, but because of the DFA
 * caching problem. The closure routine only considers the rule invocation stack
 * created during prediction beginning in the decision rule. For example, if
 * prediction occurs without invoking another rule's ATN, there are no context
 * stacks in the configurations. When lack of context leads to a conflict, we
 * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
 * strategy (versus full LL(*)).</p>
 *
 * <p>
 * When SLL yields a configuration set with conflict, we rewind the input and
 * retry the ATN simulation, this time using full outer context without adding
 * to the DFA. Configuration context stacks will be the full invocation stacks
 * from the start rule. If we get a conflict using full context, then we can
 * definitively say we have a true ambiguity for that input sequence. If we
 * don't get a conflict, it implies that the decision is sensitive to the outer
 * context. (It is not context-sensitive in the sense of context-sensitive
 * grammars.)</p>
 *
 * <p>
 * The next time we reach this DFA state with an SLL conflict, through DFA
 * simulation, we will again retry the ATN simulation using full context mode.
 * This is slow because we can't save the results and have to "interpret" the
 * ATN each time we get that input.</p>
 *
 * <p>
 * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
 *
 * <p>
 * We could cache results from full context to predicted alternative easily and
 * that saves a lot of time but doesn't work in presence of predicates. The set
 * of visible predicates from the ATN start state changes depending on the
 * context, because closure can fall off the end of a rule. I tried to cache
 * tuples (stack context, semantic context, predicted alt) but it was slower
 * than interpreting and much more complicated. Also required a huge amount of
 * memory. The goal is not to create the world's fastest parser anyway. I'd like
 * to keep this algorithm simple. By launching multiple threads, we can improve
 * the speed of parsing across a large number of files.</p>
 *
 * <p>
 * There is no strict ordering between the amount of input used by SLL vs LL,
 * which makes it really hard to build a cache for full context. Let's say that
 * we have input A B C that leads to an SLL conflict with full context X. That
 * implies that using X we might only use A B but we could also use A B C D to
 * resolve conflict. Input A B C D could predict alternative 1 in one position
 * in the input and A B C E could predict alternative 2 in another position in
 * input. The conflicting SLL configurations could still be non-unique in the
 * full context prediction, which would lead us to requiring more input than the
 * original A B C.	To make a	prediction cache work, we have to track	the exact
 * input	used during the previous prediction. That amounts to a cache that maps
 * X to a specific DFA for that context.</p>
 *
 * <p>
 * Something should be done for left-recursive expression predictions. They are
 * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
 * with full LL thing Sam does.</p>
 *
 * <p>
 * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
 *
 * <p>
 * We avoid doing full context retry when the outer context is empty, we did not
 * dip into the outer context by falling off the end of the decision state rule,
 * or when we force SLL mode.</p>
 *
 * <p>
 * As an example of the not dip into outer context case, consider as super
 * constructor calls versus function calls. One grammar might look like
 * this:</p>
 *
 * <pre>
 * ctorBody
 *   : '{' superCall? stat* '}'
 *   ;
 * </pre>
 *
 * <p>
 * Or, you might see something like</p>
 *
 * <pre>
 * stat
 *   : superCall ';'
 *   | expression ';'
 *   | ...
 *   ;
 * </pre>
 *
 * <p>
 * In both cases I believe that no closure operations will dip into the outer
 * context. In the first case ctorBody in the worst case will stop at the '}'.
 * In the 2nd case it should stop at the ';'. Both cases should stay within the
 * entry rule and not dip into the outer context.</p>
 *
 * <p>
 * <strong>PREDICATES</strong></p>
 *
 * <p>
 * Predicates are always evaluated if present in either SLL or LL both. SLL and
 * LL simulation deals with predicates differently. SLL collects predicates as
 * it performs closure operations like ANTLR v3 did. It delays predicate
 * evaluation until it reaches and accept state. This allows us to cache the SLL
 * ATN simulation whereas, if we had evaluated predicates on-the-fly during
 * closure, the DFA state configuration sets would be different and we couldn't
 * build up a suitable DFA.</p>
 *
 * <p>
 * When building a DFA accept state during ATN simulation, we evaluate any
 * predicates and return the sole semantically valid alternative. If there is
 * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
 * we throw an exception. Alternatives without predicates act like they have
 * true predicates. The simple way to think about it is to strip away all
 * alternatives with false predicates and choose the minimum alternative that
 * remains.</p>
 *
 * <p>
 * When we start in the DFA and reach an accept state that's predicated, we test
 * those and return the minimum semantically viable alternative. If no
 * alternatives are viable, we throw an exception.</p>
 *
 * <p>
 * During full LL ATN simulation, closure always evaluates predicates and
 * on-the-fly. This is crucial to reducing the configuration set size during
 * closure. It hits a landmine when parsing with the Java grammar, for example,
 * without this on-the-fly evaluation.</p>
 *
 * <p>
 * <strong>SHARING DFA</strong></p>
 *
 * <p>
 * All instances of the same parser share the same decision DFAs through a
 * static field. Each instance gets its own ATN simulator but they share the
 * same {@link //decisionToDFA} field. They also share a
 * {@link PredictionContextCache} object that makes sure that all
 * {@link PredictionContext} objects are shared among the DFA states. This makes
 * a big size difference.</p>
 *
 * <p>
 * <strong>THREAD SAFETY</strong></p>
 *
 * <p>
 * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when
 * it adds a new DFA object to that array. {@link //addDFAEdge}
 * locks on the DFA for the current decision when setting the
 * {@link DFAState//edges} field. {@link //addDFAState} locks on
 * the DFA for the current decision when looking up a DFA state to see if it
 * already exists. We must make sure that all requests to add DFA states that
 * are equivalent result in the same shared DFA object. This is because lots of
 * threads will be trying to update the DFA at once. The
 * {@link //addDFAState} method also locks inside the DFA lock
 * but this time on the shared context cache when it rebuilds the
 * configurations' {@link PredictionContext} objects using cached
 * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
 * safe as long as we can guarantee that all threads referencing
 * {@code s.edge[t]} get the same physical target {@link DFAState}, or
 * {@code null}. Once into the DFA, the DFA simulation does not reference the
 * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new
 * targets. The DFA simulator will either find {@link DFAState//edges} to be
 * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
 * {@code dfa.edges[t]} to be non-null. The
 * {@link //addDFAEdge} method could be racing to set the field
 * but in either case the DFA simulator works; if {@code null}, and requests ATN
 * simulation. It could also race trying to get {@code dfa.edges[t]}, but either
 * way it will work because it's not doing a test and set operation.</p>
 *
 * <p>
 * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
 * Parsing)</strong></p>
 *
 * <p>
 * Sam pointed out that if SLL does not give a syntax error, then there is no
 * point in doing full LL, which is slower. We only have to try LL if we get a
 * syntax error. For maximum speed, Sam starts the parser set to pure SLL
 * mode with the {@link BailErrorStrategy}:</p>
 *
 * <pre>
 * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};
 * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
 * </pre>
 *
 * <p>
 * If it does not get a syntax error, then we're done. If it does get a syntax
 * error, we need to retry with the combined SLL/LL strategy.</p>
 *
 * <p>
 * The reason this works is as follows. If there are no SLL conflicts, then the
 * grammar is SLL (at least for that input set). If there is an SLL conflict,
 * the full LL analysis must yield a set of viable alternatives which is a
 * subset of the alternatives reported by SLL. If the LL set is a singleton,
 * then the grammar is LL but not SLL. If the LL set is the same size as the SLL
 * set, the decision is SLL. If the LL set has size &gt; 1, then that decision
 * is truly ambiguous on the current input. If the LL set is smaller, then the
 * SLL conflict resolution might choose an alternative that the full LL would
 * rule out as a possibility based upon better context information. If that's
 * the case, then the SLL parse will definitely get an error because the full LL
 * analysis says it's not viable. If SLL conflict resolution chooses an
 * alternative within the LL set, them both SLL and LL would choose the same
 * alternative because they both choose the minimum of multiple conflicting
 * alternatives.</p>
 *
 * <p>
 * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
 * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
 * parsing will get an error because SLL will pursue alternative 1. If
 * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
 * choose the same alternative because alternative one is the minimum of either
 * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
 * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
 *
 * <p>
 * Of course, if the input is invalid, then we will get an error for sure in
 * both SLL and LL parsing. Erroneous input will therefore require 2 passes over
 * the input.</p>
 */
class ParserATNSimulator extends ATNSimulator_js_1.default {
    constructor(parser, atn, decisionToDFA, sharedContextCache) {
        super(atn, sharedContextCache);
        this.parser = parser;
        this.decisionToDFA = decisionToDFA;
        // SLL, LL, or LL + exact ambig detection?//
        this.predictionMode = PredictionMode_js_1.default.LL;
        // LAME globals to avoid parameters!!!!! I need these down deep in predTransition
        this._input = null;
        this._startIndex = 0;
        this._outerContext = null;
        this._dfa = null;
        /**
         * Each prediction operation uses a cache for merge of prediction contexts.
         *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
         *  isn't synchronized but we're ok since two threads shouldn't reuse same
         *  parser/atnsim object because it can only handle one input at a time.
         *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
         *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
         *  also be examined during cache lookup.
         */
        this.mergeCache = null;
        this.debug = false;
        this.debug_closure = false;
        this.debug_add = false;
        this.debug_list_atn_decisions = false;
        this.dfa_debug = false;
        this.retry_debug = false;
    }
    reset() { }
    adaptivePredict(input, decision, outerContext) {
        if (this.debug || this.debug_list_atn_decisions) {
            console.log("adaptivePredict decision " + decision +
                " exec LA(1)==" + this.getLookaheadName(input) +
                " line " + input.LT(1).line + ":" +
                input.LT(1).column);
        }
        this._input = input;
        this._startIndex = input.index;
        this._outerContext = outerContext;
        const dfa = this.decisionToDFA[decision];
        this._dfa = dfa;
        const m = input.mark();
        const index = input.index;
        // Now we are certain to have a specific decision's DFA
        // But, do we still need an initial state?
        try {
            let s0;
            if (dfa.precedenceDfa) {
                // the start state for a precedence DFA depends on the current
                // parser precedence, and is provided by a DFA method.
                s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
            }
            else {
                // the start state for a "regular" DFA is just s0
                s0 = dfa.s0;
            }
            if (s0 === null) {
                if (outerContext === null) {
                    outerContext = RuleContext_js_1.default.EMPTY;
                }
                if (this.debug || this.debug_list_atn_decisions) {
                    console.log("predictATN decision " + dfa.decision +
                        " exec LA(1)==" + this.getLookaheadName(input) +
                        ", outerContext=" + outerContext.toString(this.parser.ruleNames));
                }
                const fullCtx = false;
                let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext_js_1.default.EMPTY, fullCtx);
                if (dfa.precedenceDfa) {
                    // If this is a precedence DFA, we use applyPrecedenceFilter
                    // to convert the computed start state to a precedence start
                    // state. We then use DFA.setPrecedenceStartState to set the
                    // appropriate start state for the precedence level rather
                    // than simply setting DFA.s0.
                    //
                    dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway
                    s0_closure = this.applyPrecedenceFilter(s0_closure);
                    s0 = this.addDFAState(dfa, new DFAState_js_1.default(null, s0_closure));
                    dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
                }
                else {
                    s0 = this.addDFAState(dfa, new DFAState_js_1.default(null, s0_closure));
                    dfa.s0 = s0;
                }
            }
            const alt = this.execATN(dfa, s0, input, index, outerContext);
            if (this.debug) {
                console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));
            }
            return alt;
        }
        finally {
            this._dfa = null;
            this.mergeCache = null; // wack cache after each prediction
            input.seek(index);
            input.release(m);
        }
    }
    /**
     * Performs ATN simulation to compute a predicted alternative based
     *  upon the remaining input, but also updates the DFA cache to avoid
     *  having to traverse the ATN again for the same input sequence.
     *
     * There are some key conditions we're looking for after computing a new
     * set of ATN configs (proposed DFA state):
     *       if the set is empty, there is no viable alternative for current symbol
     *       does the state uniquely predict an alternative?
     *       does the state have a conflict that would prevent us from
     *         putting it on the work list?
     *
     * We also have some key operations to do:
     *       add an edge from previous DFA state to potentially new DFA state, D,
     *         upon current symbol but only if adding to work list, which means in all
     *         cases except no viable alternative (and possibly non-greedy decisions?)
     *       collecting predicates and adding semantic context to DFA accept states
     *       adding rule context to context-sensitive DFA accept states
     *       consuming an input symbol
     *       reporting a conflict
     *       reporting an ambiguity
     *       reporting a context sensitivity
     *       reporting insufficient predicates
     *
     * cover these cases:
     *    dead end
     *    single alt
     *    single alt + preds
     *    conflict
     *    conflict + preds
     *
     */
    execATN(dfa, s0, input, startIndex, outerContext) {
        if (this.debug || this.debug_list_atn_decisions) {
            console.log("execATN decision " + dfa.decision +
                " exec LA(1)==" + this.getLookaheadName(input) +
                " line " + input.LT(1).line + ":" + input.LT(1).column);
        }
        let alt;
        let previousD = s0;
        if (this.debug) {
            console.log("s0 = " + s0);
        }
        let t = input.LA(1);
        for (;;) { // while more work
            let D = this.getExistingTargetState(previousD, t);
            if (D === null) {
                D = this.computeTargetState(dfa, previousD, t);
            }
            if (D === ATNSimulator_js_1.default.ERROR) {
                // if any configs in previous dipped into outer context, that
                // means that input up to t actually finished entry rule
                // at least for SLL decision. Full LL doesn't dip into outer
                // so don't need special case.
                // We will get an error no matter what so delay until after
                // decision; better error message. Also, no reachable target
                // ATN states in SLL implies LL will also get nowhere.
                // If conflict in states that dip out, choose min since we
                // will get error no matter what.
                const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
                input.seek(startIndex);
                alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);
                if (alt !== ATN_js_1.default.INVALID_ALT_NUMBER) {
                    return alt;
                }
                else {
                    throw e;
                }
            }
            if (D.requiresFullContext && this.predictionMode !== PredictionMode_js_1.default.SLL) {
                // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
                let conflictingAlts = null;
                if (D.predicates !== null) {
                    if (this.debug) {
                        console.log("DFA state has preds in DFA sim LL failover");
                    }
                    const conflictIndex = input.index;
                    if (conflictIndex !== startIndex) {
                        input.seek(startIndex);
                    }
                    conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);
                    if (conflictingAlts.length === 1) {
                        if (this.debug) {
                            console.log("Full LL avoided");
                        }
                        return conflictingAlts.minValue();
                    }
                    if (conflictIndex !== startIndex) {
                        // restore the index so reporting the fallback to full
                        // context occurs with the index at the correct spot
                        input.seek(conflictIndex);
                    }
                }
                if (this.dfa_debug) {
                    console.log("ctx sensitive state " + outerContext + " in " + D);
                }
                const fullCtx = true;
                const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
                this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
                alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
                return alt;
            }
            if (D.isAcceptState) {
                if (D.predicates === null) {
                    return D.prediction;
                }
                const stopIndex = input.index;
                input.seek(startIndex);
                const alts = this.evalSemanticContext(D.predicates, outerContext, true);
                if (alts.length === 0) {
                    throw this.noViableAlt(input, outerContext, D.configs, startIndex);
                }
                else if (alts.length === 1) {
                    return alts.minValue();
                }
                else {
                    // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.
                    this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
                    return alts.minValue();
                }
            }
            previousD = D;
            if (t !== Token_js_1.default.EOF) {
                input.consume();
                t = input.LA(1);
            }
        }
    }
    /**
     * Get an existing target state for an edge in the DFA. If the target state
     * for the edge has not yet been computed or is otherwise not available,
     * this method returns {@code null}.
     *
     * @param previousD The current DFA state
     * @param t The next input symbol
     * @return The existing target DFA state for the given input symbol
     * {@code t}, or {@code null} if the target state for this edge is not
     * already cached
     */
    getExistingTargetState(previousD, t) {
        const edges = previousD.edges;
        if (edges === null) {
            return null;
        }
        else {
            return edges[t + 1] || null;
        }
    }
    /**
     * Compute a target state for an edge in the DFA, and attempt to add the
     * computed state and corresponding edge to the DFA.
     *
     * @param dfa The DFA
     * @param previousD The current DFA state
     * @param t The next input symbol
     *
     * @return The computed target DFA state for the given input symbol
     * {@code t}. If {@code t} does not lead to a valid DFA state, this method
     * returns {@link //ERROR
     */
    computeTargetState(dfa, previousD, t) {
        const reach = this.computeReachSet(previousD.configs, t, false);
        if (reach === null) {
            this.addDFAEdge(dfa, previousD, t, ATNSimulator_js_1.default.ERROR);
            return ATNSimulator_js_1.default.ERROR;
        }
        // create new target state; we'll add to DFA after it's complete
        let D = new DFAState_js_1.default(null, reach);
        const predictedAlt = this.getUniqueAlt(reach);
        if (this.debug) {
            const altSubSets = PredictionMode_js_1.default.getConflictingAltSubsets(reach);
            console.log("SLL altSubSets=" + (0, arrayToString_js_1.default)(altSubSets) +
                /*", previous=" + previousD.configs + */
                ", configs=" + reach +
                ", predict=" + predictedAlt +
                ", allSubsetsConflict=" +
                PredictionMode_js_1.default.allSubsetsConflict(altSubSets) + ", conflictingAlts=" +
                this.getConflictingAlts(reach));
        }
        if (predictedAlt !== ATN_js_1.default.INVALID_ALT_NUMBER) {
            // NO CONFLICT, UNIQUELY PREDICTED ALT
            D.isAcceptState = true;
            D.configs.uniqueAlt = predictedAlt;
            D.prediction = predictedAlt;
        }
        else if (PredictionMode_js_1.default.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
            // MORE THAN ONE VIABLE ALTERNATIVE
            D.configs.conflictingAlts = this.getConflictingAlts(reach);
            D.requiresFullContext = true;
            // in SLL-only mode, we will stop at this state and return the minimum alt
            D.isAcceptState = true;
            D.prediction = D.configs.conflictingAlts.minValue();
        }
        if (D.isAcceptState && D.configs.hasSemanticContext) {
            this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));
            if (D.predicates !== null) {
                D.prediction = ATN_js_1.default.INVALID_ALT_NUMBER;
            }
        }
        // all adds to dfa are done after we've created full D state
        D = this.addDFAEdge(dfa, previousD, t, D);
        return D;
    }
    predicateDFAState(dfaState, decisionState) {
        // We need to test all predicates, even in DFA states that
        // uniquely predict alternative.
        const nalts = decisionState.transitions.length;
        // Update DFA so reach becomes accept state with (predicate,alt)
        // pairs if preds found for conflicting alts
        const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
        const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);
        if (altToPred !== null) {
            dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
            dfaState.prediction = ATN_js_1.default.INVALID_ALT_NUMBER; // make sure we use preds
        }
        else {
            // There are preds in configs but they might go away
            // when OR'd together like {p}? || NONE == NONE. If neither
            // alt has preds, resolve to min alt
            dfaState.prediction = altsToCollectPredsFrom.minValue();
        }
    }
    // comes back with reach.uniqueAlt set to a valid alt
    execATNWithFullContext(dfa, D, // how far we got before failing over
    s0, input, startIndex, outerContext) {
        if (this.debug || this.debug_list_atn_decisions) {
            console.log("execATNWithFullContext " + s0);
        }
        const fullCtx = true;
        let foundExactAmbig = false;
        let reach;
        let previous = s0;
        input.seek(startIndex);
        let t = input.LA(1);
        let predictedAlt = -1;
        for (;;) { // while more work
            reach = this.computeReachSet(previous, t, fullCtx);
            if (reach === null) {
                // if any configs in previous dipped into outer context, that
                // means that input up to t actually finished entry rule
                // at least for LL decision. Full LL doesn't dip into outer
                // so don't need special case.
                // We will get an error no matter what so delay until after
                // decision; better error message. Also, no reachable target
                // ATN states in SLL implies LL will also get nowhere.
                // If conflict in states that dip out, choose min since we
                // will get error no matter what.
                const e = this.noViableAlt(input, outerContext, previous, startIndex);
                input.seek(startIndex);
                const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);
                if (alt !== ATN_js_1.default.INVALID_ALT_NUMBER) {
                    return alt;
                }
                else {
                    throw e;
                }
            }
            const altSubSets = PredictionMode_js_1.default.getConflictingAltSubsets(reach);
            if (this.debug) {
                console.log("LL altSubSets=" + altSubSets + ", predict=" +
                    PredictionMode_js_1.default.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" +
                    PredictionMode_js_1.default.resolvesToJustOneViableAlt(altSubSets));
            }
            reach.uniqueAlt = this.getUniqueAlt(reach);
            // unique prediction?
            if (reach.uniqueAlt !== ATN_js_1.default.INVALID_ALT_NUMBER) {
                predictedAlt = reach.uniqueAlt;
                break;
            }
            else if (this.predictionMode !== PredictionMode_js_1.default.LL_EXACT_AMBIG_DETECTION) {
                predictedAlt = PredictionMode_js_1.default.resolvesToJustOneViableAlt(altSubSets);
                if (predictedAlt !== ATN_js_1.default.INVALID_ALT_NUMBER) {
                    break;
                }
            }
            else {
                // In exact ambiguity mode, we never try to terminate early.
                // Just keeps scarfing until we know what the conflict is
                if (PredictionMode_js_1.default.allSubsetsConflict(altSubSets) && PredictionMode_js_1.default.allSubsetsEqual(altSubSets)) {
                    foundExactAmbig = true;
                    predictedAlt = PredictionMode_js_1.default.getSingleViableAlt(altSubSets);
                    break;
                }
                // else there are multiple non-conflicting subsets or
                // we're not sure what the ambiguity is yet.
                // So, keep going.
            }
            previous = reach;
            if (t !== Token_js_1.default.EOF) {
                input.consume();
                t = input.LA(1);
            }
        }
        // If the configuration set uniquely predicts an alternative,
        // without conflict, then we know that it's a full LL decision
        // not SLL.
        if (reach.uniqueAlt !== ATN_js_1.default.INVALID_ALT_NUMBER) {
            this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
            return predictedAlt;
        }
        // We do not check predicates here because we have checked them
        // on-the-fly when doing full context prediction.
        //
        // In non-exact ambiguity detection mode, we might	actually be able to
        // detect an exact ambiguity, but I'm not going to spend the cycles
        // needed to check. We only emit ambiguity warnings in exact ambiguity
        // mode.
        //
        // For example, we might know that we have conflicting configurations.
        // But, that does not mean that there is no way forward without a
        // conflict. It's possible to have nonconflicting alt subsets as in:
        // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]
        // from
        //
        //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
        //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
        //
        // In this case, (17,1,[5 $]) indicates there is some next sequence that
        // would resolve this without conflict to alternative 1. Any other viable
        // next sequence, however, is associated with a conflict.  We stop
        // looking for input because no amount of further lookahead will alter
        // the fact that we should predict alternative 1.  We just can't say for
        // sure that there is an ambiguity without looking further.
        this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);
        return predictedAlt;
    }
    computeReachSet(closure, t, fullCtx) {
        if (this.debug) {
            console.log("in computeReachSet, starting closure: " + closure);
        }
        if (this.mergeCache === null) {
            this.mergeCache = new DoubleDict_js_1.default();
        }
        const intermediate = new ATNConfigSet_js_1.default(fullCtx);
        // Configurations already in a rule stop state indicate reaching the end
        // of the decision rule (local context) or end of the start rule (full
        // context). Once reached, these configurations are never updated by a
        // closure operation, so they are handled separately for the performance
        // advantage of having a smaller intermediate set when calling closure.
        //
        // For full-context reach operations, separate handling is required to
        // ensure that the alternative matching the longest overall sequence is
        // chosen when multiple such configurations can match the input.
        let skippedStopStates = null;
        // First figure out where we can reach on input t
        for (let i = 0; i < closure.items.length; i++) {
            const c = closure.items[i];
            if (this.debug) {
                console.log("testing " + this.getTokenName(t) + " at " + c);
            }
            if (c.state instanceof RuleStopState_js_1.default) {
                if (fullCtx || t === Token_js_1.default.EOF) {
                    if (skippedStopStates === null) {
                        skippedStopStates = [];
                    }
                    skippedStopStates.push(c);
                    if (this.debug_add) {
                        console.log("added " + c + " to skippedStopStates");
                    }
                }
                continue;
            }
            for (let j = 0; j < c.state.transitions.length; j++) {
                const trans = c.state.transitions[j];
                const target = this.getReachableTarget(trans, t);
                if (target !== null) {
                    const cfg = new ATNConfig_js_1.default({ state: target }, c);
                    intermediate.add(cfg, this.mergeCache);
                    if (this.debug_add) {
                        console.log("added " + cfg + " to intermediate");
                    }
                }
            }
        }
        // Now figure out where the reach operation can take us...
        let reach = null;
        // This block optimizes the reach operation for intermediate sets which
        // trivially indicate a termination state for the overall
        // adaptivePredict operation.
        //
        // The conditions assume that intermediate
        // contains all configurations relevant to the reach set, but this
        // condition is not true when one or more configurations have been
        // withheld in skippedStopStates, or when the current symbol is EOF.
        //
        if (skippedStopStates === null && t !== Token_js_1.default.EOF) {
            if (intermediate.items.length === 1) {
                // Don't pursue the closure if there is just one state.
                // It can only have one alternative; just add to result
                // Also don't pursue the closure if there is unique alternative
                // among the configurations.
                reach = intermediate;
            }
            else if (this.getUniqueAlt(intermediate) !== ATN_js_1.default.INVALID_ALT_NUMBER) {
                // Also don't pursue the closure if there is unique alternative
                // among the configurations.
                reach = intermediate;
            }
        }
        // If the reach set could not be trivially determined, perform a closure
        // operation on the intermediate set to compute its initial value.
        //
        if (reach === null) {
            reach = new ATNConfigSet_js_1.default(fullCtx);
            const closureBusy = new HashSet_js_1.default();
            const treatEofAsEpsilon = t === Token_js_1.default.EOF;
            for (let k = 0; k < intermediate.items.length; k++) {
                this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
            }
        }
        if (t === Token_js_1.default.EOF) {
            // After consuming EOF no additional input is possible, so we are
            // only interested in configurations which reached the end of the
            // decision rule (local context) or end of the start rule (full
            // context). Update reach to contain only these configurations. This
            // handles both explicit EOF transitions in the grammar and implicit
            // EOF transitions following the end of the decision or start rule.
            //
            // When reach==intermediate, no closure operation was performed. In
            // this case, removeAllConfigsNotInRuleStopState needs to check for
            // reachable rule stop states as well as configurations already in
            // a rule stop state.
            //
            // This is handled before the configurations in skippedStopStates,
            // because any configurations potentially added from that list are
            // already guaranteed to meet this condition whether or not it's
            // required.
            //
            reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
        }
        // If skippedStopStates!==null, then it contains at least one
        // configuration. For full-context reach operations, these
        // configurations reached the end of the start rule, in which case we
        // only add them back to reach if no configuration during the current
        // closure operation reached such a state. This ensures adaptivePredict
        // chooses an alternative matching the longest overall sequence when
        // multiple alternatives are viable.
        //
        if (skippedStopStates !== null && ((!fullCtx) || (!PredictionMode_js_1.default.hasConfigInRuleStopState(reach)))) {
            for (let l = 0; l < skippedStopStates.length; l++) {
                reach.add(skippedStopStates[l], this.mergeCache);
            }
        }
        if (reach.items.length === 0) {
            return null;
        }
        else {
            return reach;
        }
    }
    /**
     * Return a configuration set containing only the configurations from
     * {@code configs} which are in a {@link RuleStopState}. If all
     * configurations in {@code configs} are already in a rule stop state, this
     * method simply returns {@code configs}.
     *
     * <p>When {@code lookToEndOfRule} is true, this method uses
     * {@link ATN//nextTokens} for each configuration in {@code configs} which is
     * not already in a rule stop state to see if a rule stop state is reachable
     * from the configuration via epsilon-only transitions.</p>
     *
     * @param configs the configuration set to update
     * @param lookToEndOfRule when true, this method checks for rule stop states
     * reachable by epsilon-only transitions from each configuration in
     * {@code configs}.
     *
     * @return {@code configs} if all configurations in {@code configs} are in a
     * rule stop state, otherwise return a new configuration set containing only
     * the configurations from {@code configs} which are in a rule stop state
     */
    removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
        if (PredictionMode_js_1.default.allConfigsInRuleStopStates(configs)) {
            return configs;
        }
        const result = new ATNConfigSet_js_1.default(configs.fullCtx);
        for (let i = 0; i < configs.items.length; i++) {
            const config = configs.items[i];
            if (config.state instanceof RuleStopState_js_1.default) {
                result.add(config, this.mergeCache);
                continue;
            }
            if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
                const nextTokens = this.atn.nextTokens(config.state);
                if (nextTokens.contains(Token_js_1.default.EPSILON)) {
                    const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
                    result.add(new ATNConfig_js_1.default({ state: endOfRuleState }, config), this.mergeCache);
                }
            }
        }
        return result;
    }
    computeStartState(p, ctx, fullCtx) {
        // always at least the implicit call to start rule
        const initialContext = (0, PredictionContextUtils_js_1.predictionContextFromRuleContext)(this.atn, ctx);
        const configs = new ATNConfigSet_js_1.default(fullCtx);
        for (let i = 0; i < p.transitions.length; i++) {
            const target = p.transitions[i].target;
            const c = new ATNConfig_js_1.default({ state: target, alt: i + 1, context: initialContext }, null);
            const closureBusy = new HashSet_js_1.default();
            this.closure(c, configs, closureBusy, true, fullCtx, false);
        }
        return configs;
    }
    /**
     * This method transforms the start state computed by
     * {@link //computeStartState} to the special start state used by a
     * precedence DFA for a particular precedence value. The transformation
     * process applies the following changes to the start state's configuration
     * set.
     *
     * <ol>
     * <li>Evaluate the precedence predicates for each configuration using
     * {@link SemanticContext//evalPrecedence}.</li>
     * <li>Remove all configurations which predict an alternative greater than
     * 1, for which another configuration that predicts alternative 1 is in the
     * same ATN state with the same prediction context. This transformation is
     * valid for the following reasons:
     * <ul>
     * <li>The closure block cannot contain any epsilon transitions which bypass
     * the body of the closure, so all states reachable via alternative 1 are
     * part of the precedence alternatives of the transformed left-recursive
     * rule.</li>
     * <li>The "primary" portion of a left recursive rule cannot contain an
     * epsilon transition, so the only way an alternative other than 1 can exist
     * in a state that is also reachable via alternative 1 is by nesting calls
     * to the left-recursive rule, with the outer calls not being at the
     * preferred precedence level.</li>
     * </ul>
     * </li>
     * </ol>
     *
     * <p>
     * The prediction context must be considered by this filter to address
     * situations like the following.
     * </p>
     * <code>
     * <pre>
     * grammar TA;
     * prog: statement* EOF;
     * statement: letterA | statement letterA 'b' ;
     * letterA: 'a';
     * </pre>
     * </code>
     * <p>
     * If the above grammar, the ATN state immediately before the token
     * reference {@code 'a'} in {@code letterA} is reachable from the left edge
     * of both the primary and closure blocks of the left-recursive rule
     * {@code statement}. The prediction context associated with each of these
     * configurations distinguishes between them, and prevents the alternative
     * which stepped out to {@code prog} (and then back in to {@code statement}
     * from being eliminated by the filter.
     * </p>
     *
     * @param configs The configuration set computed by
     * {@link //computeStartState} as the start state for the DFA.
     * @return The transformed configuration set representing the start state
     * for a precedence DFA at a particular precedence level (determined by
     * calling {@link Parser//getPrecedence})
     */
    applyPrecedenceFilter(configs) {
        let config;
        const statesFromAlt1 = [];
        const configSet = new ATNConfigSet_js_1.default(configs.fullCtx);
        for (let i = 0; i < configs.items.length; i++) {
            config = configs.items[i];
            // handle alt 1 first
            if (config.alt !== 1) {
                continue;
            }
            const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);
            if (updatedContext === null) {
                // the configuration was eliminated
                continue;
            }
            statesFromAlt1[config.state.stateNumber] = config.context;
            if (updatedContext !== config.semanticContext) {
                configSet.add(new ATNConfig_js_1.default({ semanticContext: updatedContext }, config), this.mergeCache);
            }
            else {
                configSet.add(config, this.mergeCache);
            }
        }
        for (let i = 0; i < configs.items.length; i++) {
            config = configs.items[i];
            if (config.alt === 1) {
                // already handled
                continue;
            }
            // In the future, this elimination step could be updated to also
            // filter the prediction context for alternatives predicting alt>1
            // (basically a graph subtraction algorithm).
            if (!config.precedenceFilterSuppressed) {
                const context = statesFromAlt1[config.state.stateNumber] || null;
                if (context !== null && context.equals(config.context)) {
                    // eliminated
                    continue;
                }
            }
            configSet.add(config, this.mergeCache);
        }
        return configSet;
    }
    getReachableTarget(trans, ttype) {
        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
            return trans.target;
        }
        else {
            return null;
        }
    }
    getPredsForAmbigAlts(ambigAlts, configs, nalts) {
        // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
        // altToPred starts as an array of all null contexts. The entry at index i
        // corresponds to alternative i. altToPred[i] may have one of three values:
        //   1. null: no ATNConfig c is found such that c.alt==i
        //   2. SemanticContext.NONE: At least one ATNConfig c exists such that
        //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,
        //      alt i has at least one unpredicated config.
        //   3. Non-NONE Semantic Context: There exists at least one, and for all
        //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.
        //
        // From this, it is clear that NONE||anything==NONE.
        //
        let altToPred = [];
        for (let i = 0; i < configs.items.length; i++) {
            const c = configs.items[i];
            if (ambigAlts.has(c.alt)) {
                altToPred[c.alt] = SemanticContext_js_1.default.orContext(altToPred[c.alt] || null, c.semanticContext);
            }
        }
        let nPredAlts = 0;
        for (let i = 1; i < nalts + 1; i++) {
            const pred = altToPred[i] || null;
            if (pred === null) {
                altToPred[i] = SemanticContext_js_1.default.NONE;
            }
            else if (pred !== SemanticContext_js_1.default.NONE) {
                nPredAlts += 1;
            }
        }
        // nonambig alts are null in altToPred
        if (nPredAlts === 0) {
            altToPred = null;
        }
        if (this.debug) {
            console.log("getPredsForAmbigAlts result " + (0, arrayToString_js_1.default)(altToPred));
        }
        return altToPred;
    }
    getPredicatePredictions(ambigAlts, altToPred) {
        const pairs = [];
        let containsPredicate = false;
        for (let i = 1; i < altToPred.length; i++) {
            const pred = altToPred[i];
            // unpredicated is indicated by SemanticContext.NONE
            if (ambigAlts !== null && ambigAlts.has(i)) {
                pairs.push(new PredPrediction_js_1.default(pred, i));
            }
            if (pred !== SemanticContext_js_1.default.NONE) {
                containsPredicate = true;
            }
        }
        if (!containsPredicate) {
            return null;
        }
        return pairs;
    }
    /**
     * This method is used to improve the localization of error messages by
     * choosing an alternative rather than throwing a
     * {@link NoViableAltException} in particular prediction scenarios where the
     * {@link //ERROR} state was reached during ATN simulation.
     *
     * <p>
     * The default implementation of this method uses the following
     * algorithm to identify an ATN configuration which successfully parsed the
     * decision entry rule. Choosing such an alternative ensures that the
     * {@link ParserRuleContext} returned by the calling rule will be complete
     * and valid, and the syntax error will be reported later at a more
     * localized location.</p>
     *
     * <ul>
     * <li>If a syntactically valid path or paths reach the end of the decision rule and
     * they are semantically valid if predicated, return the min associated alt.</li>
     * <li>Else, if a semantically invalid but syntactically valid path exist
     * or paths exist, return the minimum associated alt.
     * </li>
     * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
     * </ul>
     *
     * <p>
     * In some scenarios, the algorithm described above could predict an
     * alternative which will result in a {@link FailedPredicateException} in
     * the parser. Specifically, this could occur if the <em>only</em> configuration
     * capable of successfully parsing to the end of the decision rule is
     * blocked by a semantic predicate. By choosing this alternative within
     * {@link //adaptivePredict} instead of throwing a
     * {@link NoViableAltException}, the resulting
     * {@link FailedPredicateException} in the parser will identify the specific
     * predicate which is preventing the parser from successfully parsing the
     * decision rule, which helps developers identify and correct logic errors
     * in semantic predicates.
     * </p>
     *
     * @param configs The ATN configurations which were valid immediately before
     * the {@link //ERROR} state was reached
     * @param outerContext The is the \gamma_0 initial parser context from the paper
     * or the parser stack at the instant before prediction commences.
     *
     * @return The value to return from {@link //adaptivePredict}, or
     * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
     * identified and {@link //adaptivePredict} should report an error instead
     */
    getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
        const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
        const semValidConfigs = cfgs[0];
        const semInvalidConfigs = cfgs[1];
        let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);
        if (alt !== ATN_js_1.default.INVALID_ALT_NUMBER) { // semantically/syntactically viable path exists
            return alt;
        }
        // Is there a syntactically valid path with a failed pred?
        if (semInvalidConfigs.items.length > 0) {
            alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);
            if (alt !== ATN_js_1.default.INVALID_ALT_NUMBER) { // syntactically viable path exists
                return alt;
            }
        }
        return ATN_js_1.default.INVALID_ALT_NUMBER;
    }
    getAltThatFinishedDecisionEntryRule(configs) {
        const alts = [];
        for (let i = 0; i < configs.items.length; i++) {
            const c = configs.items[i];
            if (c.reachesIntoOuterContext > 0 || ((c.state instanceof RuleStopState_js_1.default) && c.context.hasEmptyPath())) {
                if (alts.indexOf(c.alt) < 0) {
                    alts.push(c.alt);
                }
            }
        }
        if (alts.length === 0) {
            return ATN_js_1.default.INVALID_ALT_NUMBER;
        }
        else {
            return Math.min.apply(null, alts);
        }
    }
    /**
     * Walk the list of configurations and split them according to
     * those that have preds evaluating to true/false.  If no pred, assume
     * true pred and include in succeeded set.  Returns Pair of sets.
     *
     * Create a new set so as not to alter the incoming parameter.
     *
     * Assumption: the input stream has been restored to the starting point
     * prediction, which is where predicates need to evaluate.*/
    splitAccordingToSemanticValidity(configs, outerContext) {
        const succeeded = new ATNConfigSet_js_1.default(configs.fullCtx);
        const failed = new ATNConfigSet_js_1.default(configs.fullCtx);
        for (let i = 0; i < configs.items.length; i++) {
            const c = configs.items[i];
            if (c.semanticContext !== SemanticContext_js_1.default.NONE) {
                const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);
                if (predicateEvaluationResult) {
                    succeeded.add(c);
                }
                else {
                    failed.add(c);
                }
            }
            else {
                succeeded.add(c);
            }
        }
        return [succeeded, failed];
    }
    /**
     * Look through a list of predicate/alt pairs, returning alts for the
     * pairs that win. A {@code NONE} predicate indicates an alt containing an
     * unpredicated config which behaves as "always true." If !complete
     * then we stop at the first predicate that evaluates to true. This
     * includes pairs with null predicates.
     */
    evalSemanticContext(predPredictions, outerContext, complete) {
        const predictions = new BitSet_js_1.default();
        for (let i = 0; i < predPredictions.length; i++) {
            const pair = predPredictions[i];
            if (pair.pred === SemanticContext_js_1.default.NONE) {
                predictions.add(pair.alt);
                if (!complete) {
                    break;
                }
                continue;
            }
            const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);
            if (this.debug || this.dfa_debug) {
                console.log("eval pred " + pair + "=" + predicateEvaluationResult);
            }
            if (predicateEvaluationResult) {
                if (this.debug || this.dfa_debug) {
                    console.log("PREDICT " + pair.alt);
                }
                predictions.add(pair.alt);
                if (!complete) {
                    break;
                }
            }
        }
        return predictions;
    }
    // TODO: If we are doing predicates, there is no point in pursuing
    //     closure operations if we reach a DFA state that uniquely predicts
    //     alternative. We will not be caching that DFA state and it is a
    //     waste to pursue the closure. Might have to advance when we do
    //     ambig detection thought :(
    //
    closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
        const initialDepth = 0;
        this.closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, initialDepth, treatEofAsEpsilon);
    }
    closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
        if (this.debug || this.debug_closure) {
            console.log("closure(" + config.toString(this.parser, true) + ")");
            // console.log("configs(" + configs.toString() + ")");
            if (config.reachesIntoOuterContext > 50) {
                throw "problem";
            }
        }
        if (config.state instanceof RuleStopState_js_1.default) {
            // We hit rule end. If we have context info, use it
            // run thru all possible stack tops in ctx
            if (!config.context.isEmpty()) {
                for (let i = 0; i < config.context.length; i++) {
                    if (config.context.getReturnState(i) === PredictionContext_js_1.default.EMPTY_RETURN_STATE) {
                        if (fullCtx) {
                            configs.add(new ATNConfig_js_1.default({ state: config.state, context: PredictionContext_js_1.default.EMPTY }, config), this.mergeCache);
                            continue;
                        }
                        else {
                            // we have no context info, just chase follow links (if greedy)
                            if (this.debug) {
                                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                            }
                            this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
                        }
                        continue;
                    }
                    const returnState = this.atn.states[config.context.getReturnState(i)];
                    const newContext = config.context.getParent(i); // "pop" return state
                    const parms = { state: returnState, alt: config.alt, context: newContext, semanticContext: config.semanticContext };
                    const c = new ATNConfig_js_1.default(parms, null);
                    // While we have context to pop back from, we may have
                    // gotten that context AFTER having falling off a rule.
                    // Make sure we track that we are now out of context.
                    c.reachesIntoOuterContext = config.reachesIntoOuterContext;
                    this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
                }
                return;
            }
            else if (fullCtx) {
                // reached end of start rule
                configs.add(config, this.mergeCache);
                return;
            }
            else {
                // else if we have no context info, just chase follow links (if greedy)
                if (this.debug) {
                    console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
                }
            }
        }
        this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
    }
    // Do the actual work of walking epsilon edges//
    closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
        const p = config.state;
        // optimization
        if (!p.epsilonOnlyTransitions) {
            configs.add(config, this.mergeCache);
            // make sure to not return here, because EOF transitions can act as
            // both epsilon transitions and non-epsilon transitions.
        }
        for (let i = 0; i < p.transitions.length; i++) {
            if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config))
                continue;
            const t = p.transitions[i];
            const continueCollecting = collectPredicates && !(t instanceof ActionTransition_js_1.default);
            const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);
            if (c !== null) {
                let newDepth = depth;
                if (config.state instanceof RuleStopState_js_1.default) {
                    // target fell off end of rule; mark resulting c as having dipped into outer context
                    // We can't get here if incoming config was rule stop and we had context
                    // track how far we dip into outer context.  Might
                    // come in handy and we avoid evaluating context dependent
                    // preds if this is > 0.
                    if (this._dfa !== null && this._dfa.precedenceDfa) {
                        if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
                            c.precedenceFilterSuppressed = true;
                        }
                    }
                    c.reachesIntoOuterContext += 1;
                    if (closureBusy.add(c) !== c) {
                        // avoid infinite recursion for right-recursive rules
                        continue;
                    }
                    configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method
                    newDepth -= 1;
                    if (this.debug) {
                        console.log("dips into outer ctx: " + c);
                    }
                }
                else {
                    if (!t.isEpsilon && closureBusy.add(c) !== c) {
                        // avoid infinite recursion for EOF* and EOF+
                        continue;
                    }
                    if (t instanceof RuleTransition_js_1.default) {
                        // latch when newDepth goes negative - once we step out of the entry context we can't return
                        if (newDepth >= 0) {
                            newDepth += 1;
                        }
                    }
                }
                this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
            }
        }
    }
    canDropLoopEntryEdgeInLeftRecursiveRule(config) {
        // return False
        const p = config.state;
        // First check to see if we are in StarLoopEntryState generated during
        // left-recursion elimination. For efficiency, also check if
        // the context has an empty stack case. If so, it would mean
        // global FOLLOW so we can't perform optimization
        // Are we the special loop entry/exit state? or SLL wildcard
        if (p.stateType !== ATNState_js_1.default.STAR_LOOP_ENTRY)
            return false;
        if (p.stateType !== ATNState_js_1.default.STAR_LOOP_ENTRY || !p.isPrecedenceDecision ||
            config.context.isEmpty() || config.context.hasEmptyPath())
            return false;
        // Require all return states to return back to the same rule that p is in.
        const numCtxs = config.context.length;
        for (let i = 0; i < numCtxs; i++) { // for each stack context
            const returnState = this.atn.states[config.context.getReturnState(i)];
            if (returnState.ruleIndex !== p.ruleIndex)
                return false;
        }
        const decisionStartState = p.transitions[0].target;
        const blockEndStateNum = decisionStartState.endState.stateNumber;
        const blockEndState = this.atn.states[blockEndStateNum];
        // Verify that the top of each stack context leads to loop entry/exit
        // state through epsilon edges and w/o leaving rule.
        for (let i = 0; i < numCtxs; i++) { // for each stack context
            const returnStateNumber = config.context.getReturnState(i);
            const returnState = this.atn.states[returnStateNumber];
            // all states must have single outgoing epsilon edge
            if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon)
                return false;
            // Look for prefix op case like 'not expr', (' type ')' expr
            const returnStateTarget = returnState.transitions[0].target;
            if (returnState.stateType === ATNState_js_1.default.BLOCK_END && returnStateTarget === p)
                continue;
            // Look for 'expr op expr' or case where expr's return state is block end
            // of (...)* internal block; the block end points to loop back
            // which points to p but we don't need to check that
            if (returnState === blockEndState)
                continue;
            // Look for ternary expr ? expr : expr. The return state points at block end,
            // which points at loop entry state
            if (returnStateTarget === blockEndState)
                continue;
            // Look for complex prefix 'between expr and expr' case where 2nd expr's
            // return state points at block end state of (...)* internal block
            if (returnStateTarget.stateType === ATNState_js_1.default.BLOCK_END && returnStateTarget.transitions.length === 1
                && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p)
                continue;
            // anything else ain't conforming
            return false;
        }
        return true;
    }
    getRuleName(index) {
        if (this.parser !== null && index >= 0) {
            return this.parser.ruleNames[index];
        }
        else {
            return "<rule " + index + ">";
        }
    }
    getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
        switch (t.serializationType) {
            case Transition_js_1.default.RULE:
                return this.ruleTransition(config, t);
            case Transition_js_1.default.PRECEDENCE:
                return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);
            case Transition_js_1.default.PREDICATE:
                return this.predTransition(config, t, collectPredicates, inContext, fullCtx);
            case Transition_js_1.default.ACTION:
                return this.actionTransition(config, t);
            case Transition_js_1.default.EPSILON:
                return new ATNConfig_js_1.default({ state: t.target }, config);
            case Transition_js_1.default.ATOM:
            case Transition_js_1.default.RANGE:
            case Transition_js_1.default.SET:
                // EOF transitions act like epsilon transitions after the first EOF
                // transition is traversed
                if (treatEofAsEpsilon) {
                    if (t.matches(Token_js_1.default.EOF, 0, 1)) {
                        return new ATNConfig_js_1.default({ state: t.target }, config);
                    }
                }
                return null;
            default:
                return null;
        }
    }
    actionTransition(config, t) {
        if (this.debug) {
            const index = t.actionIndex === -1 ? 65535 : t.actionIndex;
            console.log("ACTION edge " + t.ruleIndex + ":" + index);
        }
        return new ATNConfig_js_1.default({ state: t.target }, config);
    }
    precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
        if (this.debug) {
            console.log("PRED (collectPredicates=" + collectPredicates + ") " +
                pt.precedence + ">=_p, ctx dependent=true");
            if (this.parser !== null) {
                console.log("context surrounding pred is " + (0, arrayToString_js_1.default)(this.parser.getRuleInvocationStack()));
            }
        }
        let c = null;
        if (collectPredicates && inContext) {
            if (fullCtx) {
                // In full context mode, we can evaluate predicates on-the-fly
                // during closure, which dramatically reduces the size of
                // the config sets. It also obviates the need to test predicates
                // later during conflict resolution.
                const currentPosition = this._input.index;
                this._input.seek(this._startIndex);
                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
                this._input.seek(currentPosition);
                if (predSucceeds) {
                    c = new ATNConfig_js_1.default({ state: pt.target }, config); // no pred context
                }
            }
            else {
                const newSemCtx = SemanticContext_js_1.default.andContext(config.semanticContext, pt.getPredicate());
                c = new ATNConfig_js_1.default({ state: pt.target, semanticContext: newSemCtx }, config);
            }
        }
        else {
            c = new ATNConfig_js_1.default({ state: pt.target }, config);
        }
        if (this.debug) {
            console.log("config from pred transition=" + c);
        }
        return c;
    }
    predTransition(config, pt, collectPredicates, inContext, fullCtx) {
        if (this.debug) {
            console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex +
                ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);
            if (this.parser !== null) {
                console.log("context surrounding pred is " + (0, arrayToString_js_1.default)(this.parser.getRuleInvocationStack()));
            }
        }
        let c = null;
        if (collectPredicates && ((pt.isCtxDependent && inContext) || !pt.isCtxDependent)) {
            if (fullCtx) {
                // In full context mode, we can evaluate predicates on-the-fly
                // during closure, which dramatically reduces the size of
                // the config sets. It also obviates the need to test predicates
                // later during conflict resolution.
                const currentPosition = this._input.index;
                this._input.seek(this._startIndex);
                const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);
                this._input.seek(currentPosition);
                if (predSucceeds) {
                    c = new ATNConfig_js_1.default({ state: pt.target }, config); // no pred context
                }
            }
            else {
                const newSemCtx = SemanticContext_js_1.default.andContext(config.semanticContext, pt.getPredicate());
                c = new ATNConfig_js_1.default({ state: pt.target, semanticContext: newSemCtx }, config);
            }
        }
        else {
            c = new ATNConfig_js_1.default({ state: pt.target }, config);
        }
        if (this.debug) {
            console.log("config from pred transition=" + c);
        }
        return c;
    }
    ruleTransition(config, t) {
        if (this.debug) {
            console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
        }
        const returnState = t.followState;
        const newContext = SingletonPredictionContext_js_1.default.create(config.context, returnState.stateNumber);
        return new ATNConfig_js_1.default({ state: t.target, context: newContext }, config);
    }
    getConflictingAlts(configs) {
        const altsets = PredictionMode_js_1.default.getConflictingAltSubsets(configs);
        return PredictionMode_js_1.default.getAlts(altsets);
    }
    /**
     * Sam pointed out a problem with the previous definition, v3, of
     * ambiguous states. If we have another state associated with conflicting
     * alternatives, we should keep going. For example, the following grammar
     *
     * s : (ID | ID ID?) ';' ;
     *
     * When the ATN simulation reaches the state before ';', it has a DFA
     * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
     * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
     * because alternative to has another way to continue, via [6|2|[]].
     * The key is that we have a single state that has config's only associated
     * with a single alternative, 2, and crucially the state transitions
     * among the configurations are all non-epsilon transitions. That means
     * we don't consider any conflicts that include alternative 2. So, we
     * ignore the conflict between alts 1 and 2. We ignore a set of
     * conflicting alts when there is an intersection with an alternative
     * associated with a single alt state in the state&rarr;config-list map.
     *
     * It's also the case that we might have two conflicting configurations but
     * also a 3rd nonconflicting configuration for a different alternative:
     * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
     *
     * a : A | A | A B ;
     *
     * After matching input A, we reach the stop state for rule A, state 1.
     * State 8 is the state right before B. Clearly alternatives 1 and 2
     * conflict and no amount of further lookahead will separate the two.
     * However, alternative 3 will be able to continue and so we do not
     * stop working on this state. In the previous example, we're concerned
     * with states associated with the conflicting alternatives. Here alt
     * 3 is not associated with the conflicting configs, but since we can continue
     * looking for input reasonably, I don't declare the state done. We
     * ignore a set of conflicting alts when we have an alternative
     * that we still need to pursue
     */
    getConflictingAltsOrUniqueAlt(configs) {
        let conflictingAlts = null;
        if (configs.uniqueAlt !== ATN_js_1.default.INVALID_ALT_NUMBER) {
            conflictingAlts = new BitSet_js_1.default();
            conflictingAlts.add(configs.uniqueAlt);
        }
        else {
            conflictingAlts = configs.conflictingAlts;
        }
        return conflictingAlts;
    }
    getTokenName(t) {
        if (t === Token_js_1.default.EOF) {
            return "EOF";
        }
        if (this.parser !== null && this.parser.literalNames !== null) {
            if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
                console.log("" + t + " ttype out of range: " + this.parser.literalNames);
                console.log("" + this.parser.getInputStream().getTokens());
            }
            else {
                const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];
                return name + "<" + t + ">";
            }
        }
        return "" + t;
    }
    getLookaheadName(input) {
        return this.getTokenName(input.LA(1));
    }
    /**
     * Used for debugging in adaptivePredict around execATN but I cut
     * it out for clarity now that alg. works well. We can leave this
     * "dead" code for a bit
     */
    dumpDeadEndConfigs(nvae) {
        console.log("dead end configs: ");
        const decs = nvae.getDeadEndConfigs();
        for (let i = 0; i < decs.length; i++) {
            const c = decs[i];
            let trans = "no edges";
            if (c.state.transitions.length > 0) {
                const t = c.state.transitions[0];
                if (t instanceof AtomTransition_js_1.default) {
                    trans = "Atom " + this.getTokenName(t.label);
                }
                else if (t instanceof SetTransition_js_1.default) {
                    const neg = (t instanceof NotSetTransition_js_1.default);
                    trans = (neg ? "~" : "") + "Set " + t.set;
                }
            }
            console.error(c.toString(this.parser, true) + ":" + trans);
        }
    }
    noViableAlt(input, outerContext, configs, startIndex) {
        return new NoViableAltException_js_1.default(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
    }
    getUniqueAlt(configs) {
        let alt = ATN_js_1.default.INVALID_ALT_NUMBER;
        for (let i = 0; i < configs.items.length; i++) {
            const c = configs.items[i];
            if (alt === ATN_js_1.default.INVALID_ALT_NUMBER) {
                alt = c.alt; // found first alt
            }
            else if (c.alt !== alt) {
                return ATN_js_1.default.INVALID_ALT_NUMBER;
            }
        }
        return alt;
    }
    /**
     * Add an edge to the DFA, if possible. This method calls
     * {@link //addDFAState} to ensure the {@code to} state is present in the
     * DFA. If {@code from} is {@code null}, or if {@code t} is outside the
     * range of edges that can be represented in the DFA tables, this method
     * returns without adding the edge to the DFA.
     *
     * <p>If {@code to} is {@code null}, this method returns {@code null}.
     * Otherwise, this method returns the {@link DFAState} returned by calling
     * {@link //addDFAState} for the {@code to} state.</p>
     *
     * @param dfa The DFA
     * @param from_ The source state for the edge
     * @param t The input symbol
     * @param to The target state for the edge
     *
     * @return If {@code to} is {@code null}, this method returns {@code null};
     * otherwise this method returns the result of calling {@link //addDFAState}
     * on {@code to}
     */
    addDFAEdge(dfa, from_, t, to) {
        if (this.debug) {
            console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
        }
        if (to === null) {
            return null;
        }
        to = this.addDFAState(dfa, to); // used existing if possible not incoming
        if (from_ === null || t < -1 || t > this.atn.maxTokenType) {
            return to;
        }
        if (from_.edges === null) {
            from_.edges = [];
        }
        from_.edges[t + 1] = to; // connect
        if (this.debug) {
            const literalNames = this.parser === null ? null : this.parser.literalNames;
            const symbolicNames = this.parser === null ? null : this.parser.symbolicNames;
            console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
        }
        return to;
    }
    /**
     * Add state {@code D} to the DFA if it is not already present, and return
     * the actual instance stored in the DFA. If a state equivalent to {@code D}
     * is already in the DFA, the existing state is returned. Otherwise this
     * method returns {@code D} after adding it to the DFA.
     *
     * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
     * does not change the DFA.</p>
     *
     * @param dfa The dfa
     * @param D The DFA state to add
     * @return The state stored in the DFA. This will be either the existing
     * state if {@code D} is already in the DFA, or {@code D} itself if the
     * state was not already present
     */
    addDFAState(dfa, D) {
        if (D === ATNSimulator_js_1.default.ERROR) {
            return D;
        }
        const existing = dfa.states.get(D);
        if (existing !== null) {
            return existing;
        }
        D.stateNumber = dfa.states.length;
        if (!D.configs.readOnly) {
            D.configs.optimizeConfigs(this);
            D.configs.setReadonly(true);
        }
        dfa.states.add(D);
        if (this.debug) {
            console.log("adding new DFA state: " + D);
        }
        return D;
    }
    reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
        if (this.debug || this.retry_debug) {
            const interval = new Interval_js_1.default(startIndex, stopIndex + 1);
            console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs +
                ", input=" + this.parser.getTokenStream().getText(interval));
        }
        if (this.parser !== null) {
            this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
        }
    }
    reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
        if (this.debug || this.retry_debug) {
            const interval = new Interval_js_1.default(startIndex, stopIndex + 1);
            console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs +
                ", input=" + this.parser.getTokenStream().getText(interval));
        }
        if (this.parser !== null) {
            this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
        }
    }
    // If context sensitive parsing, we know it's ambiguity not conflict//
    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.debug || this.retry_debug) {
            const interval = new Interval_js_1.default(startIndex, stopIndex + 1);
            console.log("reportAmbiguity " + ambigAlts + ":" + configs +
                ", input=" + this.parser.getTokenStream().getText(interval));
        }
        if (this.parser !== null) {
            this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
        }
    }
}
exports["default"] = ParserATNSimulator;
//# sourceMappingURL=ParserATNSimulator.js.map

/***/ }),

/***/ 3378:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const SemanticContext_js_1 = __importDefault(__webpack_require__(2105));
class PrecedencePredicate extends SemanticContext_js_1.default {
    constructor(precedence) {
        super();
        this.precedence = precedence === undefined ? 0 : precedence;
    }
    evaluate(parser, outerContext) {
        return parser.precpred(outerContext, this.precedence);
    }
    evalPrecedence(parser, outerContext) {
        if (parser.precpred(outerContext, this.precedence)) {
            return SemanticContext_js_1.default.NONE;
        }
        else {
            return null;
        }
    }
    compareTo(other) {
        return this.precedence - other.precedence;
    }
    updateHashCode(hash) {
        hash.update(this.precedence);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof PrecedencePredicate)) {
            return false;
        }
        else {
            return this.precedence === other.precedence;
        }
    }
    toString() {
        return "{" + this.precedence + ">=prec}?";
    }
}
exports["default"] = PrecedencePredicate;
// HORRIBLE workaround circular import, avoiding dynamic import
SemanticContext_js_1.default.PrecedencePredicate = PrecedencePredicate;
//# sourceMappingURL=PrecedencePredicate.js.map

/***/ }),

/***/ 9305:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const SemanticContext_js_1 = __importDefault(__webpack_require__(2105));
class Predicate extends SemanticContext_js_1.default {
    constructor(ruleIndex, predIndex, isCtxDependent) {
        super();
        this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;
        this.predIndex = predIndex === undefined ? -1 : predIndex;
        this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
    }
    evaluate(parser, outerContext) {
        const localctx = this.isCtxDependent ? outerContext : null;
        return parser.sempred(localctx, this.ruleIndex, this.predIndex);
    }
    updateHashCode(hash) {
        hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof Predicate)) {
            return false;
        }
        else {
            return this.ruleIndex === other.ruleIndex &&
                this.predIndex === other.predIndex &&
                this.isCtxDependent === other.isCtxDependent;
        }
    }
    toString() {
        return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
    }
}
exports["default"] = Predicate;
/**
 * The default {@link SemanticContext}, which is semantically equivalent to
 * a predicate of the form {@code {true}?}
 */
SemanticContext_js_1.default.NONE = new Predicate();
//# sourceMappingURL=Predicate.js.map

/***/ }),

/***/ 2534:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const PredictionContext_js_1 = __importDefault(__webpack_require__(748));
const HashMap_js_1 = __importDefault(__webpack_require__(1935));
/**
 * Used to cache {@link PredictionContext} objects. Its used for the shared
 * context cash associated with contexts in DFA states. This cache
 * can be used for both lexers and parsers.
 */
class PredictionContextCache {
    constructor() {
        this.cache = new HashMap_js_1.default();
    }
    /**
     * Add a context to the cache and return it. If the context already exists,
     * return that one instead and do not add a new context to the cache.
     * Protect shared cache from unsafe thread access.
     */
    add(ctx) {
        if (ctx === PredictionContext_js_1.default.EMPTY) {
            return PredictionContext_js_1.default.EMPTY;
        }
        const existing = this.cache.get(ctx) || null;
        if (existing !== null) {
            return existing;
        }
        this.cache.set(ctx, ctx);
        return ctx;
    }
    get(ctx) {
        return this.cache.get(ctx) || null;
    }
    get length() {
        return this.cache.length;
    }
}
exports["default"] = PredictionContextCache;
//# sourceMappingURL=PredictionContextCache.js.map

/***/ }),

/***/ 8895:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ATN_js_1 = __importDefault(__webpack_require__(3600));
const RuleStopState_js_1 = __importDefault(__webpack_require__(1385));
const ATNConfigSet_js_1 = __importDefault(__webpack_require__(8254));
const ATNConfig_js_1 = __importDefault(__webpack_require__(3864));
const SemanticContext_js_1 = __importDefault(__webpack_require__(2105));
const BitSet_js_1 = __importDefault(__webpack_require__(7149));
const AltDict_js_1 = __importDefault(__webpack_require__(1387));
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
const HashMap_js_1 = __importDefault(__webpack_require__(1935));
/**
 * This enumeration defines the prediction modes available in ANTLR 4 along with
 * utility methods for analyzing configuration sets for conflicts and/or
 * ambiguities.
 */
const PredictionMode = {
    /**
     * The SLL(*) prediction mode. This prediction mode ignores the current
     * parser context when making predictions. This is the fastest prediction
     * mode, and provides correct results for many grammars. This prediction
     * mode is more powerful than the prediction mode provided by ANTLR 3, but
     * may result in syntax errors for grammar and input combinations which are
     * not SLL.
     *
     * <p>
     * When using this prediction mode, the parser will either return a correct
     * parse tree (i.e. the same parse tree that would be returned with the
     * {@link //LL} prediction mode), or it will report a syntax error. If a
     * syntax error is encountered when using the {@link //SLL} prediction mode,
     * it may be due to either an actual syntax error in the input or indicate
     * that the particular combination of grammar and input requires the more
     * powerful {@link //LL} prediction abilities to complete successfully.</p>
     *
     * <p>
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.</p>
     */
    SLL: 0,
    /**
     * The LL(*) prediction mode. This prediction mode allows the current parser
     * context to be used for resolving SLL conflicts that occur during
     * prediction. This is the fastest prediction mode that guarantees correct
     * parse results for all combinations of grammars with syntactically correct
     * inputs.
     *
     * <p>
     * When using this prediction mode, the parser will make correct decisions
     * for all syntactically-correct grammar and input combinations. However, in
     * cases where the grammar is truly ambiguous this prediction mode might not
     * report a precise answer for <em>exactly which</em> alternatives are
     * ambiguous.</p>
     *
     * <p>
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.</p>
     */
    LL: 1,
    /**
     *
     * The LL(*) prediction mode with exact ambiguity detection. In addition to
     * the correctness guarantees provided by the {@link //LL} prediction mode,
     * this prediction mode instructs the prediction algorithm to determine the
     * complete and exact set of ambiguous alternatives for every ambiguous
     * decision encountered while parsing.
     *
     * <p>
     * This prediction mode may be used for diagnosing ambiguities during
     * grammar development. Due to the performance overhead of calculating sets
     * of ambiguous alternatives, this prediction mode should be avoided when
     * the exact results are not necessary.</p>
     *
     * <p>
     * This prediction mode does not provide any guarantees for prediction
     * behavior for syntactically-incorrect inputs.</p>
     */
    LL_EXACT_AMBIG_DETECTION: 2,
    /**
     *
     * Computes the SLL prediction termination condition.
     *
     * <p>
     * This method computes the SLL prediction termination condition for both of
     * the following cases.</p>
     *
     * <ul>
     * <li>The usual SLL+LL fallback upon SLL conflict</li>
     * <li>Pure SLL without LL fallback</li>
     * </ul>
     *
     * <p><strong>COMBINED SLL+LL PARSING</strong></p>
     *
     * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
     * ensured regardless of how the termination condition is computed by this
     * method. Due to the substantially higher cost of LL prediction, the
     * prediction should only fall back to LL when the additional lookahead
     * cannot lead to a unique SLL prediction.</p>
     *
     * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
     * conflicting subsets should fall back to full LL, even if the
     * configuration sets don't resolve to the same alternative (e.g.
     * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
     * configuration, SLL could continue with the hopes that more lookahead will
     * resolve via one of those non-conflicting configurations.</p>
     *
     * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
     * stops when it sees only conflicting configuration subsets. In contrast,
     * full LL keeps going when there is uncertainty.</p>
     *
     * <p><strong>HEURISTIC</strong></p>
     *
     * <p>As a heuristic, we stop prediction when we see any conflicting subset
     * unless we see a state that only has one alternative associated with it.
     * The single-alt-state thing lets prediction continue upon rules like
     * (otherwise, it would admit defeat too soon):</p>
     *
     * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
     *
     * <p>When the ATN simulation reaches the state before {@code ';'}, it has a
     * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
     * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
     * processing this node because alternative to has another way to continue,
     * via {@code [6|2|[]]}.</p>
     *
     * <p>It also let's us continue for this rule:</p>
     *
     * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
     *
     * <p>After matching input A, we reach the stop state for rule A, state 1.
     * State 8 is the state right before B. Clearly alternatives 1 and 2
     * conflict and no amount of further lookahead will separate the two.
     * However, alternative 3 will be able to continue and so we do not stop
     * working on this state. In the previous example, we're concerned with
     * states associated with the conflicting alternatives. Here alt 3 is not
     * associated with the conflicting configs, but since we can continue
     * looking for input reasonably, don't declare the state done.</p>
     *
     * <p><strong>PURE SLL PARSING</strong></p>
     *
     * <p>To handle pure SLL parsing, all we have to do is make sure that we
     * combine stack contexts for configurations that differ only by semantic
     * predicate. From there, we can do the usual SLL termination heuristic.</p>
     *
     * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
     *
     * <p>SLL decisions don't evaluate predicates until after they reach DFA stop
     * states because they need to create the DFA cache that works in all
     * semantic situations. In contrast, full LL evaluates predicates collected
     * during start state computation so it can ignore predicates thereafter.
     * This means that SLL termination detection can totally ignore semantic
     * predicates.</p>
     *
     * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
     * semantic predicate contexts so we might see two configurations like the
     * following.</p>
     *
     * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
     *
     * <p>Before testing these configurations against others, we have to merge
     * {@code x} and {@code x'} (without modifying the existing configurations).
     * For example, we test {@code (x+x')==x''} when looking for conflicts in
     * the following configurations.</p>
     *
     * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
     *
     * <p>If the configuration set has predicates (as indicated by
     * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
     * the configurations to strip out all of the predicates so that a standard
     * {@link ATNConfigSet} will merge everything ignoring predicates.</p>
     */
    hasSLLConflictTerminatingPrediction: function (mode, configs) {
        // Configs in rule stop states indicate reaching the end of the decision
        // rule (local context) or end of start rule (full context). If all
        // configs meet this condition, then none of the configurations is able
        // to match additional input so we terminate prediction.
        //
        if (PredictionMode.allConfigsInRuleStopStates(configs)) {
            return true;
        }
        // pure SLL mode parsing
        if (mode === PredictionMode.SLL) {
            // Don't bother with combining configs from different semantic
            // contexts if we can fail over to full LL; costs more time
            // since we'll often fail over anyway.
            if (configs.hasSemanticContext) {
                // dup configs, tossing out semantic predicates
                const dup = new ATNConfigSet_js_1.default();
                for (let i = 0; i < configs.items.length; i++) {
                    let c = configs.items[i];
                    c = new ATNConfig_js_1.default({ semanticContext: SemanticContext_js_1.default.NONE }, c);
                    dup.add(c);
                }
                configs = dup;
            }
            // now we have combined contexts for configs with dissimilar preds
        }
        // pure SLL or combined SLL+LL mode parsing
        const altsets = PredictionMode.getConflictingAltSubsets(configs);
        return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
    },
    /**
     * Checks if any configuration in {@code configs} is in a
     * {@link RuleStopState}. Configurations meeting this condition have reached
     * the end of the decision rule (local context) or end of start rule (full
     * context).
     *
     * @param configs the configuration set to test
     * @return {@code true} if any configuration in {@code configs} is in a
     * {@link RuleStopState}, otherwise {@code false}
     */
    hasConfigInRuleStopState: function (configs) {
        for (let i = 0; i < configs.items.length; i++) {
            const c = configs.items[i];
            if (c.state instanceof RuleStopState_js_1.default) {
                return true;
            }
        }
        return false;
    },
    /**
     * Checks if all configurations in {@code configs} are in a
     * {@link RuleStopState}. Configurations meeting this condition have reached
     * the end of the decision rule (local context) or end of start rule (full
     * context).
     *
     * @param configs the configuration set to test
     * @return {@code true} if all configurations in {@code configs} are in a
     * {@link RuleStopState}, otherwise {@code false}
     */
    allConfigsInRuleStopStates: function (configs) {
        for (let i = 0; i < configs.items.length; i++) {
            const c = configs.items[i];
            if (!(c.state instanceof RuleStopState_js_1.default)) {
                return false;
            }
        }
        return true;
    },
    /**
     *
     * Full LL prediction termination.
     *
     * <p>Can we stop looking ahead during ATN simulation or is there some
     * uncertainty as to which alternative we will ultimately pick, after
     * consuming more input? Even if there are partial conflicts, we might know
     * that everything is going to resolve to the same minimum alternative. That
     * means we can stop since no more lookahead will change that fact. On the
     * other hand, there might be multiple conflicts that resolve to different
     * minimums. That means we need more look ahead to decide which of those
     * alternatives we should predict.</p>
     *
     * <p>The basic idea is to split the set of configurations {@code C}, into
     * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
     * non-conflicting configurations. Two configurations conflict if they have
     * identical {@link ATNConfig//state} and {@link ATNConfig//context} values
     * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
     * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
     *
     * <p>Reduce these configuration subsets to the set of possible alternatives.
     * You can compute the alternative subsets in one pass as follows:</p>
     *
     * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
     * {@code C} holding {@code s} and {@code ctx} fixed.</p>
     *
     * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
     *
     * <pre>
     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
     * alt and not pred
     * </pre>
     *
     * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
     *
     * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
     * {@code s} and {@code ctx}.</p>
     *
     * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
     * the union of these alternative subsets is a singleton, then no amount of
     * more lookahead will help us. We will always pick that alternative. If,
     * however, there is more than one alternative, then we are uncertain which
     * alternative to predict and must continue looking for resolution. We may
     * or may not discover an ambiguity in the future, even if there are no
     * conflicting subsets this round.</p>
     *
     * <p>The biggest sin is to terminate early because it means we've made a
     * decision but were uncertain as to the eventual outcome. We haven't used
     * enough lookahead. On the other hand, announcing a conflict too late is no
     * big deal; you will still have the conflict. It's just inefficient. It
     * might even look until the end of file.</p>
     *
     * <p>No special consideration for semantic predicates is required because
     * predicates are evaluated on-the-fly for full LL prediction, ensuring that
     * no configuration contains a semantic context during the termination
     * check.</p>
     *
     * <p><strong>CONFLICTING CONFIGS</strong></p>
     *
     * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
     * when {@code i!=j} but {@code x=x'}. Because we merge all
     * {@code (s, i, _)} configurations together, that means that there are at
     * most {@code n} configurations associated with state {@code s} for
     * {@code n} possible alternatives in the decision. The merged stacks
     * complicate the comparison of configuration contexts {@code x} and
     * {@code x'}. Sam checks to see if one is a subset of the other by calling
     * merge and checking to see if the merged result is either {@code x} or
     * {@code x'}. If the {@code x} associated with lowest alternative {@code i}
     * is the superset, then {@code i} is the only possible prediction since the
     * others resolve to {@code min(i)} as well. However, if {@code x} is
     * associated with {@code j>i} then at least one stack configuration for
     * {@code j} is not in conflict with alternative {@code i}. The algorithm
     * should keep going, looking for more lookahead due to the uncertainty.</p>
     *
     * <p>For simplicity, I'm doing a equality check between {@code x} and
     * {@code x'} that lets the algorithm continue to consume lookahead longer
     * than necessary. The reason I like the equality is of course the
     * simplicity but also because that is the test you need to detect the
     * alternatives that are actually in conflict.</p>
     *
     * <p><strong>CONTINUE/STOP RULE</strong></p>
     *
     * <p>Continue if union of resolved alternative sets from non-conflicting and
     * conflicting alternative subsets has more than one alternative. We are
     * uncertain about which alternative to predict.</p>
     *
     * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
     * alternatives are still in the running for the amount of input we've
     * consumed at this point. The conflicting sets let us to strip away
     * configurations that won't lead to more states because we resolve
     * conflicts to the configuration with a minimum alternate for the
     * conflicting set.</p>
     *
     * <p><strong>CASES</strong></p>
     *
     * <ul>
     *
     * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
     *
     * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
     * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
     * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
     * {@code {1,3}} =&gt; continue
     * </li>
     *
     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
     * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
     * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
     * {@code {1}} =&gt; stop and predict 1</li>
     *
     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
     * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
     * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
     * ambiguity {@code {1,2}}</li>
     *
     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
     * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
     * {@code {2}} = {@code {1,2}} =&gt; continue</li>
     *
     * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
     * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
     * {@code {3}} = {@code {1,3}} =&gt; continue</li>
     *
     * </ul>
     *
     * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
     *
     * <p>If all states report the same conflicting set of alternatives, then we
     * know we have the exact ambiguity set.</p>
     *
     * <p><code>|A_<em>i</em>|&gt;1</code> and
     * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
     *
     * <p>In other words, we continue examining lookahead until all {@code A_i}
     * have more than one alternative and all {@code A_i} are the same. If
     * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
     * because the resolved set is {@code {1}}. To determine what the real
     * ambiguity is, we have to know whether the ambiguity is between one and
     * two or one and three so we keep going. We can only stop prediction when
     * we need exact ambiguity detection when the sets look like
     * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
     */
    resolvesToJustOneViableAlt: function (altsets) {
        return PredictionMode.getSingleViableAlt(altsets);
    },
    /**
     * Determines if every alternative subset in {@code altsets} contains more
     * than one alternative.
     *
     * @param altsets a collection of alternative subsets
     * @return {@code true} if every {@link BitSet} in {@code altsets} has
     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
     */
    allSubsetsConflict: function (altsets) {
        return !PredictionMode.hasNonConflictingAltSet(altsets);
    },
    /**
     * Determines if any single alternative subset in {@code altsets} contains
     * exactly one alternative.
     *
     * @param altsets a collection of alternative subsets
     * @return {@code true} if {@code altsets} contains a {@link BitSet} with
     * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
     */
    hasNonConflictingAltSet: function (altsets) {
        for (let i = 0; i < altsets.length; i++) {
            const alts = altsets[i];
            if (alts.length === 1) {
                return true;
            }
        }
        return false;
    },
    /**
     * Determines if any single alternative subset in {@code altsets} contains
     * more than one alternative.
     *
     * @param altsets a collection of alternative subsets
     * @return {@code true} if {@code altsets} contains a {@link BitSet} with
     * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
     */
    hasConflictingAltSet: function (altsets) {
        for (let i = 0; i < altsets.length; i++) {
            const alts = altsets[i];
            if (alts.length > 1) {
                return true;
            }
        }
        return false;
    },
    /**
     * Determines if every alternative subset in {@code altsets} is equivalent.
     *
     * @param altsets a collection of alternative subsets
     * @return {@code true} if every member of {@code altsets} is equal to the
     * others, otherwise {@code false}
     */
    allSubsetsEqual: function (altsets) {
        let first = null;
        for (let i = 0; i < altsets.length; i++) {
            const alts = altsets[i];
            if (first === null) {
                first = alts;
            }
            else if (alts !== first) {
                return false;
            }
        }
        return true;
    },
    /**
     * Returns the unique alternative predicted by all alternative subsets in
     * {@code altsets}. If no such alternative exists, this method returns
     * {@link ATN//INVALID_ALT_NUMBER}.
     *
     * @param altsets a collection of alternative subsets
     */
    getUniqueAlt: function (altsets) {
        const all = PredictionMode.getAlts(altsets);
        if (all.length === 1) {
            return all.minValue();
        }
        else {
            return ATN_js_1.default.INVALID_ALT_NUMBER;
        }
    },
    /**
     * Gets the complete set of represented alternatives for a collection of
     * alternative subsets. This method returns the union of each {@link BitSet}
     * in {@code altsets}.
     *
     * @param altsets a collection of alternative subsets
     * @return the set of represented alternatives in {@code altsets}
     */
    getAlts: function (altsets) {
        const all = new BitSet_js_1.default();
        altsets.map(function (alts) { all.or(alts); });
        return all;
    },
    /**
     * This function gets the conflicting alt subsets from a configuration set.
     * For each configuration {@code c} in {@code configs}:
     *
     * <pre>
     * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
     * alt and not pred
     * </pre>
     */
    getConflictingAltSubsets: function (configs) {
        const configToAlts = new HashMap_js_1.default();
        configToAlts.hashFunction = function (cfg) { HashCode_js_1.default.hashStuff(cfg.state.stateNumber, cfg.context); };
        configToAlts.equalsFunction = function (c1, c2) { return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context); };
        configs.items.map(function (cfg) {
            let alts = configToAlts.get(cfg);
            if (alts === null) {
                alts = new BitSet_js_1.default();
                configToAlts.set(cfg, alts);
            }
            alts.add(cfg.alt);
        });
        return configToAlts.getValues();
    },
    /**
     * Get a map from state to alt subset from a configuration set. For each
     * configuration {@code c} in {@code configs}:
     *
     * <pre>
     * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
     * </pre>
     */
    getStateToAltMap: function (configs) {
        const m = new AltDict_js_1.default();
        configs.items.map(function (c) {
            let alts = m.get(c.state);
            if (alts === null) {
                alts = new BitSet_js_1.default();
                m.set(c.state, alts);
            }
            alts.add(c.alt);
        });
        return m;
    },
    hasStateAssociatedWithOneAlt: function (configs) {
        const values = PredictionMode.getStateToAltMap(configs).values();
        for (let i = 0; i < values.length; i++) {
            if (values[i].length === 1) {
                return true;
            }
        }
        return false;
    },
    getSingleViableAlt: function (altsets) {
        let result = null;
        for (let i = 0; i < altsets.length; i++) {
            const alts = altsets[i];
            const minAlt = alts.minValue();
            if (result === null) {
                result = minAlt;
            }
            else if (result !== minAlt) { // more than 1 viable alt
                return ATN_js_1.default.INVALID_ALT_NUMBER;
            }
        }
        return result;
    }
};
exports["default"] = PredictionMode;
//# sourceMappingURL=PredictionMode.js.map

/***/ }),

/***/ 2105:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const equalArrays_js_1 = __importDefault(__webpack_require__(1267));
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
const HashSet_js_1 = __importDefault(__webpack_require__(5563));
/**
 * A tree structure used to record the semantic context in which
 * an ATN configuration is valid.  It's either a single predicate,
 * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
 *
 * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
 * {@link SemanticContext} within the scope of this outer class.</p>
 */
class SemanticContext {
    hashCode() {
        const hash = new HashCode_js_1.default();
        this.updateHashCode(hash);
        return hash.finish();
    }
    /**
     * For context independent predicates, we evaluate them without a local
     * context (i.e., null context). That way, we can evaluate them without
     * having to create proper rule-specific context during prediction (as
     * opposed to the parser, which creates them naturally). In a practical
     * sense, this avoids a cast exception from RuleContext to myruleContext.
     *
     * <p>For context dependent predicates, we must pass in a local context so that
     * references such as $arg evaluate properly as _localctx.arg. We only
     * capture context dependent predicates in the context in which we begin
     * prediction, so we passed in the outer context here in case of context
     * dependent predicate evaluation.</p>
     */
    evaluate(parser, outerContext) { }
    /**
     * Evaluate the precedence predicates for the context and reduce the result.
     *
     * @param parser The parser instance.
     * @param outerContext The current parser context object.
     * @return The simplified semantic context after precedence predicates are
     * evaluated, which will be one of the following values.
     * <ul>
     * <li>{@link //NONE}: if the predicate simplifies to {@code true} after
     * precedence predicates are evaluated.</li>
     * <li>{@code null}: if the predicate simplifies to {@code false} after
     * precedence predicates are evaluated.</li>
     * <li>{@code this}: if the semantic context is not changed as a result of
     * precedence predicate evaluation.</li>
     * <li>A non-{@code null} {@link SemanticContext}: the new simplified
     * semantic context after precedence predicates are evaluated.</li>
     * </ul>
     */
    evalPrecedence(parser, outerContext) {
        return this;
    }
    static andContext(a, b) {
        if (a === null || a === SemanticContext.NONE) {
            return b;
        }
        if (b === null || b === SemanticContext.NONE) {
            return a;
        }
        const result = new AND(a, b);
        if (result.opnds.length === 1) {
            return result.opnds[0];
        }
        else {
            return result;
        }
    }
    static orContext(a, b) {
        if (a === null) {
            return b;
        }
        if (b === null) {
            return a;
        }
        if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
            return SemanticContext.NONE;
        }
        const result = new OR(a, b);
        if (result.opnds.length === 1) {
            return result.opnds[0];
        }
        else {
            return result;
        }
    }
}
exports["default"] = SemanticContext;
class AND extends SemanticContext {
    /**
     * A semantic context which is true whenever none of the contained contexts
     * is false
     */
    constructor(a, b) {
        super();
        const operands = new HashSet_js_1.default();
        if (a instanceof AND) {
            a.opnds.map(function (o) {
                operands.add(o);
            });
        }
        else {
            operands.add(a);
        }
        if (b instanceof AND) {
            b.opnds.map(function (o) {
                operands.add(o);
            });
        }
        else {
            operands.add(b);
        }
        const precedencePredicates = filterPrecedencePredicates(operands);
        if (precedencePredicates.length > 0) {
            // interested in the transition with the lowest precedence
            let reduced = null;
            precedencePredicates.map(function (p) {
                if (reduced === null || p.precedence < reduced.precedence) {
                    reduced = p;
                }
            });
            operands.add(reduced);
        }
        this.opnds = Array.from(operands.values());
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof AND)) {
            return false;
        }
        else {
            return (0, equalArrays_js_1.default)(this.opnds, other.opnds);
        }
    }
    updateHashCode(hash) {
        hash.update(this.opnds, "AND");
    }
    /**
     * {@inheritDoc}
     *
     * <p>
     * The evaluation of predicates by this context is short-circuiting, but
     * unordered.</p>
     */
    evaluate(parser, outerContext) {
        for (let i = 0; i < this.opnds.length; i++) {
            if (!this.opnds[i].evaluate(parser, outerContext)) {
                return false;
            }
        }
        return true;
    }
    evalPrecedence(parser, outerContext) {
        let differs = false;
        const operands = [];
        for (let i = 0; i < this.opnds.length; i++) {
            const context = this.opnds[i];
            const evaluated = context.evalPrecedence(parser, outerContext);
            differs |= (evaluated !== context);
            if (evaluated === null) {
                // The AND context is false if any element is false
                return null;
            }
            else if (evaluated !== SemanticContext.NONE) {
                // Reduce the result by skipping true elements
                operands.push(evaluated);
            }
        }
        if (!differs) {
            return this;
        }
        if (operands.length === 0) {
            // all elements were true, so the AND context is true
            return SemanticContext.NONE;
        }
        let result = null;
        operands.map(function (o) {
            result = result === null ? o : SemanticContext.andContext(result, o);
        });
        return result;
    }
    toString() {
        const s = this.opnds.map(o => o.toString());
        return (s.length > 3 ? s.slice(3) : s).join("&&");
    }
}
class OR extends SemanticContext {
    /**
     * A semantic context which is true whenever at least one of the contained
     * contexts is true
     */
    constructor(a, b) {
        super();
        const operands = new HashSet_js_1.default();
        if (a instanceof OR) {
            a.opnds.map(function (o) {
                operands.add(o);
            });
        }
        else {
            operands.add(a);
        }
        if (b instanceof OR) {
            b.opnds.map(function (o) {
                operands.add(o);
            });
        }
        else {
            operands.add(b);
        }
        const precedencePredicates = filterPrecedencePredicates(operands);
        if (precedencePredicates.length > 0) {
            // interested in the transition with the highest precedence
            const s = precedencePredicates.sort(function (a, b) {
                return a.compareTo(b);
            });
            const reduced = s[s.length - 1];
            operands.add(reduced);
        }
        this.opnds = Array.from(operands.values());
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof OR)) {
            return false;
        }
        else {
            return (0, equalArrays_js_1.default)(this.opnds, other.opnds);
        }
    }
    updateHashCode(hash) {
        hash.update(this.opnds, "OR");
    }
    /**
     * <p>
     * The evaluation of predicates by this context is short-circuiting, but
     * unordered.</p>
     */
    evaluate(parser, outerContext) {
        for (let i = 0; i < this.opnds.length; i++) {
            if (this.opnds[i].evaluate(parser, outerContext)) {
                return true;
            }
        }
        return false;
    }
    evalPrecedence(parser, outerContext) {
        let differs = false;
        const operands = [];
        for (let i = 0; i < this.opnds.length; i++) {
            const context = this.opnds[i];
            const evaluated = context.evalPrecedence(parser, outerContext);
            differs |= (evaluated !== context);
            if (evaluated === SemanticContext.NONE) {
                // The OR context is true if any element is true
                return SemanticContext.NONE;
            }
            else if (evaluated !== null) {
                // Reduce the result by skipping false elements
                operands.push(evaluated);
            }
        }
        if (!differs) {
            return this;
        }
        if (operands.length === 0) {
            // all elements were false, so the OR context is false
            return null;
        }
        const result = null;
        operands.map(function (o) {
            return result === null ? o : SemanticContext.orContext(result, o);
        });
        return result;
    }
    toString() {
        const s = this.opnds.map(o => o.toString());
        return (s.length > 3 ? s.slice(3) : s).join("||");
    }
}
function filterPrecedencePredicates(set) {
    const result = [];
    set.values().map(function (context) {
        if (context instanceof SemanticContext.PrecedencePredicate) {
            result.push(context);
        }
    });
    return result;
}
//# sourceMappingURL=SemanticContext.js.map

/***/ }),

/***/ 9548:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ATN_js_1 = __importDefault(__webpack_require__(3600));
const ATNDeserializer_js_1 = __importDefault(__webpack_require__(8833));
const LexerATNSimulator_js_1 = __importDefault(__webpack_require__(5145));
const ParserATNSimulator_js_1 = __importDefault(__webpack_require__(1807));
const PredictionMode_js_1 = __importDefault(__webpack_require__(8895));
exports["default"] = { ATN: ATN_js_1.default, ATNDeserializer: ATNDeserializer_js_1.default, LexerATNSimulator: LexerATNSimulator_js_1.default, ParserATNSimulator: ParserATNSimulator_js_1.default, PredictionMode: PredictionMode_js_1.default };
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 6442:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const PredictionContext_js_1 = __importDefault(__webpack_require__(748));
const equalArrays_js_1 = __importDefault(__webpack_require__(1267));
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
class ArrayPredictionContext extends PredictionContext_js_1.default {
    constructor(parents, returnStates) {
        /**
         * Parent can be null only if full ctx mode and we make an array
         * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
         * null parent and
         * returnState == {@link //EMPTY_RETURN_STATE}.
         */
        const h = new HashCode_js_1.default();
        h.update(parents, returnStates);
        const hashCode = h.finish();
        super(hashCode);
        this.parents = parents;
        this.returnStates = returnStates;
        return this;
    }
    isEmpty() {
        // since EMPTY_RETURN_STATE can only appear in the last position, we
        // don't need to verify that size==1
        return this.returnStates[0] === PredictionContext_js_1.default.EMPTY_RETURN_STATE;
    }
    getParent(index) {
        return this.parents[index];
    }
    getReturnState(index) {
        return this.returnStates[index];
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof ArrayPredictionContext)) {
            return false;
        }
        else if (this.hashCode() !== other.hashCode()) {
            return false; // can't be same if hash is different
        }
        else {
            return (0, equalArrays_js_1.default)(this.returnStates, other.returnStates) &&
                (0, equalArrays_js_1.default)(this.parents, other.parents);
        }
    }
    toString() {
        if (this.isEmpty()) {
            return "[]";
        }
        else {
            let s = "[";
            for (let i = 0; i < this.returnStates.length; i++) {
                if (i > 0) {
                    s = s + ", ";
                }
                if (this.returnStates[i] === PredictionContext_js_1.default.EMPTY_RETURN_STATE) {
                    s = s + "$";
                    continue;
                }
                s = s + this.returnStates[i];
                if (this.parents[i] !== null) {
                    s = s + " " + this.parents[i];
                }
                else {
                    s = s + "null";
                }
            }
            return s + "]";
        }
    }
    get length() {
        return this.returnStates.length;
    }
}
exports["default"] = ArrayPredictionContext;
//# sourceMappingURL=ArrayPredictionContext.js.map

/***/ }),

/***/ 3466:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const PredictionContext_js_1 = __importDefault(__webpack_require__(748));
const SingletonPredictionContext_js_1 = __importDefault(__webpack_require__(292));
class EmptyPredictionContext extends SingletonPredictionContext_js_1.default {
    constructor() {
        super(null, PredictionContext_js_1.default.EMPTY_RETURN_STATE);
    }
    isEmpty() {
        return true;
    }
    getParent(index) {
        return null;
    }
    getReturnState(index) {
        return this.returnState;
    }
    equals(other) {
        return this === other;
    }
    toString() {
        return "$";
    }
}
exports["default"] = EmptyPredictionContext;
PredictionContext_js_1.default.EMPTY = new EmptyPredictionContext();
//# sourceMappingURL=EmptyPredictionContext.js.map

/***/ }),

/***/ 8535:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const RuleContext_js_1 = __importDefault(__webpack_require__(4673));
const TerminalNode_js_1 = __importDefault(__webpack_require__(7022));
const TerminalNodeImpl_js_1 = __importDefault(__webpack_require__(5418));
const ErrorNodeImpl_js_1 = __importDefault(__webpack_require__(2335));
const Interval_js_1 = __importDefault(__webpack_require__(4886));
/**
 * A rule invocation record for parsing.
 *
 *  Contains all of the information about the current rule not stored in the
 *  RuleContext. It handles parse tree children list, Any ATN state
 *  tracing, and the default values available for rule indications:
 *  start, stop, rule index, current alt number, current
 *  ATN state.
 *
 *  Subclasses made for each rule and grammar track the parameters,
 *  return values, locals, and labels specific to that rule. These
 *  are the objects that are returned from rules.
 *
 *  Note text is not an actual field of a rule return value; it is computed
 *  from start and stop using the input stream's toString() method.  I
 *  could add a ctor to this so that we can pass in and store the input
 *  stream, but I'm not sure we want to do that.  It would seem to be undefined
 *  to get the .text property anyway if the rule matches tokens from multiple
 *  input streams.
 *
 *  I do not use getters for fields of objects that are used simply to
 *  group values such as this aggregate.  The getters/setters are there to
 *  satisfy the superclass interface.
 */
class ParserRuleContext extends RuleContext_js_1.default {
    constructor(parent, invokingStateNumber) {
        parent = parent || null;
        invokingStateNumber = invokingStateNumber || null;
        super(parent, invokingStateNumber);
        this.ruleIndex = -1;
        /**
         * If we are debugging or building a parse tree for a visitor,
         * we need to track all of the tokens and rule invocations associated
         * with this rule's context. This is empty for parsing w/o tree constr.
         * operation because we don't the need to track the details about
         * how we parse this rule.
         */
        this.children = null;
        this.start = null;
        this.stop = null;
        /**
         * The exception that forced this rule to return. If the rule successfully
         * completed, this is {@code null}.
         */
        this.exception = null;
    }
    // COPY a ctx (I'm deliberately not using copy constructor)
    copyFrom(ctx) {
        // from RuleContext
        this.parentCtx = ctx.parentCtx;
        this.invokingState = ctx.invokingState;
        this.children = null;
        this.start = ctx.start;
        this.stop = ctx.stop;
        // copy any error nodes to alt label node
        if (ctx.children) {
            this.children = [];
            // reset parent pointer for any error nodes
            ctx.children.map(function (child) {
                if (child instanceof ErrorNodeImpl_js_1.default) {
                    this.children.push(child);
                    child.parentCtx = this;
                }
            }, this);
        }
    }
    // Double dispatch methods for listeners
    enterRule(listener) {
    }
    exitRule(listener) {
    }
    // Does not set parent link; other add methods do that
    addChild(child) {
        if (this.children === null) {
            this.children = [];
        }
        this.children.push(child);
        return child;
    }
    /** Used by enterOuterAlt to toss out a RuleContext previously added as
     * we entered a rule. If we have // label, we will need to remove
     * generic ruleContext object.
     */
    removeLastChild() {
        if (this.children !== null) {
            this.children.pop();
        }
    }
    addTokenNode(token) {
        const node = new TerminalNodeImpl_js_1.default(token);
        this.addChild(node);
        node.parentCtx = this;
        return node;
    }
    addErrorNode(badToken) {
        const node = new ErrorNodeImpl_js_1.default(badToken);
        this.addChild(node);
        node.parentCtx = this;
        return node;
    }
    getChild(i, type) {
        type = type || null;
        if (this.children === null || i < 0 || i >= this.children.length) {
            return null;
        }
        if (type === null) {
            return this.children[i];
        }
        else {
            for (let j = 0; j < this.children.length; j++) {
                const child = this.children[j];
                if (child instanceof type) {
                    if (i === 0) {
                        return child;
                    }
                    else {
                        i -= 1;
                    }
                }
            }
            return null;
        }
    }
    getToken(ttype, i) {
        if (this.children === null || i < 0 || i >= this.children.length) {
            return null;
        }
        for (let j = 0; j < this.children.length; j++) {
            const child = this.children[j];
            if (child instanceof TerminalNode_js_1.default) {
                if (child.symbol.type === ttype) {
                    if (i === 0) {
                        return child;
                    }
                    else {
                        i -= 1;
                    }
                }
            }
        }
        return null;
    }
    getTokens(ttype) {
        if (this.children === null) {
            return [];
        }
        else {
            const tokens = [];
            for (let j = 0; j < this.children.length; j++) {
                const child = this.children[j];
                if (child instanceof TerminalNode_js_1.default) {
                    if (child.symbol.type === ttype) {
                        tokens.push(child);
                    }
                }
            }
            return tokens;
        }
    }
    getTypedRuleContext(ctxType, i) {
        return this.getChild(i, ctxType);
    }
    getTypedRuleContexts(ctxType) {
        if (this.children === null) {
            return [];
        }
        else {
            const contexts = [];
            for (let j = 0; j < this.children.length; j++) {
                const child = this.children[j];
                if (child instanceof ctxType) {
                    contexts.push(child);
                }
            }
            return contexts;
        }
    }
    getChildCount() {
        if (this.children === null) {
            return 0;
        }
        else {
            return this.children.length;
        }
    }
    getSourceInterval() {
        if (this.start === null || this.stop === null) {
            return Interval_js_1.default.INVALID_INTERVAL;
        }
        else {
            return new Interval_js_1.default(this.start.tokenIndex, this.stop.tokenIndex);
        }
    }
}
exports["default"] = ParserRuleContext;
RuleContext_js_1.default.EMPTY = new ParserRuleContext();
//# sourceMappingURL=ParserRuleContext.js.map

/***/ }),

/***/ 748:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
class PredictionContext {
    constructor(cachedHashCode) {
        this.cachedHashCode = cachedHashCode;
    }
    /**
     * Stores the computed hash code of this {@link PredictionContext}. The hash
     * code is computed in parts to match the following reference algorithm.
     *
     * <pre>
     * private int referenceHashCode() {
     * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
     * //INITIAL_HASH});
     *
     * for (int i = 0; i &lt; {@link //size()}; i++) {
     * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
     * getParent}(i));
     * }
     *
     * for (int i = 0; i &lt; {@link //size()}; i++) {
     * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
     * //getReturnState getReturnState}(i));
     * }
     *
     * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
     * //size()});
     * return hash;
     * }
     * </pre>
     * This means only the {@link //EMPTY} context is in set.
     */
    isEmpty() {
        return this === PredictionContext.EMPTY;
    }
    hasEmptyPath() {
        return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
    }
    hashCode() {
        return this.cachedHashCode;
    }
    updateHashCode(hash) {
        hash.update(this.cachedHashCode);
    }
}
exports["default"] = PredictionContext;
/**
 * Represents {@code $} in local context prediction, which means wildcard.
 * {@code//+x =//}.
 */
PredictionContext.EMPTY = null;
/**
 * Represents {@code $} in an array in full context mode, when {@code $}
 * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
 * {@code $} = {@link //EMPTY_RETURN_STATE}.
 */
PredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;
PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;
//# sourceMappingURL=PredictionContext.js.map

/***/ }),

/***/ 4747:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAllContextNodes = exports.merge = exports.getCachedPredictionContext = exports.predictionContextFromRuleContext = void 0;
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const RuleContext_js_1 = __importDefault(__webpack_require__(4673));
const PredictionContext_js_1 = __importDefault(__webpack_require__(748));
const ArrayPredictionContext_js_1 = __importDefault(__webpack_require__(6442));
const SingletonPredictionContext_js_1 = __importDefault(__webpack_require__(292));
const EmptyPredictionContext_js_1 = __importDefault(__webpack_require__(3466));
const HashMap_js_1 = __importDefault(__webpack_require__(1935));
/**
 * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
 * Return {@link //EMPTY} if {@code outerContext} is empty or null.
 */
function predictionContextFromRuleContext(atn, outerContext) {
    if (outerContext === undefined || outerContext === null) {
        outerContext = RuleContext_js_1.default.EMPTY;
    }
    // if we are in RuleContext of start rule, s, then PredictionContext
    // is EMPTY. Nobody called us. (if we are empty, return empty)
    if (outerContext.parentCtx === null || outerContext === RuleContext_js_1.default.EMPTY) {
        return PredictionContext_js_1.default.EMPTY;
    }
    // If we have a parent, convert it to a PredictionContext graph
    const parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
    const state = atn.states[outerContext.invokingState];
    const transition = state.transitions[0];
    return SingletonPredictionContext_js_1.default.create(parent, transition.followState.stateNumber);
}
exports.predictionContextFromRuleContext = predictionContextFromRuleContext;
function getCachedPredictionContext(context, contextCache, visited) {
    if (context.isEmpty()) {
        return context;
    }
    let existing = visited.get(context) || null;
    if (existing !== null) {
        return existing;
    }
    existing = contextCache.get(context);
    if (existing !== null) {
        visited.set(context, existing);
        return existing;
    }
    let changed = false;
    let parents = [];
    for (let i = 0; i < parents.length; i++) {
        const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);
        if (changed || parent !== context.getParent(i)) {
            if (!changed) {
                parents = [];
                for (let j = 0; j < context.length; j++) {
                    parents[j] = context.getParent(j);
                }
                changed = true;
            }
            parents[i] = parent;
        }
    }
    if (!changed) {
        contextCache.add(context);
        visited.set(context, context);
        return context;
    }
    let updated = null;
    if (parents.length === 0) {
        updated = PredictionContext_js_1.default.EMPTY;
    }
    else if (parents.length === 1) {
        updated = SingletonPredictionContext_js_1.default.create(parents[0], context
            .getReturnState(0));
    }
    else {
        updated = new ArrayPredictionContext_js_1.default(parents, context.returnStates);
    }
    contextCache.add(updated);
    visited.set(updated, updated);
    visited.set(context, updated);
    return updated;
}
exports.getCachedPredictionContext = getCachedPredictionContext;
function merge(a, b, rootIsWildcard, mergeCache) {
    // share same graph if both same
    if (a === b) {
        return a;
    }
    if (a instanceof SingletonPredictionContext_js_1.default && b instanceof SingletonPredictionContext_js_1.default) {
        return mergeSingletons(a, b, rootIsWildcard, mergeCache);
    }
    // At least one of a or b is array
    // If one is $ and rootIsWildcard, return $ as// wildcard
    if (rootIsWildcard) {
        if (a instanceof EmptyPredictionContext_js_1.default) {
            return a;
        }
        if (b instanceof EmptyPredictionContext_js_1.default) {
            return b;
        }
    }
    // convert singleton so both are arrays to normalize
    if (a instanceof SingletonPredictionContext_js_1.default) {
        a = new ArrayPredictionContext_js_1.default([a.getParent()], [a.returnState]);
    }
    if (b instanceof SingletonPredictionContext_js_1.default) {
        b = new ArrayPredictionContext_js_1.default([b.getParent()], [b.returnState]);
    }
    return mergeArrays(a, b, rootIsWildcard, mergeCache);
}
exports.merge = merge;
/**
 * Merge two {@link ArrayPredictionContext} instances.
 *
 * <p>Different tops, different parents.<br>
 * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, same parents.<br>
 * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, different parents.<br>
 * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, all shared parents.<br>
 * <embed src="images/ArrayMerge_ShareTopSharePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Equal tops, merge parents and reduce top to
 * {@link SingletonPredictionContext}.<br>
 * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
 */
function mergeArrays(a, b, rootIsWildcard, mergeCache) {
    if (mergeCache !== null) {
        let previous = mergeCache.get(a, b);
        if (previous !== null) {
            return previous;
        }
        previous = mergeCache.get(b, a);
        if (previous !== null) {
            return previous;
        }
    }
    // merge sorted payloads a + b => M
    let i = 0; // walks a
    let j = 0; // walks b
    let k = 0; // walks target M array
    let mergedReturnStates = [];
    let mergedParents = [];
    // walk and merge to yield mergedParents, mergedReturnStates
    while (i < a.returnStates.length && j < b.returnStates.length) {
        const a_parent = a.parents[i];
        const b_parent = b.parents[j];
        if (a.returnStates[i] === b.returnStates[j]) {
            // same payload (stack tops are equal), must yield merged singleton
            const payload = a.returnStates[i];
            // $+$ = $
            const bothDollars = payload === PredictionContext_js_1.default.EMPTY_RETURN_STATE &&
                a_parent === null && b_parent === null;
            const ax_ax = (a_parent !== null && b_parent !== null && a_parent === b_parent); // ax+ax
            // ->
            // ax
            if (bothDollars || ax_ax) {
                mergedParents[k] = a_parent; // choose left
                mergedReturnStates[k] = payload;
            }
            else { // ax+ay -> a'[x,y]
                mergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
                mergedReturnStates[k] = payload;
            }
            i += 1; // hop over left one as usual
            j += 1; // but also skip one in right side since we merge
        }
        else if (a.returnStates[i] < b.returnStates[j]) { // copy a[i] to M
            mergedParents[k] = a_parent;
            mergedReturnStates[k] = a.returnStates[i];
            i += 1;
        }
        else { // b > a, copy b[j] to M
            mergedParents[k] = b_parent;
            mergedReturnStates[k] = b.returnStates[j];
            j += 1;
        }
        k += 1;
    }
    // copy over any payloads remaining in either array
    if (i < a.returnStates.length) {
        for (let p = i; p < a.returnStates.length; p++) {
            mergedParents[k] = a.parents[p];
            mergedReturnStates[k] = a.returnStates[p];
            k += 1;
        }
    }
    else {
        for (let p = j; p < b.returnStates.length; p++) {
            mergedParents[k] = b.parents[p];
            mergedReturnStates[k] = b.returnStates[p];
            k += 1;
        }
    }
    // trim merged if we combined a few that had same stack tops
    if (k < mergedParents.length) { // write index < last position; trim
        if (k === 1) { // for just one merged element, return singleton top
            const a_ = SingletonPredictionContext_js_1.default.create(mergedParents[0], mergedReturnStates[0]);
            if (mergeCache !== null) {
                mergeCache.set(a, b, a_);
            }
            return a_;
        }
        mergedParents = mergedParents.slice(0, k);
        mergedReturnStates = mergedReturnStates.slice(0, k);
    }
    const M = new ArrayPredictionContext_js_1.default(mergedParents, mergedReturnStates);
    // if we created same array as a or b, return that instead
    // TODO: track whether this is possible above during merge sort for speed
    if (M === a) {
        if (mergeCache !== null) {
            mergeCache.set(a, b, a);
        }
        return a;
    }
    if (M === b) {
        if (mergeCache !== null) {
            mergeCache.set(a, b, b);
        }
        return b;
    }
    combineCommonParents(mergedParents);
    if (mergeCache !== null) {
        mergeCache.set(a, b, M);
    }
    return M;
}
/**
 * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
 * ones.
 */
function combineCommonParents(parents) {
    const uniqueParents = new HashMap_js_1.default();
    for (let p = 0; p < parents.length; p++) {
        const parent = parents[p];
        if (!(uniqueParents.containsKey(parent))) {
            uniqueParents.set(parent, parent);
        }
    }
    for (let q = 0; q < parents.length; q++) {
        parents[q] = uniqueParents.get(parents[q]);
    }
}
/**
 * Merge two {@link SingletonPredictionContext} instances.
 *
 * <p>Stack tops equal, parents merge is same; return left graph.<br>
 * <embed src="images/SingletonMerge_SameRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Same stack top, parents differ; merge parents giving array node, then
 * remainders of those graphs. A new root node is created to point to the
 * merged parents.<br>
 * <embed src="images/SingletonMerge_SameRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to same parent. Make array node for the
 * root where both element in the root point to the same (original)
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to different parents. Make array node for
 * the root where each element points to the corresponding original
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 * @param mergeCache
 */
function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
    if (mergeCache !== null) {
        let previous = mergeCache.get(a, b);
        if (previous !== null) {
            return previous;
        }
        previous = mergeCache.get(b, a);
        if (previous !== null) {
            return previous;
        }
    }
    const rootMerge = mergeRoot(a, b, rootIsWildcard);
    if (rootMerge !== null) {
        if (mergeCache !== null) {
            mergeCache.set(a, b, rootMerge);
        }
        return rootMerge;
    }
    if (a.returnState === b.returnState) {
        const parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache);
        // if parent is same as existing a or b parent or reduced to a parent,
        // return it
        if (parent === a.parentCtx) {
            return a; // ax + bx = ax, if a=b
        }
        if (parent === b.parentCtx) {
            return b; // ax + bx = bx, if a=b
        }
        // else: ax + ay = a'[x,y]
        // merge parents x and y, giving array node with x,y then remainders
        // of those graphs. dup a, a' points at merged array
        // new joined parent so create new singleton pointing to it, a'
        const spc = SingletonPredictionContext_js_1.default.create(parent, a.returnState);
        if (mergeCache !== null) {
            mergeCache.set(a, b, spc);
        }
        return spc;
    }
    else { // a != b payloads differ
        // see if we can collapse parents due to $+x parents if local ctx
        let singleParent = null;
        if (a === b || (a.parentCtx !== null && a.parentCtx === b.parentCtx)) { // ax +
            // bx =
            // [a,b]x
            singleParent = a.parentCtx;
        }
        if (singleParent !== null) { // parents are same
            // sort payloads and use same parent
            const payloads = [a.returnState, b.returnState];
            if (a.returnState > b.returnState) {
                payloads[0] = b.returnState;
                payloads[1] = a.returnState;
            }
            const parents = [singleParent, singleParent];
            const apc = new ArrayPredictionContext_js_1.default(parents, payloads);
            if (mergeCache !== null) {
                mergeCache.set(a, b, apc);
            }
            return apc;
        }
        // parents differ and can't merge them. Just pack together
        // into array; can't merge.
        // ax + by = [ax,by]
        const payloads = [a.returnState, b.returnState];
        let parents = [a.parentCtx, b.parentCtx];
        if (a.returnState > b.returnState) { // sort by payload
            payloads[0] = b.returnState;
            payloads[1] = a.returnState;
            parents = [b.parentCtx, a.parentCtx];
        }
        const a_ = new ArrayPredictionContext_js_1.default(parents, payloads);
        if (mergeCache !== null) {
            mergeCache.set(a, b, a_);
        }
        return a_;
    }
}
/**
 * Handle case where at least one of {@code a} or {@code b} is
 * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
 * to represent {@link //EMPTY}.
 *
 * <h2>Local-Context Merges</h2>
 *
 * <p>These local-context merge operations are used when {@code rootIsWildcard}
 * is true.</p>
 *
 * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>
 * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
 * {@code //EMPTY}; return left graph.<br>
 * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
 *
 * <p>Special case of last merge if local context.<br>
 * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
 *
 * <h2>Full-Context Merges</h2>
 *
 * <p>These full-context merge operations are used when {@code rootIsWildcard}
 * is false.</p>
 *
 * <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
 *
 * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and
 * null parent).<br>
 * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 */
function mergeRoot(a, b, rootIsWildcard) {
    if (rootIsWildcard) {
        if (a === PredictionContext_js_1.default.EMPTY) {
            return PredictionContext_js_1.default.EMPTY; // // + b =//
        }
        if (b === PredictionContext_js_1.default.EMPTY) {
            return PredictionContext_js_1.default.EMPTY; // a +// =//
        }
    }
    else {
        if (a === PredictionContext_js_1.default.EMPTY && b === PredictionContext_js_1.default.EMPTY) {
            return PredictionContext_js_1.default.EMPTY; // $ + $ = $
        }
        else if (a === PredictionContext_js_1.default.EMPTY) { // $ + x = [$,x]
            const payloads = [b.returnState,
                PredictionContext_js_1.default.EMPTY_RETURN_STATE];
            const parents = [b.parentCtx, null];
            return new ArrayPredictionContext_js_1.default(parents, payloads);
        }
        else if (b === PredictionContext_js_1.default.EMPTY) { // x + $ = [$,x] ($ is always first if present)
            const payloads = [a.returnState, PredictionContext_js_1.default.EMPTY_RETURN_STATE];
            const parents = [a.parentCtx, null];
            return new ArrayPredictionContext_js_1.default(parents, payloads);
        }
    }
    return null;
}
// ter's recursive version of Sam's getAllNodes()
function getAllContextNodes(context, nodes, visited) {
    if (nodes === null) {
        nodes = [];
        return getAllContextNodes(context, nodes, visited);
    }
    else if (visited === null) {
        visited = new HashMap_js_1.default();
        return getAllContextNodes(context, nodes, visited);
    }
    else {
        if (context === null || visited.containsKey(context)) {
            return nodes;
        }
        visited.set(context, context);
        nodes.push(context);
        for (let i = 0; i < context.length; i++) {
            getAllContextNodes(context.getParent(i), nodes, visited);
        }
        return nodes;
    }
}
exports.getAllContextNodes = getAllContextNodes;
//# sourceMappingURL=PredictionContextUtils.js.map

/***/ }),

/***/ 4673:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const RuleNode_js_1 = __importDefault(__webpack_require__(5004));
const Interval_js_1 = __importDefault(__webpack_require__(4886));
const Trees_js_1 = __importDefault(__webpack_require__(2181));
class RuleContext extends RuleNode_js_1.default {
    /** A rule context is a record of a single rule invocation. It knows
     * which context invoked it, if any. If there is no parent context, then
     * naturally the invoking state is not valid.  The parent link
     * provides a chain upwards from the current rule invocation to the root
     * of the invocation tree, forming a stack. We actually carry no
     * information about the rule associated with this context (except
     * when parsing). We keep only the state number of the invoking state from
     * the ATN submachine that invoked this. Contrast this with the s
     * pointer inside ParserRuleContext that tracks the current state
     * being "executed" for the current rule.
     *
     * The parent contexts are useful for computing lookahead sets and
     * getting error information.
     *
     * These objects are used during parsing and prediction.
     * For the special case of parsers, we use the subclass
     * ParserRuleContext.
     *
     * @see ParserRuleContext
     */
    constructor(parent, invokingState) {
        // What context invoked this rule?
        super();
        this.parentCtx = parent || null;
        /**
         * What state invoked the rule associated with this context?
         * The "return address" is the followState of invokingState
         * If parent is null, this should be -1.
         */
        this.invokingState = invokingState || -1;
    }
    depth() {
        let n = 0;
        let p = this;
        while (p !== null) {
            p = p.parentCtx;
            n += 1;
        }
        return n;
    }
    /**
     * A context is empty if there is no invoking state; meaning nobody call
     * current context.
     */
    isEmpty() {
        return this.invokingState === -1;
    }
    // satisfy the ParseTree / SyntaxTree interface
    getSourceInterval() {
        return Interval_js_1.default.INVALID_INTERVAL;
    }
    getRuleContext() {
        return this;
    }
    getPayload() {
        return this;
    }
    /**
     * Return the combined text of all child nodes. This method only considers
     * tokens which have been added to the parse tree.
     * <p>
     * Since tokens on hidden channels (e.g. whitespace or comments) are not
     * added to the parse trees, they will not appear in the output of this
     * method.
     */
    getText() {
        if (this.getChildCount() === 0) {
            return "";
        }
        else {
            return this.children.map(function (child) {
                return child.getText();
            }).join("");
        }
    }
    /**
     * For rule associated with this parse tree internal node, return
     * the outer alternative number used to match the input. Default
     * implementation does not compute nor store this alt num. Create
     * a subclass of ParserRuleContext with backing field and set
     * option contextSuperClass.
     * to set it.
     */
    getAltNumber() {
        // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency
        return 0;
    }
    /**
     * Set the outer alternative number for this context node. Default
     * implementation does nothing to avoid backing field overhead for
     * trees that don't need it.  Create
     * a subclass of ParserRuleContext with backing field and set
     * option contextSuperClass.
     */
    setAltNumber(altNumber) {
    }
    getChild(i) {
        return null;
    }
    getChildCount() {
        return 0;
    }
    accept(visitor) {
        return visitor.visitChildren(this);
    }
    /**
     * Print out a whole tree, not just a node, in LISP format
     * (root child1 .. childN). Print just a node if this is a leaf.
     */
    toStringTree(ruleNames, recog) {
        return Trees_js_1.default.toStringTree(this, ruleNames, recog);
    }
    toString(ruleNames, stop) {
        ruleNames = ruleNames || null;
        stop = stop || null;
        let p = this;
        let s = "[";
        while (p !== null && p !== stop) {
            if (ruleNames === null) {
                if (!p.isEmpty()) {
                    s += p.invokingState;
                }
            }
            else {
                const ri = p.ruleIndex;
                const ruleName = (ri >= 0 && ri < ruleNames.length) ? ruleNames[ri]
                    : "" + ri;
                s += ruleName;
            }
            if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
                s += " ";
            }
            p = p.parentCtx;
        }
        s += "]";
        return s;
    }
}
exports["default"] = RuleContext;
//# sourceMappingURL=RuleContext.js.map

/***/ }),

/***/ 292:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const PredictionContext_js_1 = __importDefault(__webpack_require__(748));
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
class SingletonPredictionContext extends PredictionContext_js_1.default {
    constructor(parent, returnState) {
        let hashCode = 0;
        const hash = new HashCode_js_1.default();
        if (parent !== null) {
            hash.update(parent, returnState);
        }
        else {
            hash.update(1);
        }
        hashCode = hash.finish();
        super(hashCode);
        this.parentCtx = parent;
        this.returnState = returnState;
    }
    getParent(index) {
        return this.parentCtx;
    }
    getReturnState(index) {
        return this.returnState;
    }
    equals(other) {
        if (this === other) {
            return true;
        }
        else if (!(other instanceof SingletonPredictionContext)) {
            return false;
        }
        else if (this.hashCode() !== other.hashCode()) {
            return false; // can't be same if hash is different
        }
        else {
            if (this.returnState !== other.returnState)
                return false;
            else if (this.parentCtx == null)
                return other.parentCtx == null;
            else
                return this.parentCtx.equals(other.parentCtx);
        }
    }
    toString() {
        const up = this.parentCtx === null ? "" : this.parentCtx.toString();
        if (up.length === 0) {
            if (this.returnState === PredictionContext_js_1.default.EMPTY_RETURN_STATE) {
                return "$";
            }
            else {
                return "" + this.returnState;
            }
        }
        else {
            return "" + this.returnState + " " + up;
        }
    }
    get length() {
        return 1;
    }
    static create(parent, returnState) {
        if (returnState === PredictionContext_js_1.default.EMPTY_RETURN_STATE && parent === null) {
            // someone can pass in the bits of an array ctx that mean $
            return PredictionContext_js_1.default.EMPTY;
        }
        else {
            return new SingletonPredictionContext(parent, returnState);
        }
    }
}
exports["default"] = SingletonPredictionContext;
//# sourceMappingURL=SingletonPredictionContext.js.map

/***/ }),

/***/ 4878:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const DFAState_js_1 = __importDefault(__webpack_require__(2603));
const StarLoopEntryState_js_1 = __importDefault(__webpack_require__(6832));
const ATNConfigSet_js_1 = __importDefault(__webpack_require__(8254));
const DFASerializer_js_1 = __importDefault(__webpack_require__(6336));
const LexerDFASerializer_js_1 = __importDefault(__webpack_require__(8474));
const HashSet_js_1 = __importDefault(__webpack_require__(5563));
class DFA {
    constructor(atnStartState, decision) {
        if (decision === undefined) {
            decision = 0;
        }
        /**
         * From which ATN state did we create this DFA?
         */
        this.atnStartState = atnStartState;
        this.decision = decision;
        /**
         * A set of all DFA states. Use {@link Map} so we can get old state back
         * ({@link Set} only allows you to see if it's there).
         */
        this._states = new HashSet_js_1.default();
        this.s0 = null;
        /**
         * {@code true} if this DFA is for a precedence decision; otherwise,
         * {@code false}. This is the backing field for {@link //isPrecedenceDfa},
         * {@link //setPrecedenceDfa}
         */
        this.precedenceDfa = false;
        if (atnStartState instanceof StarLoopEntryState_js_1.default) {
            if (atnStartState.isPrecedenceDecision) {
                this.precedenceDfa = true;
                const precedenceState = new DFAState_js_1.default(null, new ATNConfigSet_js_1.default());
                precedenceState.edges = [];
                precedenceState.isAcceptState = false;
                precedenceState.requiresFullContext = false;
                this.s0 = precedenceState;
            }
        }
    }
    /**
     * Get the start state for a specific precedence value.
     *
     * @param precedence The current precedence.
     * @return The start state corresponding to the specified precedence, or
     * {@code null} if no start state exists for the specified precedence.
     *
     * @throws IllegalStateException if this is not a precedence DFA.
     * @see //isPrecedenceDfa()
     */
    getPrecedenceStartState(precedence) {
        if (!(this.precedenceDfa)) {
            throw ("Only precedence DFAs may contain a precedence start state.");
        }
        // s0.edges is never null for a precedence DFA
        if (precedence < 0 || precedence >= this.s0.edges.length) {
            return null;
        }
        return this.s0.edges[precedence] || null;
    }
    /**
     * Set the start state for a specific precedence value.
     *
     * @param precedence The current precedence.
     * @param startState The start state corresponding to the specified
     * precedence.
     *
     * @throws IllegalStateException if this is not a precedence DFA.
     * @see //isPrecedenceDfa()
     */
    setPrecedenceStartState(precedence, startState) {
        if (!(this.precedenceDfa)) {
            throw ("Only precedence DFAs may contain a precedence start state.");
        }
        if (precedence < 0) {
            return;
        }
        /**
         * synchronization on s0 here is ok. when the DFA is turned into a
         * precedence DFA, s0 will be initialized once and not updated again
         * s0.edges is never null for a precedence DFA
         */
        this.s0.edges[precedence] = startState;
    }
    /**
     * Sets whether this is a precedence DFA. If the specified value differs
     * from the current DFA configuration, the following actions are taken;
     * otherwise no changes are made to the current DFA.
     *
     * <ul>
     * <li>The {@link //states} map is cleared</li>
     * <li>If {@code precedenceDfa} is {@code false}, the initial state
     * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
     * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
     * store the start states for individual precedence values.</li>
     * <li>The {@link //precedenceDfa} field is updated</li>
     * </ul>
     *
     * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
     * {@code false}
     */
    setPrecedenceDfa(precedenceDfa) {
        if (this.precedenceDfa !== precedenceDfa) {
            this._states = new HashSet_js_1.default();
            if (precedenceDfa) {
                const precedenceState = new DFAState_js_1.default(null, new ATNConfigSet_js_1.default());
                precedenceState.edges = [];
                precedenceState.isAcceptState = false;
                precedenceState.requiresFullContext = false;
                this.s0 = precedenceState;
            }
            else {
                this.s0 = null;
            }
            this.precedenceDfa = precedenceDfa;
        }
    }
    /**
     * Return a list of all states in this DFA, ordered by state number.
     */
    sortedStates() {
        const list = this._states.values();
        return list.sort(function (a, b) {
            return a.stateNumber - b.stateNumber;
        });
    }
    toString(literalNames, symbolicNames) {
        literalNames = literalNames || null;
        symbolicNames = symbolicNames || null;
        if (this.s0 === null) {
            return "";
        }
        const serializer = new DFASerializer_js_1.default(this, literalNames, symbolicNames);
        return serializer.toString();
    }
    toLexerString() {
        if (this.s0 === null) {
            return "";
        }
        const serializer = new LexerDFASerializer_js_1.default(this);
        return serializer.toString();
    }
    get states() {
        return this._states;
    }
}
exports["default"] = DFA;
//# sourceMappingURL=DFA.js.map

/***/ }),

/***/ 6336:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const arrayToString_js_1 = __importDefault(__webpack_require__(1324));
/**
 * A DFA walker that knows how to dump them to serialized strings.
 */
class DFASerializer {
    constructor(dfa, literalNames, symbolicNames) {
        this.dfa = dfa;
        this.literalNames = literalNames || [];
        this.symbolicNames = symbolicNames || [];
    }
    toString() {
        if (this.dfa.s0 === null) {
            return null;
        }
        let buf = "";
        const states = this.dfa.sortedStates();
        for (let i = 0; i < states.length; i++) {
            const s = states[i];
            if (s.edges !== null) {
                const n = s.edges.length;
                for (let j = 0; j < n; j++) {
                    const t = s.edges[j] || null;
                    if (t !== null && t.stateNumber !== 0x7FFFFFFF) {
                        buf = buf.concat(this.getStateString(s));
                        buf = buf.concat("-");
                        buf = buf.concat(this.getEdgeLabel(j));
                        buf = buf.concat("->");
                        buf = buf.concat(this.getStateString(t));
                        buf = buf.concat('\n');
                    }
                }
            }
        }
        return buf.length === 0 ? null : buf;
    }
    getEdgeLabel(i) {
        if (i === 0) {
            return "EOF";
        }
        else if (this.literalNames !== null || this.symbolicNames !== null) {
            return this.literalNames[i - 1] || this.symbolicNames[i - 1];
        }
        else {
            return String.fromCharCode(i - 1);
        }
    }
    getStateString(s) {
        const baseStateStr = (s.isAcceptState ? ":" : "") + "s" + s.stateNumber + (s.requiresFullContext ? "^" : "");
        if (s.isAcceptState) {
            if (s.predicates !== null) {
                return baseStateStr + "=>" + (0, arrayToString_js_1.default)(s.predicates);
            }
            else {
                return baseStateStr + "=>" + s.prediction.toString();
            }
        }
        else {
            return baseStateStr;
        }
    }
}
exports["default"] = DFASerializer;
//# sourceMappingURL=DFASerializer.js.map

/***/ }),

/***/ 2603:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ATNConfigSet_js_1 = __importDefault(__webpack_require__(8254));
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
const HashSet_js_1 = __importDefault(__webpack_require__(5563));
/**
 * A DFA state represents a set of possible ATN configurations.
 * As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
 * to keep track of all possible states the ATN can be in after
 * reading each input symbol. That is to say, after reading
 * input a1a2..an, the DFA is in a state that represents the
 * subset T of the states of the ATN that are reachable from the
 * ATN's start state along some path labeled a1a2..an."
 * In conventional NFA&rarr;DFA conversion, therefore, the subset T
 * would be a bitset representing the set of states the
 * ATN could be in. We need to track the alt predicted by each
 * state as well, however. More importantly, we need to maintain
 * a stack of states, tracking the closure operations as they
 * jump from rule to rule, emulating rule invocations (method calls).
 * I have to add a stack to simulate the proper lookahead sequences for
 * the underlying LL grammar from which the ATN was derived.
 *
 * <p>I use a set of ATNConfig objects not simple states. An ATNConfig
 * is both a state (ala normal conversion) and a RuleContext describing
 * the chain of rules (if any) followed to arrive at that state.</p>
 *
 * <p>A DFA state may have multiple references to a particular state,
 * but with different ATN contexts (with same or different alts)
 * meaning that state was reached via a different set of rule invocations.</p>
 */
class DFAState {
    constructor(stateNumber, configs) {
        if (stateNumber === null) {
            stateNumber = -1;
        }
        if (configs === null) {
            configs = new ATNConfigSet_js_1.default();
        }
        this.stateNumber = stateNumber;
        this.configs = configs;
        /**
         * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
         * {@link Token//EOF} maps to {@code edges[0]}.
         */
        this.edges = null;
        this.isAcceptState = false;
        /**
         * if accept state, what ttype do we match or alt do we predict?
         * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}
         * {@code !=null} or {@link //requiresFullContext}.
         */
        this.prediction = 0;
        this.lexerActionExecutor = null;
        /**
         * Indicates that this state was created during SLL prediction that
         * discovered a conflict between the configurations in the state. Future
         * {@link ParserATNSimulator//execATN} invocations immediately jumped doing
         * full context prediction if this field is true.
         */
        this.requiresFullContext = false;
        /**
         * During SLL parsing, this is a list of predicates associated with the
         * ATN configurations of the DFA state. When we have predicates,
         * {@link //requiresFullContext} is {@code false} since full context
         * prediction evaluates predicates
         * on-the-fly. If this is not null, then {@link //prediction} is
         * {@link ATN//INVALID_ALT_NUMBER}.
         *
         * <p>We only use these for non-{@link //requiresFullContext} but
         * conflicting states. That
         * means we know from the context (it's $ or we don't dip into outer
         * context) that it's an ambiguity not a conflict.</p>
         *
         * <p>This list is computed by {@link
         * ParserATNSimulator//predicateDFAState}.</p>
         */
        this.predicates = null;
        return this;
    }
    /**
     * Get the set of all alts mentioned by all ATN configurations in this
     * DFA state.
     */
    getAltSet() {
        const alts = new HashSet_js_1.default();
        if (this.configs !== null) {
            for (let i = 0; i < this.configs.length; i++) {
                const c = this.configs[i];
                alts.add(c.alt);
            }
        }
        if (alts.length === 0) {
            return null;
        }
        else {
            return alts;
        }
    }
    /**
     * Two {@link DFAState} instances are equal if their ATN configuration sets
     * are the same. This method is used to see if a state already exists.
     *
     * <p>Because the number of alternatives and number of ATN configurations are
     * finite, there is a finite number of DFA states that can be processed.
     * This is necessary to show that the algorithm terminates.</p>
     *
     * <p>Cannot test the DFA state numbers here because in
     * {@link ParserATNSimulator//addDFAState} we need to know if any other state
     * exists that has this exact set of ATN configurations. The
     * {@link //stateNumber} is irrelevant.</p>
     */
    equals(other) {
        // compare set of ATN configurations in this set with other
        return this === other ||
            (other instanceof DFAState &&
                this.configs.equals(other.configs));
    }
    toString() {
        let s = "" + this.stateNumber + ":" + this.configs;
        if (this.isAcceptState) {
            s = s + "=>";
            if (this.predicates !== null)
                s = s + this.predicates;
            else
                s = s + this.prediction;
        }
        return s;
    }
    hashCode() {
        const hash = new HashCode_js_1.default();
        hash.update(this.configs);
        return hash.finish();
    }
}
exports["default"] = DFAState;
//# sourceMappingURL=DFAState.js.map

/***/ }),

/***/ 8474:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const DFASerializer_js_1 = __importDefault(__webpack_require__(6336));
class LexerDFASerializer extends DFASerializer_js_1.default {
    constructor(dfa) {
        super(dfa, null);
    }
    getEdgeLabel(i) {
        return "'" + String.fromCharCode(i) + "'";
    }
}
exports["default"] = LexerDFASerializer;
//# sourceMappingURL=LexerDFASerializer.js.map

/***/ }),

/***/ 8875:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/**
 * Map a predicate to a predicted alternative.
 */
class PredPrediction {
    constructor(pred, alt) {
        this.alt = alt;
        this.pred = pred;
    }
    toString() {
        return "(" + this.pred + ", " + this.alt + ")";
    }
}
exports["default"] = PredPrediction;
//# sourceMappingURL=PredPrediction.js.map

/***/ }),

/***/ 5224:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const DFA_js_1 = __importDefault(__webpack_require__(4878));
const DFASerializer_js_1 = __importDefault(__webpack_require__(6336));
const LexerDFASerializer_js_1 = __importDefault(__webpack_require__(8474));
const PredPrediction_js_1 = __importDefault(__webpack_require__(8875));
exports["default"] = { DFA: DFA_js_1.default, DFASerializer: DFASerializer_js_1.default, LexerDFASerializer: LexerDFASerializer_js_1.default, PredPrediction: PredPrediction_js_1.default };
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 267:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const InputMismatchException_js_1 = __importDefault(__webpack_require__(3067));
const ParseCancellationException_js_1 = __importDefault(__webpack_require__(9278));
const DefaultErrorStrategy_js_1 = __importDefault(__webpack_require__(838));
/**
 * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
 * by immediately canceling the parse operation with a
 * {@link ParseCancellationException}. The implementation ensures that the
 * {@link ParserRuleContext//exception} field is set for all parse tree nodes
 * that were not completed prior to encountering the error.
 *
 * <p>
 * This error strategy is useful in the following scenarios.</p>
 *
 * <ul>
 * <li><strong>Two-stage parsing:</strong> This error strategy allows the first
 * stage of two-stage parsing to immediately terminate if an error is
 * encountered, and immediately fall back to the second stage. In addition to
 * avoiding wasted work by attempting to recover from errors here, the empty
 * implementation of {@link BailErrorStrategy//sync} improves the performance of
 * the first stage.</li>
 * <li><strong>Silent validation:</strong> When syntax errors are not being
 * reported or logged, and the parse result is simply ignored if errors occur,
 * the {@link BailErrorStrategy} avoids wasting work on recovering from errors
 * when the result will be ignored either way.</li>
 * </ul>
 *
 * <p>
 * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
 *
 * @see Parser//setErrorHandler(ANTLRErrorStrategy)
 * */
class BailErrorStrategy extends DefaultErrorStrategy_js_1.default {
    constructor() {
        super();
    }
    /**
     * Instead of recovering from exception {@code e}, re-throw it wrapped
     * in a {@link ParseCancellationException} so it is not caught by the
     * rule function catches. Use {@link Exception//getCause()} to get the
     * original {@link RecognitionException}.
     */
    recover(recognizer, e) {
        let context = recognizer._ctx;
        while (context !== null) {
            context.exception = e;
            context = context.parentCtx;
        }
        throw new ParseCancellationException_js_1.default(e);
    }
    /**
     * Make sure we don't attempt to recover inline; if the parser
     * successfully recovers, it won't throw an exception.
     */
    recoverInline(recognizer) {
        this.recover(recognizer, new InputMismatchException_js_1.default(recognizer));
    }
    // Make sure we don't attempt to recover from problems in subrules.//
    sync(recognizer) {
        // pass
    }
}
exports["default"] = BailErrorStrategy;
//# sourceMappingURL=BailErrorStrategy.js.map

/***/ }),

/***/ 3640:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ErrorListener_js_1 = __importDefault(__webpack_require__(5827));
/**
 * {@inheritDoc}
 *
 * <p>
 * This implementation prints messages to {@link System//err} containing the
 * values of {@code line}, {@code charPositionInLine}, and {@code msg} using
 * the following format.</p>
 *
 * <pre>
 * line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
 * </pre>
 *
 */
class ConsoleErrorListener extends ErrorListener_js_1.default {
    constructor() {
        super();
    }
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
        console.error("line " + line + ":" + column + " " + msg);
    }
}
exports["default"] = ConsoleErrorListener;
/**
 * Provides a default instance of {@link ConsoleErrorListener}.
 */
ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();
//# sourceMappingURL=ConsoleErrorListener.js.map

/***/ }),

/***/ 838:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const FailedPredicateException_js_1 = __importDefault(__webpack_require__(409));
const InputMismatchException_js_1 = __importDefault(__webpack_require__(3067));
const NoViableAltException_js_1 = __importDefault(__webpack_require__(1454));
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const Interval_js_1 = __importDefault(__webpack_require__(4886));
const IntervalSet_js_1 = __importDefault(__webpack_require__(619));
const ErrorStrategy_js_1 = __importDefault(__webpack_require__(1080));
/**
 * This is the default implementation of {@link ANTLRErrorStrategy} used for
 * error reporting and recovery in ANTLR parsers.
 */
class DefaultErrorStrategy extends ErrorStrategy_js_1.default {
    constructor() {
        super();
        /**
         * Indicates whether the error strategy is currently "recovering from an
         * error". This is used to suppress reporting multiple error messages while
         * attempting to recover from a detected syntax error.
         *
         * @see //inErrorRecoveryMode
         */
        this.errorRecoveryMode = false;
        /**
         * The index into the input stream where the last error occurred.
         * This is used to prevent infinite loops where an error is found
         * but no token is consumed during recovery...another error is found,
         * ad nauseum. This is a failsafe mechanism to guarantee that at least
         * one token/tree node is consumed for two errors.
         */
        this.lastErrorIndex = -1;
        this.lastErrorStates = null;
        this.nextTokensContext = null;
        this.nextTokenState = 0;
    }
    /**
     * <p>The default implementation simply calls {@link //endErrorCondition} to
     * ensure that the handler is not in error recovery mode.</p>
     */
    reset(recognizer) {
        this.endErrorCondition(recognizer);
    }
    /**
     * This method is called to enter error recovery mode when a recognition
     * exception is reported.
     *
     * @param recognizer the parser instance
     */
    beginErrorCondition(recognizer) {
        this.errorRecoveryMode = true;
    }
    inErrorRecoveryMode(recognizer) {
        return this.errorRecoveryMode;
    }
    /**
     * This method is called to leave error recovery mode after recovering from
     * a recognition exception.
     * @param recognizer
     */
    endErrorCondition(recognizer) {
        this.errorRecoveryMode = false;
        this.lastErrorStates = null;
        this.lastErrorIndex = -1;
    }
    /**
     * {@inheritDoc}
     * <p>The default implementation simply calls {@link //endErrorCondition}.</p>
     */
    reportMatch(recognizer) {
        this.endErrorCondition(recognizer);
    }
    /**
     * {@inheritDoc}
     *
     * <p>The default implementation returns immediately if the handler is already
     * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
     * and dispatches the reporting task based on the runtime type of {@code e}
     * according to the following table.</p>
     *
     * <ul>
     * <li>{@link NoViableAltException}: Dispatches the call to
     * {@link //reportNoViableAlternative}</li>
     * <li>{@link InputMismatchException}: Dispatches the call to
     * {@link //reportInputMismatch}</li>
     * <li>{@link FailedPredicateException}: Dispatches the call to
     * {@link //reportFailedPredicate}</li>
     * <li>All other types: calls {@link Parser//notifyErrorListeners} to report
     * the exception</li>
     * </ul>
     */
    reportError(recognizer, e) {
        // if we've already reported an error and have not matched a token
        // yet successfully, don't report any errors.
        if (this.inErrorRecoveryMode(recognizer)) {
            return; // don't report spurious errors
        }
        this.beginErrorCondition(recognizer);
        if (e instanceof NoViableAltException_js_1.default) {
            this.reportNoViableAlternative(recognizer, e);
        }
        else if (e instanceof InputMismatchException_js_1.default) {
            this.reportInputMismatch(recognizer, e);
        }
        else if (e instanceof FailedPredicateException_js_1.default) {
            this.reportFailedPredicate(recognizer, e);
        }
        else {
            console.log("unknown recognition error type: " + e.constructor.name);
            console.log(e.stack);
            recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
        }
    }
    /**
     *
     * {@inheritDoc}
     *
     * <p>The default implementation resynchronizes the parser by consuming tokens
     * until we find one in the resynchronization set--loosely the set of tokens
     * that can follow the current rule.</p>
     *
     */
    recover(recognizer, e) {
        if (this.lastErrorIndex === recognizer.getInputStream().index &&
            this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {
            // uh oh, another error at same token index and previously-visited
            // state in ATN; must be a case where LT(1) is in the recovery
            // token set so nothing got consumed. Consume a single token
            // at least to prevent an infinite loop; this is a failsafe.
            recognizer.consume();
        }
        this.lastErrorIndex = recognizer._input.index;
        if (this.lastErrorStates === null) {
            this.lastErrorStates = [];
        }
        this.lastErrorStates.push(recognizer.state);
        const followSet = this.getErrorRecoverySet(recognizer);
        this.consumeUntil(recognizer, followSet);
    }
    /**
     * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
     * that the current lookahead symbol is consistent with what were expecting
     * at this point in the ATN. You can call this anytime but ANTLR only
     * generates code to check before subrules/loops and each iteration.
     *
     * <p>Implements Jim Idle's magic sync mechanism in closures and optional
     * subrules. E.g.,</p>
     *
     * <pre>
     * a : sync ( stuff sync )* ;
     * sync : {consume to what can follow sync} ;
     * </pre>
     *
     * At the start of a sub rule upon error, {@link //sync} performs single
     * token deletion, if possible. If it can't do that, it bails on the current
     * rule and uses the default error recovery, which consumes until the
     * resynchronization set of the current rule.
     *
     * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
     * with an empty alternative), then the expected set includes what follows
     * the subrule.</p>
     *
     * <p>During loop iteration, it consumes until it sees a token that can start a
     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
     * stay in the loop as long as possible.</p>
     *
     * <p><strong>ORIGINS</strong></p>
     *
     * <p>Previous versions of ANTLR did a poor job of their recovery within loops.
     * A single mismatch token or missing token would force the parser to bail
     * out of the entire rules surrounding the loop. So, for rule</p>
     *
     * <pre>
     * classDef : 'class' ID '{' member* '}'
     * </pre>
     *
     * input with an extra token between members would force the parser to
     * consume until it found the next class definition rather than the next
     * member definition of the current class.
     *
     * <p>This functionality cost a little bit of effort because the parser has to
     * compare token set at the start of the loop and at each iteration. If for
     * some reason speed is suffering for you, you can turn off this
     * functionality by simply overriding this method as a blank { }.</p>
     *
     */
    sync(recognizer) {
        // If already recovering, don't try to sync
        if (this.inErrorRecoveryMode(recognizer)) {
            return;
        }
        const s = recognizer._interp.atn.states[recognizer.state];
        const la = recognizer.getTokenStream().LA(1);
        // try cheaper subset first; might get lucky. seems to shave a wee bit off
        const nextTokens = recognizer.atn.nextTokens(s);
        if (nextTokens.contains(la)) {
            this.nextTokensContext = null;
            this.nextTokenState = ATNState_js_1.default.INVALID_STATE_NUMBER;
            return;
        }
        else if (nextTokens.contains(Token_js_1.default.EPSILON)) {
            if (this.nextTokensContext === null) {
                // It's possible the next token won't match information tracked
                // by sync is restricted for performance.
                this.nextTokensContext = recognizer._ctx;
                this.nextTokensState = recognizer._stateNumber;
            }
            return;
        }
        switch (s.stateType) {
            case ATNState_js_1.default.BLOCK_START:
            case ATNState_js_1.default.STAR_BLOCK_START:
            case ATNState_js_1.default.PLUS_BLOCK_START:
            case ATNState_js_1.default.STAR_LOOP_ENTRY:
                // report error and recover if possible
                if (this.singleTokenDeletion(recognizer) !== null) {
                    return;
                }
                else {
                    throw new InputMismatchException_js_1.default(recognizer);
                }
            case ATNState_js_1.default.PLUS_LOOP_BACK:
            case ATNState_js_1.default.STAR_LOOP_BACK:
                {
                    this.reportUnwantedToken(recognizer);
                    const expecting = new IntervalSet_js_1.default();
                    expecting.addSet(recognizer.getExpectedTokens());
                    const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
                    this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
                }
                break;
            default:
            // do nothing if we can't identify the exact kind of ATN state
        }
    }
    /**
     * This is called by {@link //reportError} when the exception is a
     * {@link NoViableAltException}.
     *
     * @see //reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportNoViableAlternative(recognizer, e) {
        const tokens = recognizer.getTokenStream();
        let input;
        if (tokens !== null) {
            if (e.startToken.type === Token_js_1.default.EOF) {
                input = "<EOF>";
            }
            else {
                input = tokens.getText(new Interval_js_1.default(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
            }
        }
        else {
            input = "<unknown input>";
        }
        const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    /**
     * This is called by {@link //reportError} when the exception is an
     * {@link InputMismatchException}.
     *
     * @see //reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportInputMismatch(recognizer, e) {
        const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) +
            " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    /**
     * This is called by {@link //reportError} when the exception is a
     * {@link FailedPredicateException}.
     *
     * @see //reportError
     *
     * @param recognizer the parser instance
     * @param e the recognition exception
     */
    reportFailedPredicate(recognizer, e) {
        const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
        const msg = "rule " + ruleName + " " + e.message;
        recognizer.notifyErrorListeners(msg, e.offendingToken, e);
    }
    /**
     * This method is called to report a syntax error which requires the removal
     * of a token from the input stream. At the time this method is called, the
     * erroneous symbol is current {@code LT(1)} symbol and has not yet been
     * removed from the input stream. When this method returns,
     * {@code recognizer} is in error recovery mode.
     *
     * <p>This method is called when {@link //singleTokenDeletion} identifies
     * single-token deletion as a viable recovery strategy for a mismatched
     * input error.</p>
     *
     * <p>The default implementation simply returns if the handler is already in
     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
     * enter error recovery mode, followed by calling
     * {@link Parser//notifyErrorListeners}.</p>
     *
     * @param recognizer the parser instance
     *
     */
    reportUnwantedToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
            return;
        }
        this.beginErrorCondition(recognizer);
        const t = recognizer.getCurrentToken();
        const tokenName = this.getTokenErrorDisplay(t);
        const expecting = this.getExpectedTokens(recognizer);
        const msg = "extraneous input " + tokenName + " expecting " +
            expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
        recognizer.notifyErrorListeners(msg, t, null);
    }
    /**
     * This method is called to report a syntax error which requires the
     * insertion of a missing token into the input stream. At the time this
     * method is called, the missing token has not yet been inserted. When this
     * method returns, {@code recognizer} is in error recovery mode.
     *
     * <p>This method is called when {@link //singleTokenInsertion} identifies
     * single-token insertion as a viable recovery strategy for a mismatched
     * input error.</p>
     *
     * <p>The default implementation simply returns if the handler is already in
     * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
     * enter error recovery mode, followed by calling
     * {@link Parser//notifyErrorListeners}.</p>
     *
     * @param recognizer the parser instance
     */
    reportMissingToken(recognizer) {
        if (this.inErrorRecoveryMode(recognizer)) {
            return;
        }
        this.beginErrorCondition(recognizer);
        const t = recognizer.getCurrentToken();
        const expecting = this.getExpectedTokens(recognizer);
        const msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +
            " at " + this.getTokenErrorDisplay(t);
        recognizer.notifyErrorListeners(msg, t, null);
    }
    /**
     * <p>The default implementation attempts to recover from the mismatched input
     * by using single token insertion and deletion as described below. If the
     * recovery attempt fails, this method throws an
     * {@link InputMismatchException}.</p>
     *
     * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
     *
     * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
     * right token, however, then assume {@code LA(1)} is some extra spurious
     * token and delete it. Then consume and return the next token (which was
     * the {@code LA(2)} token) as the successful result of the match operation.</p>
     *
     * <p>This recovery strategy is implemented by {@link
        * //singleTokenDeletion}.</p>
     *
     * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
     *
     * <p>If current token (at {@code LA(1)}) is consistent with what could come
     * after the expected {@code LA(1)} token, then assume the token is missing
     * and use the parser's {@link TokenFactory} to create it on the fly. The
     * "insertion" is performed by returning the created token as the successful
     * result of the match operation.</p>
     *
     * <p>This recovery strategy is implemented by {@link
        * //singleTokenInsertion}.</p>
     *
     * <p><strong>EXAMPLE</strong></p>
     *
     * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
     * the parser returns from the nested call to {@code expr}, it will have
     * call chain:</p>
     *
     * <pre>
     * stat &rarr; expr &rarr; atom
     * </pre>
     *
     * and it will be trying to match the {@code ')'} at this point in the
     * derivation:
     *
     * <pre>
     * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
     * ^
     * </pre>
     *
     * The attempt to match {@code ')'} will fail when it sees {@code ';'} and
     * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
     * is in the set of tokens that can follow the {@code ')'} token reference
     * in rule {@code atom}. It can assume that you forgot the {@code ')'}.
     */
    recoverInline(recognizer) {
        // SINGLE TOKEN DELETION
        const matchedSymbol = this.singleTokenDeletion(recognizer);
        if (matchedSymbol !== null) {
            // we have deleted the extra token.
            // now, move past ttype token as if all were ok
            recognizer.consume();
            return matchedSymbol;
        }
        // SINGLE TOKEN INSERTION
        if (this.singleTokenInsertion(recognizer)) {
            return this.getMissingSymbol(recognizer);
        }
        // even that didn't work; must throw the exception
        throw new InputMismatchException_js_1.default(recognizer);
    }
    /**
     * This method implements the single-token insertion inline error recovery
     * strategy. It is called by {@link //recoverInline} if the single-token
     * deletion strategy fails to recover from the mismatched input. If this
     * method returns {@code true}, {@code recognizer} will be in error recovery
     * mode.
     *
     * <p>This method determines whether or not single-token insertion is viable by
     * checking if the {@code LA(1)} input symbol could be successfully matched
     * if it were instead the {@code LA(2)} symbol. If this method returns
     * {@code true}, the caller is responsible for creating and inserting a
     * token with the correct type to produce this behavior.</p>
     *
     * @param recognizer the parser instance
     * @return {@code true} if single-token insertion is a viable recovery
     * strategy for the current mismatched input, otherwise {@code false}
     */
    singleTokenInsertion(recognizer) {
        const currentSymbolType = recognizer.getTokenStream().LA(1);
        // if current token is consistent with what could come after current
        // ATN state, then we know we're missing a token; error recovery
        // is free to conjure up and insert the missing token
        const atn = recognizer._interp.atn;
        const currentState = atn.states[recognizer.state];
        const next = currentState.transitions[0].target;
        const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);
        if (expectingAtLL2.contains(currentSymbolType)) {
            this.reportMissingToken(recognizer);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * This method implements the single-token deletion inline error recovery
     * strategy. It is called by {@link //recoverInline} to attempt to recover
     * from mismatched input. If this method returns null, the parser and error
     * handler state will not have changed. If this method returns non-null,
     * {@code recognizer} will <em>not</em> be in error recovery mode since the
     * returned token was a successful match.
     *
     * <p>If the single-token deletion is successful, this method calls
     * {@link //reportUnwantedToken} to report the error, followed by
     * {@link Parser//consume} to actually "delete" the extraneous token. Then,
     * before returning {@link //reportMatch} is called to signal a successful
     * match.</p>
     *
     * @param recognizer the parser instance
     * @return the successfully matched {@link Token} instance if single-token
     * deletion successfully recovers from the mismatched input, otherwise
     * {@code null}
     */
    singleTokenDeletion(recognizer) {
        const nextTokenType = recognizer.getTokenStream().LA(2);
        const expecting = this.getExpectedTokens(recognizer);
        if (expecting.contains(nextTokenType)) {
            this.reportUnwantedToken(recognizer);
            // print("recoverFromMismatchedToken deleting " \
            // + str(recognizer.getTokenStream().LT(1)) \
            // + " since " + str(recognizer.getTokenStream().LT(2)) \
            // + " is what we want", file=sys.stderr)
            recognizer.consume(); // simply delete extra token
            // we want to return the token we're actually matching
            const matchedSymbol = recognizer.getCurrentToken();
            this.reportMatch(recognizer); // we know current token is correct
            return matchedSymbol;
        }
        else {
            return null;
        }
    }
    /**
     * Conjure up a missing token during error recovery.
     *
     * The recognizer attempts to recover from single missing
     * symbols. But, actions might refer to that missing symbol.
     * For example, x=ID {f($x);}. The action clearly assumes
     * that there has been an identifier matched previously and that
     * $x points at that token. If that token is missing, but
     * the next token in the stream is what we want we assume that
     * this token is missing and we keep going. Because we
     * have to return some token to replace the missing token,
     * we have to conjure one up. This method gives the user control
     * over the tokens returned for missing tokens. Mostly,
     * you will want to create something special for identifier
     * tokens. For literals such as '{' and ',', the default
     * action in the parser or tree parser works. It simply creates
     * a CommonToken of the appropriate type. The text will be the token.
     * If you change what tokens must be created by the lexer,
     * override this method to create the appropriate tokens.
     *
     */
    getMissingSymbol(recognizer) {
        const currentSymbol = recognizer.getCurrentToken();
        const expecting = this.getExpectedTokens(recognizer);
        const expectedTokenType = expecting.first(); // get any element
        let tokenText;
        if (expectedTokenType === Token_js_1.default.EOF) {
            tokenText = "<missing EOF>";
        }
        else {
            tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
        }
        let current = currentSymbol;
        const lookback = recognizer.getTokenStream().LT(-1);
        if (current.type === Token_js_1.default.EOF && lookback !== null) {
            current = lookback;
        }
        return recognizer.getTokenFactory().create(current.source, expectedTokenType, tokenText, Token_js_1.default.DEFAULT_CHANNEL, -1, -1, current.line, current.column);
    }
    getExpectedTokens(recognizer) {
        return recognizer.getExpectedTokens();
    }
    /**
     * How should a token be displayed in an error message? The default
     * is to display just the text, but during development you might
     * want to have a lot of information spit out. Override in that case
     * to use t.toString() (which, for CommonToken, dumps everything about
     * the token). This is better than forcing you to override a method in
     * your token objects because you don't have to go modify your lexer
     * so that it creates a new Java type.
     */
    getTokenErrorDisplay(t) {
        if (t === null) {
            return "<no token>";
        }
        let s = t.text;
        if (s === null) {
            if (t.type === Token_js_1.default.EOF) {
                s = "<EOF>";
            }
            else {
                s = "<" + t.type + ">";
            }
        }
        return this.escapeWSAndQuote(s);
    }
    escapeWSAndQuote(s) {
        s = s.replace(/\n/g, "\\n");
        s = s.replace(/\r/g, "\\r");
        s = s.replace(/\t/g, "\\t");
        return "'" + s + "'";
    }
    /**
     * Compute the error recovery set for the current rule. During
     * rule invocation, the parser pushes the set of tokens that can
     * follow that rule reference on the stack; this amounts to
     * computing FIRST of what follows the rule reference in the
     * enclosing rule. See LinearApproximator.FIRST().
     * This local follow set only includes tokens
     * from within the rule; i.e., the FIRST computation done by
     * ANTLR stops at the end of a rule.
     *
     * EXAMPLE
     *
     * When you find a "no viable alt exception", the input is not
     * consistent with any of the alternatives for rule r. The best
     * thing to do is to consume tokens until you see something that
     * can legally follow a call to r//or* any rule that called r.
     * You don't want the exact set of viable next tokens because the
     * input might just be missing a token--you might consume the
     * rest of the input looking for one of the missing tokens.
     *
     * Consider grammar:
     *
     * a : '[' b ']'
     * | '(' b ')'
     * ;
     * b : c '^' INT ;
     * c : ID
     * | INT
     * ;
     *
     * At each rule invocation, the set of tokens that could follow
     * that rule is pushed on a stack. Here are the various
     * context-sensitive follow sets:
     *
     * FOLLOW(b1_in_a) = FIRST(']') = ']'
     * FOLLOW(b2_in_a) = FIRST(')') = ')'
     * FOLLOW(c_in_b) = FIRST('^') = '^'
     *
     * Upon erroneous input "[]", the call chain is
     *
     * a -> b -> c
     *
     * and, hence, the follow context stack is:
     *
     * depth follow set start of rule execution
     * 0 <EOF> a (from main())
     * 1 ']' b
     * 2 '^' c
     *
     * Notice that ')' is not included, because b would have to have
     * been called from a different context in rule a for ')' to be
     * included.
     *
     * For error recovery, we cannot consider FOLLOW(c)
     * (context-sensitive or otherwise). We need the combined set of
     * all context-sensitive FOLLOW sets--the set of all tokens that
     * could follow any reference in the call chain. We need to
     * resync to one of those tokens. Note that FOLLOW(c)='^' and if
     * we resync'd to that token, we'd consume until EOF. We need to
     * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
     * In this case, for input "[]", LA(1) is ']' and in the set, so we would
     * not consume anything. After printing an error, rule c would
     * return normally. Rule b would not find the required '^' though.
     * At this point, it gets a mismatched token error and throws an
     * exception (since LA(1) is not in the viable following token
     * set). The rule exception handler tries to recover, but finds
     * the same recovery set and doesn't consume anything. Rule b
     * exits normally returning to rule a. Now it finds the ']' (and
     * with the successful match exits errorRecovery mode).
     *
     * So, you can see that the parser walks up the call chain looking
     * for the token that was a member of the recovery set.
     *
     * Errors are not generated in errorRecovery mode.
     *
     * ANTLR's error recovery mechanism is based upon original ideas:
     *
     * "Algorithms + Data Structures = Programs" by Niklaus Wirth
     *
     * and
     *
     * "A note on error recovery in recursive descent parsers":
     * http://portal.acm.org/citation.cfm?id=947902.947905
     *
     * Later, Josef Grosch had some good ideas:
     *
     * "Efficient and Comfortable Error Recovery in Recursive Descent
     * Parsers":
     * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
     *
     * Like Grosch I implement context-sensitive FOLLOW sets that are combined
     * at run-time upon error to avoid overhead during parsing.
     */
    getErrorRecoverySet(recognizer) {
        const atn = recognizer._interp.atn;
        let ctx = recognizer._ctx;
        const recoverSet = new IntervalSet_js_1.default();
        while (ctx !== null && ctx.invokingState >= 0) {
            // compute what follows who invoked us
            const invokingState = atn.states[ctx.invokingState];
            const rt = invokingState.transitions[0];
            const follow = atn.nextTokens(rt.followState);
            recoverSet.addSet(follow);
            ctx = ctx.parentCtx;
        }
        recoverSet.removeOne(Token_js_1.default.EPSILON);
        return recoverSet;
    }
    // Consume tokens until one matches the given token set.//
    consumeUntil(recognizer, set) {
        let ttype = recognizer.getTokenStream().LA(1);
        while (ttype !== Token_js_1.default.EOF && !set.contains(ttype)) {
            recognizer.consume();
            ttype = recognizer.getTokenStream().LA(1);
        }
    }
}
exports["default"] = DefaultErrorStrategy;
//# sourceMappingURL=DefaultErrorStrategy.js.map

/***/ }),

/***/ 1574:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ErrorListener_js_1 = __importDefault(__webpack_require__(5827));
const Interval_js_1 = __importDefault(__webpack_require__(4886));
const BitSet_js_1 = __importDefault(__webpack_require__(7149));
/**
 * This implementation of {@link ANTLRErrorListener} can be used to identify
 *  certain potential correctness and performance problems in grammars. "Reports"
 *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate
 *  message.
 *
 *  <ul>
 *  <li><b>Ambiguities</b>: These are cases where more than one path through the
 *  grammar can match the input.</li>
 *  <li><b>Weak context sensitivity</b>: These are cases where full-context
 *  prediction resolved an SLL conflict to a unique alternative which equaled the
 *  minimum alternative of the SLL conflict.</li>
 *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the
 *  full-context prediction resolved an SLL conflict to a unique alternative,
 *  <em>and</em> the minimum alternative of the SLL conflict was found to not be
 *  a truly viable alternative. Two-stage parsing cannot be used for inputs where
 *  this situation occurs.</li>
 *  </ul>
 */
class DiagnosticErrorListener extends ErrorListener_js_1.default {
    constructor(exactOnly) {
        super();
        exactOnly = exactOnly || true;
        // whether all ambiguities or only exact ambiguities are reported.
        this.exactOnly = exactOnly;
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        if (this.exactOnly && !exact) {
            return;
        }
        const msg = "reportAmbiguity d=" +
            this.getDecisionDescription(recognizer, dfa) +
            ": ambigAlts=" +
            this.getConflictingAlts(ambigAlts, configs) +
            ", input='" +
            recognizer.getTokenStream().getText(new Interval_js_1.default(startIndex, stopIndex)) + "'";
        recognizer.notifyErrorListeners(msg);
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
        const msg = "reportAttemptingFullContext d=" +
            this.getDecisionDescription(recognizer, dfa) +
            ", input='" +
            recognizer.getTokenStream().getText(new Interval_js_1.default(startIndex, stopIndex)) + "'";
        recognizer.notifyErrorListeners(msg);
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
        const msg = "reportContextSensitivity d=" +
            this.getDecisionDescription(recognizer, dfa) +
            ", input='" +
            recognizer.getTokenStream().getText(new Interval_js_1.default(startIndex, stopIndex)) + "'";
        recognizer.notifyErrorListeners(msg);
    }
    getDecisionDescription(recognizer, dfa) {
        const decision = dfa.decision;
        const ruleIndex = dfa.atnStartState.ruleIndex;
        const ruleNames = recognizer.ruleNames;
        if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
            return "" + decision;
        }
        const ruleName = ruleNames[ruleIndex] || null;
        if (ruleName === null || ruleName.length === 0) {
            return "" + decision;
        }
        return `${decision} (${ruleName})`;
    }
    /**
     * Computes the set of conflicting or ambiguous alternatives from a
     * configuration set, if that information was not already provided by the
     * parser.
     *
     * @param reportedAlts The set of conflicting or ambiguous alternatives, as
     * reported by the parser.
     * @param configs The conflicting or ambiguous configuration set.
     * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
     * returns the set of alternatives represented in {@code configs}.
     */
    getConflictingAlts(reportedAlts, configs) {
        if (reportedAlts !== null) {
            return reportedAlts;
        }
        const result = new BitSet_js_1.default();
        for (let i = 0; i < configs.items.length; i++) {
            result.add(configs.items[i].alt);
        }
        return `{${result.values().join(", ")}}`;
    }
}
exports["default"] = DiagnosticErrorListener;
//# sourceMappingURL=DiagnosticErrorListener.js.map

/***/ }),

/***/ 5827:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Provides an empty default implementation of {@link ANTLRErrorListener}. The
 * default implementation of each method does nothing, but can be overridden as
 * necessary.
 */
class ErrorListener {
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    }
}
exports["default"] = ErrorListener;
//# sourceMappingURL=ErrorListener.js.map

/***/ }),

/***/ 1080:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
class ErrorStrategy {
    reset(recognizer) {
    }
    recoverInline(recognizer) {
    }
    recover(recognizer, e) {
    }
    sync(recognizer) {
    }
    inErrorRecoveryMode(recognizer) {
    }
    reportError(recognizer) {
    }
}
exports["default"] = ErrorStrategy;
//# sourceMappingURL=ErrorStrategy.js.map

/***/ }),

/***/ 409:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const PredicateTransition_js_1 = __importDefault(__webpack_require__(6614));
const RecognitionException_js_1 = __importDefault(__webpack_require__(5000));
/**
 * A semantic predicate failed during validation. Validation of predicates
 * occurs when normally parsing the alternative just like matching a token.
 * Disambiguating predicate evaluation occurs when we test a predicate during
 * prediction.
 */
class FailedPredicateException extends RecognitionException_js_1.default {
    constructor(recognizer, predicate, message) {
        super({
            message: formatMessage(predicate, message || null), recognizer: recognizer,
            input: recognizer.getInputStream(), ctx: recognizer._ctx
        });
        const s = recognizer._interp.atn.states[recognizer.state];
        const trans = s.transitions[0];
        if (trans instanceof PredicateTransition_js_1.default) {
            this.ruleIndex = trans.ruleIndex;
            this.predicateIndex = trans.predIndex;
        }
        else {
            this.ruleIndex = 0;
            this.predicateIndex = 0;
        }
        this.predicate = predicate;
        this.offendingToken = recognizer.getCurrentToken();
    }
}
exports["default"] = FailedPredicateException;
function formatMessage(predicate, message) {
    if (message !== null) {
        return message;
    }
    else {
        return "failed predicate: {" + predicate + "}?";
    }
}
//# sourceMappingURL=FailedPredicateException.js.map

/***/ }),

/***/ 3067:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const RecognitionException_js_1 = __importDefault(__webpack_require__(5000));
/**
 * This signifies any kind of mismatched input exceptions such as
 * when the current input does not match the expected token.
 */
class InputMismatchException extends RecognitionException_js_1.default {
    constructor(recognizer) {
        super({ message: "", recognizer: recognizer, input: recognizer.getInputStream(), ctx: recognizer._ctx });
        this.offendingToken = recognizer.getCurrentToken();
    }
}
exports["default"] = InputMismatchException;
//# sourceMappingURL=InputMismatchException.js.map

/***/ }),

/***/ 313:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Interval_js_1 = __importDefault(__webpack_require__(4886));
const RecognitionException_js_1 = __importDefault(__webpack_require__(5000));
class LexerNoViableAltException extends RecognitionException_js_1.default {
    constructor(lexer, input, startIndex, deadEndConfigs) {
        super({ message: "", recognizer: lexer, input: input, ctx: null });
        this.startIndex = startIndex;
        this.deadEndConfigs = deadEndConfigs;
    }
    toString() {
        let symbol = "";
        if (this.startIndex >= 0 && this.startIndex < this.input.size) {
            symbol = this.input.getText(new Interval_js_1.default(this.startIndex, this.startIndex));
        }
        return "LexerNoViableAltException" + symbol;
    }
}
exports["default"] = LexerNoViableAltException;
//# sourceMappingURL=LexerNoViableAltException.js.map

/***/ }),

/***/ 1454:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const RecognitionException_js_1 = __importDefault(__webpack_require__(5000));
/**
 * Indicates that the parser could not decide which of two or more paths
 * to take based upon the remaining input. It tracks the starting token
 * of the offending input and also knows where the parser was
 * in the various paths when the error. Reported by reportNoViableAlternative()
 */
class NoViableAltException extends RecognitionException_js_1.default {
    constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
        ctx = ctx || recognizer._ctx;
        offendingToken = offendingToken || recognizer.getCurrentToken();
        startToken = startToken || recognizer.getCurrentToken();
        input = input || recognizer.getInputStream();
        super({ message: "", recognizer: recognizer, input: input, ctx: ctx });
        // Which configurations did we try at input.index() that couldn't match
        // input.LT(1)?//
        this.deadEndConfigs = deadEndConfigs;
        // The token object at the start index; the input stream might
        // not be buffering tokens so get a reference to it. (At the
        // time the error occurred, of course the stream needs to keep a
        // buffer all of the tokens but later we might not have access to those.)
        this.startToken = startToken;
        this.offendingToken = offendingToken;
    }
}
exports["default"] = NoViableAltException;
//# sourceMappingURL=NoViableAltException.js.map

/***/ }),

/***/ 9278:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class ParseCancellationException extends Error {
    constructor() {
        super();
        Error.captureStackTrace(this, ParseCancellationException);
    }
}
exports["default"] = ParseCancellationException;
//# sourceMappingURL=ParseCancellationException.js.map

/***/ }),

/***/ 1163:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ErrorListener_js_1 = __importDefault(__webpack_require__(5827));
class ProxyErrorListener extends ErrorListener_js_1.default {
    constructor(delegates) {
        super();
        if (delegates === null) {
            throw "delegates";
        }
        this.delegates = delegates;
        return this;
    }
    syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
        this.delegates.map(d => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));
    }
    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
        this.delegates.map(d => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));
    }
    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
        this.delegates.map(d => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));
    }
    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
        this.delegates.map(d => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));
    }
}
exports["default"] = ProxyErrorListener;
//# sourceMappingURL=ProxyErrorListener.js.map

/***/ }),

/***/ 5000:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
 *  3 kinds of errors: prediction errors, failed predicate errors, and
 *  mismatched input errors. In each case, the parser knows where it is
 *  in the input, where it is in the ATN, the rule invocation stack,
 *  and what kind of problem occurred.
 */
class RecognitionException extends Error {
    constructor(params) {
        super(params.message);
        if (Error.captureStackTrace)
            Error.captureStackTrace(this, RecognitionException);
        this.message = params.message;
        this.recognizer = params.recognizer;
        this.input = params.input;
        this.ctx = params.ctx;
        /**
         * The current {@link Token} when an error occurred. Since not all streams
         * support accessing symbols by index, we have to track the {@link Token}
         * instance itself
        */
        this.offendingToken = null;
        /**
         * Get the ATN state number the parser was in at the time the error
         * occurred. For {@link NoViableAltException} and
         * {@link LexerNoViableAltException} exceptions, this is the
         * {@link DecisionState} number. For others, it is the state whose outgoing
         * edge we couldn't match.
         */
        this.offendingState = -1;
        if (this.recognizer !== null) {
            this.offendingState = this.recognizer.state;
        }
    }
    /**
     * Gets the set of input symbols which could potentially follow the
     * previously matched symbol at the time this exception was thrown.
     *
     * <p>If the set of expected tokens is not known and could not be computed,
     * this method returns {@code null}.</p>
     *
     * @return The set of token types that could potentially follow the current
     * state in the ATN, or {@code null} if the information is not available.
     */
    getExpectedTokens() {
        if (this.recognizer !== null) {
            return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
        }
        else {
            return null;
        }
    }
    // <p>If the state number is not known, this method returns -1.</p>
    toString() {
        return this.message;
    }
}
exports["default"] = RecognitionException;
//# sourceMappingURL=RecognitionException.js.map

/***/ }),

/***/ 7423:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const RecognitionException_js_1 = __importDefault(__webpack_require__(5000));
const NoViableAltException_js_1 = __importDefault(__webpack_require__(1454));
const LexerNoViableAltException_js_1 = __importDefault(__webpack_require__(313));
const InputMismatchException_js_1 = __importDefault(__webpack_require__(3067));
const FailedPredicateException_js_1 = __importDefault(__webpack_require__(409));
const DiagnosticErrorListener_js_1 = __importDefault(__webpack_require__(1574));
const BailErrorStrategy_js_1 = __importDefault(__webpack_require__(267));
const DefaultErrorStrategy_js_1 = __importDefault(__webpack_require__(838));
const ErrorListener_js_1 = __importDefault(__webpack_require__(5827));
exports["default"] = {
    RecognitionException: RecognitionException_js_1.default, NoViableAltException: NoViableAltException_js_1.default, LexerNoViableAltException: LexerNoViableAltException_js_1.default, InputMismatchException: InputMismatchException_js_1.default, FailedPredicateException: FailedPredicateException_js_1.default,
    DiagnosticErrorListener: DiagnosticErrorListener_js_1.default, BailErrorStrategy: BailErrorStrategy_js_1.default, DefaultErrorStrategy: DefaultErrorStrategy_js_1.default, ErrorListener: ErrorListener_js_1.default
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7228:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
__webpack_require__(1659);
__webpack_require__(5034);
__webpack_require__(2085);
const index_js_1 = __importDefault(__webpack_require__(9548));
const index_js_2 = __importDefault(__webpack_require__(5224));
const index_js_3 = __importDefault(__webpack_require__(1183));
const index_js_4 = __importDefault(__webpack_require__(7423));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const CommonToken_js_1 = __importDefault(__webpack_require__(1368));
const CharStreams_js_1 = __importDefault(__webpack_require__(5689));
const InputStream_js_1 = __importDefault(__webpack_require__(2732));
const FileStream_js_1 = __importDefault(__webpack_require__(654));
const CommonTokenStream_js_1 = __importDefault(__webpack_require__(1259));
const Lexer_js_1 = __importDefault(__webpack_require__(4412));
const Parser_js_1 = __importDefault(__webpack_require__(3709));
const PredictionContextCache_js_1 = __importDefault(__webpack_require__(2534));
const ParserRuleContext_js_1 = __importDefault(__webpack_require__(8535));
const Interval_js_1 = __importDefault(__webpack_require__(4886));
const IntervalSet_js_1 = __importDefault(__webpack_require__(619));
const LL1Analyzer_js_1 = __importDefault(__webpack_require__(2367));
const index_js_5 = __importDefault(__webpack_require__(7912));
const antlr4 = {
    atn: index_js_1.default, dfa: index_js_2.default, tree: index_js_3.default, error: index_js_4.default, Token: Token_js_1.default, CommonToken: CommonToken_js_1.default, CharStreams: CharStreams_js_1.default, InputStream: InputStream_js_1.default, FileStream: FileStream_js_1.default, CommonTokenStream: CommonTokenStream_js_1.default, Lexer: Lexer_js_1.default, Parser: Parser_js_1.default,
    PredictionContextCache: PredictionContextCache_js_1.default, ParserRuleContext: ParserRuleContext_js_1.default, Interval: Interval_js_1.default, IntervalSet: IntervalSet_js_1.default, LL1Analyzer: LL1Analyzer_js_1.default, Utils: index_js_5.default
};
exports["default"] = antlr4;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1387:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class AltDict {
    constructor() {
        this.data = {};
    }
    get(key) {
        return this.data["k-" + key] || null;
    }
    set(key, value) {
        this.data["k-" + key] = value;
    }
    values() {
        return Object.keys(this.data).filter(key => key.startsWith("k-")).map(key => this.data[key], this);
    }
}
exports["default"] = AltDict;
//# sourceMappingURL=AltDict.js.map

/***/ }),

/***/ 7149:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const HashCode_js_1 = __importDefault(__webpack_require__(3052));
const equalArrays_js_1 = __importDefault(__webpack_require__(1267));
class BitSet {
    constructor() {
        this.data = [];
    }
    add(value) {
        this.data[value] = true;
    }
    or(set) {
        Object.keys(set.data).map(alt => this.add(alt), this);
    }
    remove(value) {
        delete this.data[value];
    }
    has(value) {
        return this.data[value] === true;
    }
    values() {
        return Object.keys(this.data);
    }
    minValue() {
        return Math.min.apply(null, this.values());
    }
    hashCode() {
        return HashCode_js_1.default.hashStuff(this.values());
    }
    equals(other) {
        return other instanceof BitSet && (0, equalArrays_js_1.default)(this.data, other.data);
    }
    toString() {
        return "{" + this.values().join(", ") + "}";
    }
    get length() {
        return this.values().length;
    }
}
exports["default"] = BitSet;
//# sourceMappingURL=BitSet.js.map

/***/ }),

/***/ 3052:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class HashCode {
    constructor() {
        this.count = 0;
        this.hash = 0;
    }
    update() {
        for (let i = 0; i < arguments.length; i++) {
            const value = arguments[i];
            if (value == null)
                continue;
            if (Array.isArray(value))
                this.update.apply(this, value);
            else {
                let k = 0;
                switch (typeof (value)) {
                    case 'undefined':
                    case 'function':
                        continue;
                    case 'number':
                    case 'boolean':
                        k = value;
                        break;
                    case 'string':
                        k = value.hashCode();
                        break;
                    default:
                        if (value.updateHashCode)
                            value.updateHashCode(this);
                        else
                            console.log("No updateHashCode for " + value.toString());
                        continue;
                }
                k = k * 0xCC9E2D51;
                k = (k << 15) | (k >>> (32 - 15));
                k = k * 0x1B873593;
                this.count = this.count + 1;
                let hash = this.hash ^ k;
                hash = (hash << 13) | (hash >>> (32 - 13));
                hash = hash * 5 + 0xE6546B64;
                this.hash = hash;
            }
        }
    }
    finish() {
        let hash = this.hash ^ (this.count * 4);
        hash = hash ^ (hash >>> 16);
        hash = hash * 0x85EBCA6B;
        hash = hash ^ (hash >>> 13);
        hash = hash * 0xC2B2AE35;
        hash = hash ^ (hash >>> 16);
        return hash;
    }
    static hashStuff() {
        const hash = new HashCode();
        hash.update.apply(hash, arguments);
        return hash.finish();
    }
}
exports["default"] = HashCode;
//# sourceMappingURL=HashCode.js.map

/***/ }),

/***/ 1935:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const standardEqualsFunction_js_1 = __importDefault(__webpack_require__(7350));
const standardHashCodeFunction_js_1 = __importDefault(__webpack_require__(7152));
const HASH_KEY_PREFIX = "h-";
class HashMap {
    constructor(hashFunction, equalsFunction) {
        this.data = {};
        this.hashFunction = hashFunction || standardHashCodeFunction_js_1.default;
        this.equalsFunction = equalsFunction || standardEqualsFunction_js_1.default;
    }
    set(key, value) {
        const hashKey = HASH_KEY_PREFIX + this.hashFunction(key);
        if (hashKey in this.data) {
            const entries = this.data[hashKey];
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                if (this.equalsFunction(key, entry.key)) {
                    const oldValue = entry.value;
                    entry.value = value;
                    return oldValue;
                }
            }
            entries.push({ key: key, value: value });
            return value;
        }
        else {
            this.data[hashKey] = [{ key: key, value: value }];
            return value;
        }
    }
    containsKey(key) {
        const hashKey = HASH_KEY_PREFIX + this.hashFunction(key);
        if (hashKey in this.data) {
            const entries = this.data[hashKey];
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                if (this.equalsFunction(key, entry.key))
                    return true;
            }
        }
        return false;
    }
    get(key) {
        const hashKey = HASH_KEY_PREFIX + this.hashFunction(key);
        if (hashKey in this.data) {
            const entries = this.data[hashKey];
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                if (this.equalsFunction(key, entry.key))
                    return entry.value;
            }
        }
        return null;
    }
    entries() {
        return Object.keys(this.data).filter(key => key.startsWith(HASH_KEY_PREFIX)).flatMap(key => this.data[key], this);
    }
    getKeys() {
        return this.entries().map(e => e.key);
    }
    getValues() {
        return this.entries().map(e => e.value);
    }
    toString() {
        const ss = this.entries().map(e => '{' + e.key + ':' + e.value + '}');
        return '[' + ss.join(", ") + ']';
    }
    get length() {
        return Object.keys(this.data).filter(key => key.startsWith(HASH_KEY_PREFIX)).map(key => this.data[key].length, this).reduce((accum, item) => accum + item, 0);
    }
}
exports["default"] = HashMap;
//# sourceMappingURL=HashMap.js.map

/***/ }),

/***/ 5563:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const standardHashCodeFunction_js_1 = __importDefault(__webpack_require__(7152));
const standardEqualsFunction_js_1 = __importDefault(__webpack_require__(7350));
const arrayToString_js_1 = __importDefault(__webpack_require__(1324));
const HASH_KEY_PREFIX = "h-";
class HashSet {
    constructor(hashFunction, equalsFunction) {
        this.data = {};
        this.hashFunction = hashFunction || standardHashCodeFunction_js_1.default;
        this.equalsFunction = equalsFunction || standardEqualsFunction_js_1.default;
    }
    add(value) {
        const key = HASH_KEY_PREFIX + this.hashFunction(value);
        if (key in this.data) {
            const values = this.data[key];
            for (let i = 0; i < values.length; i++) {
                if (this.equalsFunction(value, values[i])) {
                    return values[i];
                }
            }
            values.push(value);
            return value;
        }
        else {
            this.data[key] = [value];
            return value;
        }
    }
    has(value) {
        return this.get(value) != null;
    }
    get(value) {
        const key = HASH_KEY_PREFIX + this.hashFunction(value);
        if (key in this.data) {
            const values = this.data[key];
            for (let i = 0; i < values.length; i++) {
                if (this.equalsFunction(value, values[i])) {
                    return values[i];
                }
            }
        }
        return null;
    }
    values() {
        return Object.keys(this.data).filter(key => key.startsWith(HASH_KEY_PREFIX)).flatMap(key => this.data[key], this);
    }
    toString() {
        return (0, arrayToString_js_1.default)(this.values());
    }
    get length() {
        return Object.keys(this.data).filter(key => key.startsWith(HASH_KEY_PREFIX)).map(key => this.data[key].length, this).reduce((accum, item) => accum + item, 0);
    }
}
exports["default"] = HashSet;
//# sourceMappingURL=HashSet.js.map

/***/ }),

/***/ 4886:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/* stop is not included! */
class Interval {
    constructor(start, stop) {
        this.start = start;
        this.stop = stop;
    }
    clone() {
        return new Interval(this.start, this.stop);
    }
    contains(item) {
        return item >= this.start && item < this.stop;
    }
    toString() {
        if (this.start === this.stop - 1) {
            return this.start.toString();
        }
        else {
            return this.start.toString() + ".." + (this.stop - 1).toString();
        }
    }
    get length() {
        return this.stop - this.start;
    }
}
exports["default"] = Interval;
Interval.INVALID_INTERVAL = new Interval(-1, -2);
//# sourceMappingURL=Interval.js.map

/***/ }),

/***/ 619:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const Interval_js_1 = __importDefault(__webpack_require__(4886));
class IntervalSet {
    constructor() {
        this.intervals = null;
        this.readOnly = false;
    }
    first(v) {
        if (this.intervals === null || this.intervals.length === 0) {
            return Token_js_1.default.INVALID_TYPE;
        }
        else {
            return this.intervals[0].start;
        }
    }
    addOne(v) {
        this.addInterval(new Interval_js_1.default(v, v + 1));
    }
    addRange(l, h) {
        this.addInterval(new Interval_js_1.default(l, h + 1));
    }
    addInterval(toAdd) {
        if (this.intervals === null) {
            this.intervals = [];
            this.intervals.push(toAdd.clone());
        }
        else {
            // find insert pos
            for (let pos = 0; pos < this.intervals.length; pos++) {
                const existing = this.intervals[pos];
                // distinct range -> insert
                if (toAdd.stop < existing.start) {
                    this.intervals.splice(pos, 0, toAdd);
                    return;
                }
                // contiguous range -> adjust
                else if (toAdd.stop === existing.start) {
                    this.intervals[pos] = new Interval_js_1.default(toAdd.start, existing.stop);
                    return;
                }
                // overlapping range -> adjust and reduce
                else if (toAdd.start <= existing.stop) {
                    this.intervals[pos] = new Interval_js_1.default(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));
                    this.reduce(pos);
                    return;
                }
            }
            // greater than any existing
            this.intervals.push(toAdd.clone());
        }
    }
    addSet(other) {
        if (other.intervals !== null) {
            other.intervals.forEach(toAdd => this.addInterval(toAdd), this);
        }
        return this;
    }
    reduce(pos) {
        // only need to reduce if pos is not the last
        if (pos < this.intervals.length - 1) {
            const current = this.intervals[pos];
            const next = this.intervals[pos + 1];
            // if next contained in current
            if (current.stop >= next.stop) {
                this.intervals.splice(pos + 1, 1);
                this.reduce(pos);
            }
            else if (current.stop >= next.start) {
                this.intervals[pos] = new Interval_js_1.default(current.start, next.stop);
                this.intervals.splice(pos + 1, 1);
            }
        }
    }
    complement(start, stop) {
        const result = new IntervalSet();
        result.addInterval(new Interval_js_1.default(start, stop + 1));
        if (this.intervals !== null)
            this.intervals.forEach(toRemove => result.removeRange(toRemove));
        return result;
    }
    contains(item) {
        if (this.intervals === null) {
            return false;
        }
        else {
            for (let k = 0; k < this.intervals.length; k++) {
                if (this.intervals[k].contains(item)) {
                    return true;
                }
            }
            return false;
        }
    }
    removeRange(toRemove) {
        if (toRemove.start === toRemove.stop - 1) {
            this.removeOne(toRemove.start);
        }
        else if (this.intervals !== null) {
            let pos = 0;
            for (let n = 0; n < this.intervals.length; n++) {
                const existing = this.intervals[pos];
                // intervals are ordered
                if (toRemove.stop <= existing.start) {
                    return;
                }
                // check for including range, split it
                else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
                    this.intervals[pos] = new Interval_js_1.default(existing.start, toRemove.start);
                    const x = new Interval_js_1.default(toRemove.stop, existing.stop);
                    this.intervals.splice(pos, 0, x);
                    return;
                }
                // check for included range, remove it
                else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
                    this.intervals.splice(pos, 1);
                    pos = pos - 1; // need another pass
                }
                // check for lower boundary
                else if (toRemove.start < existing.stop) {
                    this.intervals[pos] = new Interval_js_1.default(existing.start, toRemove.start);
                }
                // check for upper boundary
                else if (toRemove.stop < existing.stop) {
                    this.intervals[pos] = new Interval_js_1.default(toRemove.stop, existing.stop);
                }
                pos += 1;
            }
        }
    }
    removeOne(value) {
        if (this.intervals !== null) {
            for (let i = 0; i < this.intervals.length; i++) {
                const existing = this.intervals[i];
                // intervals are ordered
                if (value < existing.start) {
                    return;
                }
                // check for single value range
                else if (value === existing.start && value === existing.stop - 1) {
                    this.intervals.splice(i, 1);
                    return;
                }
                // check for lower boundary
                else if (value === existing.start) {
                    this.intervals[i] = new Interval_js_1.default(existing.start + 1, existing.stop);
                    return;
                }
                // check for upper boundary
                else if (value === existing.stop - 1) {
                    this.intervals[i] = new Interval_js_1.default(existing.start, existing.stop - 1);
                    return;
                }
                // split existing range
                else if (value < existing.stop - 1) {
                    const replace = new Interval_js_1.default(existing.start, value);
                    existing.start = value + 1;
                    this.intervals.splice(i, 0, replace);
                    return;
                }
            }
        }
    }
    toString(literalNames, symbolicNames, elemsAreChar) {
        literalNames = literalNames || null;
        symbolicNames = symbolicNames || null;
        elemsAreChar = elemsAreChar || false;
        if (this.intervals === null) {
            return "{}";
        }
        else if (literalNames !== null || symbolicNames !== null) {
            return this.toTokenString(literalNames, symbolicNames);
        }
        else if (elemsAreChar) {
            return this.toCharString();
        }
        else {
            return this.toIndexString();
        }
    }
    toCharString() {
        const names = [];
        for (let i = 0; i < this.intervals.length; i++) {
            const existing = this.intervals[i];
            if (existing.stop === existing.start + 1) {
                if (existing.start === Token_js_1.default.EOF) {
                    names.push("<EOF>");
                }
                else {
                    names.push("'" + String.fromCharCode(existing.start) + "'");
                }
            }
            else {
                names.push("'" + String.fromCharCode(existing.start) + "'..'" + String.fromCharCode(existing.stop - 1) + "'");
            }
        }
        if (names.length > 1) {
            return "{" + names.join(", ") + "}";
        }
        else {
            return names[0];
        }
    }
    toIndexString() {
        const names = [];
        for (let i = 0; i < this.intervals.length; i++) {
            const existing = this.intervals[i];
            if (existing.stop === existing.start + 1) {
                if (existing.start === Token_js_1.default.EOF) {
                    names.push("<EOF>");
                }
                else {
                    names.push(existing.start.toString());
                }
            }
            else {
                names.push(existing.start.toString() + ".." + (existing.stop - 1).toString());
            }
        }
        if (names.length > 1) {
            return "{" + names.join(", ") + "}";
        }
        else {
            return names[0];
        }
    }
    toTokenString(literalNames, symbolicNames) {
        const names = [];
        for (let i = 0; i < this.intervals.length; i++) {
            const existing = this.intervals[i];
            for (let j = existing.start; j < existing.stop; j++) {
                names.push(this.elementName(literalNames, symbolicNames, j));
            }
        }
        if (names.length > 1) {
            return "{" + names.join(", ") + "}";
        }
        else {
            return names[0];
        }
    }
    elementName(literalNames, symbolicNames, token) {
        if (token === Token_js_1.default.EOF) {
            return "<EOF>";
        }
        else if (token === Token_js_1.default.EPSILON) {
            return "<EPSILON>";
        }
        else {
            return literalNames[token] || symbolicNames[token];
        }
    }
    get length() {
        return this.intervals.map(interval => interval.length).reduce((acc, val) => acc + val);
    }
}
exports["default"] = IntervalSet;
//# sourceMappingURL=IntervalSet.js.map

/***/ }),

/***/ 5034:
/***/ (function() {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/*! https://mths.be/codepointat v0.2.0 by @mathias */
if (!String.prototype.codePointAt) {
    (function () {
        'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
        var defineProperty = (function () {
            // IE 8 only supports `Object.defineProperty` on DOM elements
            let result;
            try {
                const object = {};
                const $defineProperty = Object.defineProperty;
                result = $defineProperty(object, object, object) && $defineProperty;
            }
            catch (error) {
                /* eslint no-empty: [ "off" ] */
            }
            return result;
        }());
        const codePointAt = function (position) {
            if (this == null) {
                throw TypeError();
            }
            const string = String(this);
            const size = string.length;
            // `ToInteger`
            let index = position ? Number(position) : 0;
            if (index !== index) { // better `isNaN`
                index = 0;
            }
            // Account for out-of-bounds indices:
            if (index < 0 || index >= size) {
                return undefined;
            }
            // Get the first code unit
            const first = string.charCodeAt(index);
            let second;
            if ( // check if it’s the start of a surrogate pair
            first >= 0xD800 && first <= 0xDBFF && // high surrogate
                size > index + 1 // there is a next code unit
            ) {
                second = string.charCodeAt(index + 1);
                if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                }
            }
            return first;
        };
        if (defineProperty) {
            defineProperty(String.prototype, 'codePointAt', {
                'value': codePointAt,
                'configurable': true,
                'writable': true
            });
        }
        else {
            String.prototype.codePointAt = codePointAt;
        }
    }());
}
//# sourceMappingURL=codepointat.js.map

/***/ }),

/***/ 2085:
/***/ (function() {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
if (!String.fromCodePoint) {
    (function () {
        const defineProperty = (function () {
            // IE 8 only supports `Object.defineProperty` on DOM elements
            let result;
            try {
                const object = {};
                const $defineProperty = Object.defineProperty;
                result = $defineProperty(object, object, object) && $defineProperty;
            }
            catch (error) {
                /* eslint no-empty: [ "off" ] */
            }
            return result;
        }());
        const stringFromCharCode = String.fromCharCode;
        const floor = Math.floor;
        const fromCodePoint = function (_) {
            const MAX_SIZE = 0x4000;
            const codeUnits = [];
            let highSurrogate;
            let lowSurrogate;
            let index = -1;
            const length = arguments.length;
            if (!length) {
                return '';
            }
            let result = '';
            while (++index < length) {
                let codePoint = Number(arguments[index]);
                if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                    codePoint < 0 || // not a valid Unicode code point
                    codePoint > 0x10FFFF || // not a valid Unicode code point
                    floor(codePoint) !== codePoint // not an integer
                ) {
                    throw RangeError('Invalid code point: ' + codePoint);
                }
                if (codePoint <= 0xFFFF) { // BMP code point
                    codeUnits.push(codePoint);
                }
                else { // Astral code point; split in surrogate halves
                    // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    codePoint -= 0x10000;
                    highSurrogate = (codePoint >> 10) + 0xD800;
                    lowSurrogate = (codePoint % 0x400) + 0xDC00;
                    codeUnits.push(highSurrogate, lowSurrogate);
                }
                if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                    result += stringFromCharCode.apply(null, codeUnits);
                    codeUnits.length = 0;
                }
            }
            return result;
        };
        if (defineProperty) {
            defineProperty(String, 'fromCodePoint', {
                'value': fromCodePoint,
                'configurable': true,
                'writable': true
            });
        }
        else {
            String.fromCodePoint = fromCodePoint;
        }
    }());
}
//# sourceMappingURL=fromcodepoint.js.map

/***/ }),

/***/ 8737:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * The following images show the relation of states and
 * {@link ATNState//transitions} for various grammar constructs.
 *
 * <ul>
 *
 * <li>Solid edges marked with an &//0949; indicate a required
 * {@link EpsilonTransition}.</li>
 *
 * <li>Dashed edges indicate locations where any transition derived from
 * {@link Transition} might appear.</li>
 *
 * <li>Dashed nodes are place holders for either a sequence of linked
 * {@link BasicState} states or the inclusion of a block representing a nested
 * construct in one of the forms below.</li>
 *
 * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support
 * any number of alternatives (one or more). Nodes without the {@code ...} only
 * support the exact number of alternatives shown in the diagram.</li>
 *
 * </ul>
 *
 * <h2>Basic Blocks</h2>
 *
 * <h3>Rule</h3>
 *
 * <embed src="images/Rule.svg" type="image/svg+xml"/>
 *
 * <h3>Block of 1 or more alternatives</h3>
 *
 * <embed src="images/Block.svg" type="image/svg+xml"/>
 *
 * <h2>Greedy Loops</h2>
 *
 * <h3>Greedy Closure: {@code (...)*}</h3>
 *
 * <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Positive Closure: {@code (...)+}</h3>
 *
 * <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Optional: {@code (...)?}</h3>
 *
 * <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
 *
 * <h2>Non-Greedy Loops</h2>
 *
 * <h3>Non-Greedy Closure: {@code (...)*?}</h3>
 *
 * <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>
 *
 * <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Optional: {@code (...)??}</h3>
 *
 * <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
 */
class ATNState {
    constructor() {
        // Which ATN are we in?
        this.atn = null;
        this.stateNumber = ATNState.INVALID_STATE_NUMBER;
        this.stateType = null;
        this.ruleIndex = 0; // at runtime, we don't have Rule objects
        this.epsilonOnlyTransitions = false;
        // Track the transitions emanating from this ATN state.
        this.transitions = [];
        // Used to cache lookahead during parsing, not used during construction
        this.nextTokenWithinRule = null;
    }
    toString() {
        return this.stateNumber;
    }
    equals(other) {
        if (other instanceof ATNState) {
            return this.stateNumber === other.stateNumber;
        }
        else {
            return false;
        }
    }
    isNonGreedyExitState() {
        return false;
    }
    addTransition(trans, index) {
        if (index === undefined) {
            index = -1;
        }
        if (this.transitions.length === 0) {
            this.epsilonOnlyTransitions = trans.isEpsilon;
        }
        else if (this.epsilonOnlyTransitions !== trans.isEpsilon) {
            this.epsilonOnlyTransitions = false;
        }
        if (index === -1) {
            this.transitions.push(trans);
        }
        else {
            this.transitions.splice(index, 1, trans);
        }
    }
}
exports["default"] = ATNState;
// constants for serialization
ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;
ATNState.serializationNames = [
    "INVALID",
    "BASIC",
    "RULE_START",
    "BLOCK_START",
    "PLUS_BLOCK_START",
    "STAR_BLOCK_START",
    "TOKEN_START",
    "RULE_STOP",
    "BLOCK_END",
    "STAR_LOOP_BACK",
    "STAR_LOOP_ENTRY",
    "PLUS_LOOP_BACK",
    "LOOP_END"
];
ATNState.INVALID_STATE_NUMBER = -1;
//# sourceMappingURL=ATNState.js.map

/***/ }),

/***/ 5895:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
const BlockStartState_js_1 = __importDefault(__webpack_require__(4762));
class BasicBlockStartState extends BlockStartState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.BLOCK_START;
        return this;
    }
}
exports["default"] = BasicBlockStartState;
//# sourceMappingURL=BasicBlockStartState.js.map

/***/ }),

/***/ 5518:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
class BasicState extends ATNState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.BASIC;
    }
}
exports["default"] = BasicState;
//# sourceMappingURL=BasicState.js.map

/***/ }),

/***/ 7064:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
/**
 * Terminal node of a simple {@code (a|b|c)} block
 */
class BlockEndState extends ATNState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.BLOCK_END;
        this.startState = null;
        return this;
    }
}
exports["default"] = BlockEndState;
//# sourceMappingURL=BlockEndState.js.map

/***/ }),

/***/ 4762:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const DecisionState_js_1 = __importDefault(__webpack_require__(8923));
/**
 *  The start of a regular {@code (...)} block
 */
class BlockStartState extends DecisionState_js_1.default {
    constructor() {
        super();
        this.endState = null;
        return this;
    }
}
exports["default"] = BlockStartState;
//# sourceMappingURL=BlockStartState.js.map

/***/ }),

/***/ 8923:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
class DecisionState extends ATNState_js_1.default {
    constructor() {
        super();
        this.decision = -1;
        this.nonGreedy = false;
        return this;
    }
}
exports["default"] = DecisionState;
//# sourceMappingURL=DecisionState.js.map

/***/ }),

/***/ 4635:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
/**
 * Mark the end of a * or + loop
 */
class LoopEndState extends ATNState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.LOOP_END;
        this.loopBackState = null;
        return this;
    }
}
exports["default"] = LoopEndState;
//# sourceMappingURL=LoopEndState.js.map

/***/ }),

/***/ 4926:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const BlockStartState_js_1 = __importDefault(__webpack_require__(4762));
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
/**
 * Start of {@code (A|B|...)+} loop. Technically a decision state, but
 * we don't use for code generation; somebody might need it, so I'm defining
 * it for completeness. In reality, the {@link PlusLoopbackState} node is the
 * real decision-making note for {@code A+}
 */
class PlusBlockStartState extends BlockStartState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.PLUS_BLOCK_START;
        this.loopBackState = null;
        return this;
    }
}
exports["default"] = PlusBlockStartState;
//# sourceMappingURL=PlusBlockStartState.js.map

/***/ }),

/***/ 335:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const DecisionState_js_1 = __importDefault(__webpack_require__(8923));
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
/**
 * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:
 * one to the loop back to start of the block and one to exit.
 */
class PlusLoopbackState extends DecisionState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.PLUS_LOOP_BACK;
        return this;
    }
}
exports["default"] = PlusLoopbackState;
//# sourceMappingURL=PlusLoopbackState.js.map

/***/ }),

/***/ 2240:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
class RuleStartState extends ATNState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.RULE_START;
        this.stopState = null;
        this.isPrecedenceRule = false;
        return this;
    }
}
exports["default"] = RuleStartState;
//# sourceMappingURL=RuleStartState.js.map

/***/ }),

/***/ 1385:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
/**
 * The last node in the ATN for a rule, unless that rule is the start symbol.
 * In that case, there is one transition to EOF. Later, we might encode
 * references to all calls to this rule to compute FOLLOW sets for
 * error handling
 */
class RuleStopState extends ATNState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.RULE_STOP;
        return this;
    }
}
exports["default"] = RuleStopState;
//# sourceMappingURL=RuleStopState.js.map

/***/ }),

/***/ 8394:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const BlockStartState_js_1 = __importDefault(__webpack_require__(4762));
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
/**
 * The block that begins a closure loop
 */
class StarBlockStartState extends BlockStartState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.STAR_BLOCK_START;
        return this;
    }
}
exports["default"] = StarBlockStartState;
//# sourceMappingURL=StarBlockStartState.js.map

/***/ }),

/***/ 6832:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const DecisionState_js_1 = __importDefault(__webpack_require__(8923));
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
class StarLoopEntryState extends DecisionState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.STAR_LOOP_ENTRY;
        this.loopBackState = null;
        // Indicates whether this state can benefit from a precedence DFA during SLL decision making.
        this.isPrecedenceDecision = null;
        return this;
    }
}
exports["default"] = StarLoopEntryState;
//# sourceMappingURL=StarLoopEntryState.js.map

/***/ }),

/***/ 2184:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
class StarLoopbackState extends ATNState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.STAR_LOOP_BACK;
        return this;
    }
}
exports["default"] = StarLoopbackState;
//# sourceMappingURL=StarLoopbackState.js.map

/***/ }),

/***/ 9705:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const DecisionState_js_1 = __importDefault(__webpack_require__(8923));
const ATNState_js_1 = __importDefault(__webpack_require__(8737));
/**
 * The Tokens rule start state linking to each lexer rule start state
 */
class TokensStartState extends DecisionState_js_1.default {
    constructor() {
        super();
        this.stateType = ATNState_js_1.default.TOKEN_START;
        return this;
    }
}
exports["default"] = TokensStartState;
//# sourceMappingURL=TokensStartState.js.map

/***/ }),

/***/ 1580:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Transition_js_1 = __importDefault(__webpack_require__(738));
class ActionTransition extends Transition_js_1.default {
    constructor(target, ruleIndex, actionIndex, isCtxDependent) {
        super(target);
        this.serializationType = Transition_js_1.default.ACTION;
        this.ruleIndex = ruleIndex;
        this.actionIndex = actionIndex === undefined ? -1 : actionIndex;
        this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
        this.isEpsilon = true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }
    toString() {
        return "action_" + this.ruleIndex + ":" + this.actionIndex;
    }
}
exports["default"] = ActionTransition;
//# sourceMappingURL=ActionTransition.js.map

/***/ }),

/***/ 6696:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const IntervalSet_js_1 = __importDefault(__webpack_require__(619));
const Transition_js_1 = __importDefault(__webpack_require__(738));
class AtomTransition extends Transition_js_1.default {
    constructor(target, label) {
        super(target);
        // The token type or character value; or, signifies special label.
        this.label_ = label;
        this.label = this.makeLabel();
        this.serializationType = Transition_js_1.default.ATOM;
    }
    makeLabel() {
        const s = new IntervalSet_js_1.default();
        s.addOne(this.label_);
        return s;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this.label_ === symbol;
    }
    toString() {
        return this.label_;
    }
}
exports["default"] = AtomTransition;
//# sourceMappingURL=AtomTransition.js.map

/***/ }),

/***/ 6107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Transition_js_1 = __importDefault(__webpack_require__(738));
class EpsilonTransition extends Transition_js_1.default {
    constructor(target, outermostPrecedenceReturn) {
        super(target);
        this.serializationType = Transition_js_1.default.EPSILON;
        this.isEpsilon = true;
        this.outermostPrecedenceReturn = outermostPrecedenceReturn;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }
    toString() {
        return "epsilon";
    }
}
exports["default"] = EpsilonTransition;
//# sourceMappingURL=EpsilonTransition.js.map

/***/ }),

/***/ 5571:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Transition_js_1 = __importDefault(__webpack_require__(738));
const SetTransition_js_1 = __importDefault(__webpack_require__(3823));
class NotSetTransition extends SetTransition_js_1.default {
    constructor(target, set) {
        super(target, set);
        this.serializationType = Transition_js_1.default.NOT_SET;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol &&
            !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
    }
    toString() {
        return '~' + super.toString();
    }
}
exports["default"] = NotSetTransition;
//# sourceMappingURL=NotSetTransition.js.map

/***/ }),

/***/ 7571:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const PrecedencePredicate_js_1 = __importDefault(__webpack_require__(3378));
const Transition_js_1 = __importDefault(__webpack_require__(738));
const AbstractPredicateTransition_js_1 = __importDefault(__webpack_require__(3468));
class PrecedencePredicateTransition extends AbstractPredicateTransition_js_1.default {
    constructor(target, precedence) {
        super(target);
        this.serializationType = Transition_js_1.default.PRECEDENCE;
        this.precedence = precedence;
        this.isEpsilon = true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }
    getPredicate() {
        return new PrecedencePredicate_js_1.default(this.precedence);
    }
    toString() {
        return this.precedence + " >= _p";
    }
}
exports["default"] = PrecedencePredicateTransition;
//# sourceMappingURL=PrecedencePredicateTransition.js.map

/***/ }),

/***/ 6614:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Predicate_js_1 = __importDefault(__webpack_require__(9305));
const Transition_js_1 = __importDefault(__webpack_require__(738));
const AbstractPredicateTransition_js_1 = __importDefault(__webpack_require__(3468));
class PredicateTransition extends AbstractPredicateTransition_js_1.default {
    constructor(target, ruleIndex, predIndex, isCtxDependent) {
        super(target);
        this.serializationType = Transition_js_1.default.PREDICATE;
        this.ruleIndex = ruleIndex;
        this.predIndex = predIndex;
        this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred
        this.isEpsilon = true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }
    getPredicate() {
        return new Predicate_js_1.default(this.ruleIndex, this.predIndex, this.isCtxDependent);
    }
    toString() {
        return "pred_" + this.ruleIndex + ":" + this.predIndex;
    }
}
exports["default"] = PredicateTransition;
//# sourceMappingURL=PredicateTransition.js.map

/***/ }),

/***/ 5719:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const IntervalSet_js_1 = __importDefault(__webpack_require__(619));
const Transition_js_1 = __importDefault(__webpack_require__(738));
class RangeTransition extends Transition_js_1.default {
    constructor(target, start, stop) {
        super(target);
        this.serializationType = Transition_js_1.default.RANGE;
        this.start = start;
        this.stop = stop;
        this.label = this.makeLabel();
    }
    makeLabel() {
        const s = new IntervalSet_js_1.default();
        s.addRange(this.start, this.stop);
        return s;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= this.start && symbol <= this.stop;
    }
    toString() {
        return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
    }
}
exports["default"] = RangeTransition;
//# sourceMappingURL=RangeTransition.js.map

/***/ }),

/***/ 9128:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Transition_js_1 = __importDefault(__webpack_require__(738));
class RuleTransition extends Transition_js_1.default {
    constructor(ruleStart, ruleIndex, precedence, followState) {
        super(ruleStart);
        // ptr to the rule definition object for this rule ref
        this.ruleIndex = ruleIndex;
        this.precedence = precedence;
        // what node to begin computations following ref to rule
        this.followState = followState;
        this.serializationType = Transition_js_1.default.RULE;
        this.isEpsilon = true;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return false;
    }
}
exports["default"] = RuleTransition;
//# sourceMappingURL=RuleTransition.js.map

/***/ }),

/***/ 3823:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
// A transition containing a set of values.
const IntervalSet_js_1 = __importDefault(__webpack_require__(619));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const Transition_js_1 = __importDefault(__webpack_require__(738));
class SetTransition extends Transition_js_1.default {
    constructor(target, set) {
        super(target);
        this.serializationType = Transition_js_1.default.SET;
        if (set !== undefined && set !== null) {
            this.label = set;
        }
        else {
            this.label = new IntervalSet_js_1.default();
            this.label.addOne(Token_js_1.default.INVALID_TYPE);
        }
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return this.label.contains(symbol);
    }
    toString() {
        return this.label.toString();
    }
}
exports["default"] = SetTransition;
//# sourceMappingURL=SetTransition.js.map

/***/ }),

/***/ 738:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * An ATN transition between any two ATN states.  Subclasses define
 * atom, set, epsilon, action, predicate, rule transitions.
 *
 * <p>This is a one way link.  It emanates from a state (usually via a list of
 * transitions) and has a target state.</p>
 *
 * <p>Since we never have to change the ATN transitions once we construct it,
 * we can fix these transitions as specific classes. The DFA transitions
 * on the other hand need to update the labels as it adds transitions to
 * the states. We'll use the term Edge for the DFA to distinguish them from
 * ATN transitions.</p>
 */
class Transition {
    constructor(target) {
        // The target of this transition.
        if (target === undefined || target === null) {
            throw "target cannot be null.";
        }
        this.target = target;
        // Are we epsilon, action, sempred?
        this.isEpsilon = false;
        this.label = null;
    }
}
exports["default"] = Transition;
// constants for serialization
Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3;
// e.g., {isType(input.LT(1))}?
Transition.PREDICATE = 4;
Transition.ATOM = 5;
Transition.ACTION = 6;
// ~(A|B) or ~atom, wildcard, which convert to next 2
Transition.SET = 7;
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;
Transition.serializationNames = [
    "INVALID",
    "EPSILON",
    "RANGE",
    "RULE",
    "PREDICATE",
    "ATOM",
    "ACTION",
    "SET",
    "NOT_SET",
    "WILDCARD",
    "PRECEDENCE"
];
Transition.serializationTypes = {
    EpsilonTransition: Transition.EPSILON,
    RangeTransition: Transition.RANGE,
    RuleTransition: Transition.RULE,
    PredicateTransition: Transition.PREDICATE,
    AtomTransition: Transition.ATOM,
    ActionTransition: Transition.ACTION,
    SetTransition: Transition.SET,
    NotSetTransition: Transition.NOT_SET,
    WildcardTransition: Transition.WILDCARD,
    PrecedencePredicateTransition: Transition.PRECEDENCE
};
//# sourceMappingURL=Transition.js.map

/***/ }),

/***/ 9646:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Transition_js_1 = __importDefault(__webpack_require__(738));
class WildcardTransition extends Transition_js_1.default {
    constructor(target) {
        super(target);
        this.serializationType = Transition_js_1.default.WILDCARD;
    }
    matches(symbol, minVocabSymbol, maxVocabSymbol) {
        return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
    }
    toString() {
        return ".";
    }
}
exports["default"] = WildcardTransition;
//# sourceMappingURL=WildcardTransition.js.map

/***/ }),

/***/ 7747:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const TerminalNode_js_1 = __importDefault(__webpack_require__(7022));
class ErrorNode extends TerminalNode_js_1.default {
}
exports["default"] = ErrorNode;
//# sourceMappingURL=ErrorNode.js.map

/***/ }),

/***/ 2335:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
/**
 * Represents a token that was consumed during resynchronization
 * rather than during a valid match operation. For example,
 * we will create this kind of a node during single token insertion
 * and deletion as well as during "consume until error recovery set"
 * upon no viable alternative exceptions.
 */
const TerminalNodeImpl_js_1 = __importDefault(__webpack_require__(5418));
class ErrorNodeImpl extends TerminalNodeImpl_js_1.default {
    constructor(token) {
        super(token);
    }
    isErrorNode() {
        return true;
    }
    accept(visitor) {
        return visitor.visitErrorNode(this);
    }
}
exports["default"] = ErrorNodeImpl;
//# sourceMappingURL=ErrorNodeImpl.js.map

/***/ }),

/***/ 5126:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const SyntaxTree_js_1 = __importDefault(__webpack_require__(241));
class ParseTree extends SyntaxTree_js_1.default {
}
exports["default"] = ParseTree;
//# sourceMappingURL=ParseTree.js.map

/***/ }),

/***/ 7648:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class ParseTreeListener {
    visitTerminal(node) {
    }
    visitErrorNode(node) {
    }
    enterEveryRule(node) {
    }
    exitEveryRule(node) {
    }
}
exports["default"] = ParseTreeListener;
//# sourceMappingURL=ParseTreeListener.js.map

/***/ }),

/***/ 5992:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class ParseTreeVisitor {
    visit(ctx) {
        if (Array.isArray(ctx)) {
            return ctx.map(function (child) {
                return child.accept(this);
            }, this);
        }
        else {
            return ctx.accept(this);
        }
    }
    visitChildren(ctx) {
        if (ctx.children) {
            return this.visit(ctx.children);
        }
        else {
            return null;
        }
    }
    visitTerminal(node) {
    }
    visitErrorNode(node) {
    }
}
exports["default"] = ParseTreeVisitor;
//# sourceMappingURL=ParseTreeVisitor.js.map

/***/ }),

/***/ 4210:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const TerminalNode_js_1 = __importDefault(__webpack_require__(7022));
const ErrorNode_js_1 = __importDefault(__webpack_require__(7747));
class ParseTreeWalker {
    /**
     * Performs a walk on the given parse tree starting at the root and going down recursively
     * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before
     * recursively walking down into child nodes, then
     * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.
     * @param listener The listener used by the walker to process grammar rules
     * @param t The parse tree to be walked on
     */
    walk(listener, t) {
        const errorNode = t instanceof ErrorNode_js_1.default ||
            (t.isErrorNode !== undefined && t.isErrorNode());
        if (errorNode) {
            listener.visitErrorNode(t);
        }
        else if (t instanceof TerminalNode_js_1.default) {
            listener.visitTerminal(t);
        }
        else {
            this.enterRule(listener, t);
            for (let i = 0; i < t.getChildCount(); i++) {
                const child = t.getChild(i);
                this.walk(listener, child);
            }
            this.exitRule(listener, t);
        }
    }
    /**
     * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}
     * then by triggering the event specific to the given parse tree node
     * @param listener The listener responding to the trigger events
     * @param r The grammar rule containing the rule context
     */
    enterRule(listener, r) {
        const ctx = r.getRuleContext();
        listener.enterEveryRule(ctx);
        ctx.enterRule(listener);
    }
    /**
     * Exits a grammar rule by first triggering the event specific to the given parse tree node
     * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}
     * @param listener The listener responding to the trigger events
     * @param r The grammar rule containing the rule context
     */
    exitRule(listener, r) {
        const ctx = r.getRuleContext();
        ctx.exitRule(listener);
        listener.exitEveryRule(ctx);
    }
}
exports["default"] = ParseTreeWalker;
ParseTreeWalker.DEFAULT = new ParseTreeWalker();
//# sourceMappingURL=ParseTreeWalker.js.map

/***/ }),

/***/ 5004:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ParseTree_js_1 = __importDefault(__webpack_require__(5126));
class RuleNode extends ParseTree_js_1.default {
    getRuleContext() {
        throw new Error("missing interface implementation");
    }
}
exports["default"] = RuleNode;
//# sourceMappingURL=RuleNode.js.map

/***/ }),

/***/ 241:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Tree_js_1 = __importDefault(__webpack_require__(1065));
class SyntaxTree extends Tree_js_1.default {
}
exports["default"] = SyntaxTree;
//# sourceMappingURL=SyntaxTree.js.map

/***/ }),

/***/ 7022:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ParseTree_js_1 = __importDefault(__webpack_require__(5126));
class TerminalNode extends ParseTree_js_1.default {
}
exports["default"] = TerminalNode;
//# sourceMappingURL=TerminalNode.js.map

/***/ }),

/***/ 5418:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Interval_js_1 = __importDefault(__webpack_require__(4886));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const TerminalNode_js_1 = __importDefault(__webpack_require__(7022));
class TerminalNodeImpl extends TerminalNode_js_1.default {
    constructor(symbol) {
        super();
        this.parentCtx = null;
        this.symbol = symbol;
    }
    getChild(i) {
        return null;
    }
    getSymbol() {
        return this.symbol;
    }
    getParent() {
        return this.parentCtx;
    }
    getPayload() {
        return this.symbol;
    }
    getSourceInterval() {
        if (this.symbol === null) {
            return Interval_js_1.default.INVALID_INTERVAL;
        }
        const tokenIndex = this.symbol.tokenIndex;
        return new Interval_js_1.default(tokenIndex, tokenIndex);
    }
    getChildCount() {
        return 0;
    }
    accept(visitor) {
        return visitor.visitTerminal(this);
    }
    getText() {
        return this.symbol.text;
    }
    toString() {
        if (this.symbol.type === Token_js_1.default.EOF) {
            return "<EOF>";
        }
        else {
            return this.symbol.text;
        }
    }
}
exports["default"] = TerminalNodeImpl;
//# sourceMappingURL=TerminalNodeImpl.js.map

/***/ }),

/***/ 1065:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * The basic notion of a tree has a parent, a payload, and a list of children.
 * It is the most abstract interface for all the trees used by ANTLR.
 */
class Tree {
}
exports["default"] = Tree;
//# sourceMappingURL=Tree.js.map

/***/ }),

/***/ 2181:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Token_js_1 = __importDefault(__webpack_require__(5319));
const ErrorNode_js_1 = __importDefault(__webpack_require__(7747));
const TerminalNode_js_1 = __importDefault(__webpack_require__(7022));
const RuleNode_js_1 = __importDefault(__webpack_require__(5004));
const escapeWhitespace_js_1 = __importDefault(__webpack_require__(6101));
/** A set of utility routines useful for all kinds of ANTLR trees. */
const Trees = {
    /**
     * Print out a whole tree in LISP form. {@link //getNodeText} is used on the
     *  node payloads to get the text for the nodes.  Detect
     *  parse trees and extract data appropriately.
     */
    toStringTree: function (tree, ruleNames, recog) {
        ruleNames = ruleNames || null;
        recog = recog || null;
        if (recog !== null) {
            ruleNames = recog.ruleNames;
        }
        let s = Trees.getNodeText(tree, ruleNames);
        s = (0, escapeWhitespace_js_1.default)(s, false);
        const c = tree.getChildCount();
        if (c === 0) {
            return s;
        }
        let res = "(" + s + ' ';
        if (c > 0) {
            s = Trees.toStringTree(tree.getChild(0), ruleNames);
            res = res.concat(s);
        }
        for (let i = 1; i < c; i++) {
            s = Trees.toStringTree(tree.getChild(i), ruleNames);
            res = res.concat(' ' + s);
        }
        res = res.concat(")");
        return res;
    },
    getNodeText: function (t, ruleNames, recog) {
        ruleNames = ruleNames || null;
        recog = recog || null;
        if (recog !== null) {
            ruleNames = recog.ruleNames;
        }
        if (ruleNames !== null) {
            if (t instanceof RuleNode_js_1.default) {
                const context = t.getRuleContext();
                const altNumber = context.getAltNumber();
                // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency
                if (altNumber != 0) {
                    return ruleNames[t.ruleIndex] + ":" + altNumber;
                }
                return ruleNames[t.ruleIndex];
            }
            else if (t instanceof ErrorNode_js_1.default) {
                return t.toString();
            }
            else if (t instanceof TerminalNode_js_1.default) {
                if (t.symbol !== null) {
                    return t.symbol.text;
                }
            }
        }
        // no recog for rule names
        const payload = t.getPayload();
        if (payload instanceof Token_js_1.default) {
            return payload.text;
        }
        return t.getPayload().toString();
    },
    /**
     * Return ordered list of all children of this node
     */
    getChildren: function (t) {
        const list = [];
        for (let i = 0; i < t.getChildCount(); i++) {
            list.push(t.getChild(i));
        }
        return list;
    },
    /**
     * Return a list of all ancestors of this node.  The first node of
     * list is the root and the last is the parent of this node.
     */
    getAncestors: function (t) {
        let ancestors = [];
        t = t.getParent();
        while (t !== null) {
            ancestors = [t].concat(ancestors);
            t = t.getParent();
        }
        return ancestors;
    },
    findAllTokenNodes: function (t, ttype) {
        return Trees.findAllNodes(t, ttype, true);
    },
    findAllRuleNodes: function (t, ruleIndex) {
        return Trees.findAllNodes(t, ruleIndex, false);
    },
    findAllNodes: function (t, index, findTokens) {
        const nodes = [];
        Trees._findAllNodes(t, index, findTokens, nodes);
        return nodes;
    },
    _findAllNodes: function (t, index, findTokens, nodes) {
        // check this node (the root) first
        if (findTokens && (t instanceof TerminalNode_js_1.default)) {
            if (t.symbol.type === index) {
                nodes.push(t);
            }
        }
        else if (!findTokens && (t instanceof RuleNode_js_1.default)) {
            if (t.ruleIndex === index) {
                nodes.push(t);
            }
        }
        // check children
        for (let i = 0; i < t.getChildCount(); i++) {
            Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
        }
    },
    descendants: function (t) {
        let nodes = [t];
        for (let i = 0; i < t.getChildCount(); i++) {
            nodes = nodes.concat(Trees.descendants(t.getChild(i)));
        }
        return nodes;
    }
};
exports["default"] = Trees;
//# sourceMappingURL=Trees.js.map

/***/ }),

/***/ 1183:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const RuleNode_js_1 = __importDefault(__webpack_require__(5004));
const ErrorNode_js_1 = __importDefault(__webpack_require__(7747));
const TerminalNode_js_1 = __importDefault(__webpack_require__(7022));
const ParseTreeListener_js_1 = __importDefault(__webpack_require__(7648));
const ParseTreeVisitor_js_1 = __importDefault(__webpack_require__(5992));
const ParseTreeWalker_js_1 = __importDefault(__webpack_require__(4210));
const Trees_js_1 = __importDefault(__webpack_require__(2181));
exports["default"] = { Trees: Trees_js_1.default, RuleNode: RuleNode_js_1.default, ErrorNode: ErrorNode_js_1.default, TerminalNode: TerminalNode_js_1.default, ParseTreeListener: ParseTreeListener_js_1.default, ParseTreeVisitor: ParseTreeVisitor_js_1.default, ParseTreeWalker: ParseTreeWalker_js_1.default };
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1148:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const HashMap_js_1 = __importDefault(__webpack_require__(1935));
class DoubleDict {
    constructor(defaultMapCtor) {
        this.defaultMapCtor = defaultMapCtor || HashMap_js_1.default;
        this.cacheMap = new this.defaultMapCtor();
    }
    get(a, b) {
        const d = this.cacheMap.get(a) || null;
        return d === null ? null : (d.get(b) || null);
    }
    set(a, b, o) {
        let d = this.cacheMap.get(a) || null;
        if (d === null) {
            d = new this.defaultMapCtor();
            this.cacheMap.set(a, d);
        }
        d.set(b, o);
    }
}
exports["default"] = DoubleDict;
//# sourceMappingURL=DoubleDict.js.map

/***/ }),

/***/ 1324:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const valueToString_js_1 = __importDefault(__webpack_require__(4678));
function arrayToString(a) {
    return Array.isArray(a) ? ("[" + a.map(valueToString_js_1.default).join(", ") + "]") : "null";
}
exports["default"] = arrayToString;
//# sourceMappingURL=arrayToString.js.map

/***/ }),

/***/ 1267:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function equalArrays(a, b) {
    if (!Array.isArray(a) || !Array.isArray(b))
        return false;
    if (a === b)
        return true;
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] === b[i])
            continue;
        if (!a[i].equals || !a[i].equals(b[i]))
            return false;
    }
    return true;
}
exports["default"] = equalArrays;
//# sourceMappingURL=equalArrays.js.map

/***/ }),

/***/ 6101:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function escapeWhitespace(s, escapeSpaces) {
    s = s.replace(/\t/g, "\\t")
        .replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r");
    if (escapeSpaces) {
        s = s.replace(/ /g, "\u00B7");
    }
    return s;
}
exports["default"] = escapeWhitespace;
//# sourceMappingURL=escapeWhitespace.js.map

/***/ }),

/***/ 7912:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const arrayToString_js_1 = __importDefault(__webpack_require__(1324));
exports["default"] = { arrayToString: arrayToString_js_1.default };
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 7350:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function standardEqualsFunction(a, b) {
    return a ? a.equals(b) : a === b;
}
exports["default"] = standardEqualsFunction;
//# sourceMappingURL=standardEqualsFunction.js.map

/***/ }),

/***/ 7152:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function standardHashCodeFunction(a) {
    return a ? a.hashCode() : -1;
}
exports["default"] = standardHashCodeFunction;
//# sourceMappingURL=standardHashCodeFunction.js.map

/***/ }),

/***/ 1659:
/***/ (function() {

"use strict";

/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));
String.prototype.hashCode = function () {
    const key = this.toString();
    let h1b, k1;
    const remainder = key.length & 3; // key.length % 4
    const bytes = key.length - remainder;
    let h1 = String.prototype.seed;
    const c1 = 0xcc9e2d51;
    const c2 = 0x1b873593;
    let i = 0;
    while (i < bytes) {
        k1 =
            ((key.charCodeAt(i) & 0xff)) |
                ((key.charCodeAt(++i) & 0xff) << 8) |
                ((key.charCodeAt(++i) & 0xff) << 16) |
                ((key.charCodeAt(++i) & 0xff) << 24);
        ++i;
        k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
        k1 = (k1 << 15) | (k1 >>> 17);
        k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;
        h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
        h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
        h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
    }
    k1 = 0;
    switch (remainder) {
        case 3:
            k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
        // no-break
        case 2:
            k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
        // no-break
        case 1:
            k1 ^= (key.charCodeAt(i) & 0xff);
            k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
            k1 = (k1 << 15) | (k1 >>> 17);
            k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
            h1 ^= k1;
    }
    h1 ^= key.length;
    h1 ^= h1 >>> 16;
    h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= h1 >>> 13;
    h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
    h1 ^= h1 >>> 16;
    return h1 >>> 0;
};
//# sourceMappingURL=stringHashCode.js.map

/***/ }),

/***/ 4678:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/* Copyright (c) 2012-2022 The ANTLR Project Contributors. All rights reserved.
 * Use is of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function valueToString(v) {
    return v === null ? "null" : v;
}
exports["default"] = valueToString;
//# sourceMappingURL=valueToString.js.map

/***/ }),

/***/ 7645:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = dynamic;
exports.noSSR = noSSR;
var _react = _interopRequireDefault(__webpack_require__(7294));
var _loadable = _interopRequireDefault(__webpack_require__(4588));
function dynamic(dynamicOptions, options) {
    var loadableFn = _loadable.default;
    var loadableOptions = {
        // A loading component is not required, so we default it
        loading: function(param) {
            var error = param.error, isLoading = param.isLoading, pastDelay = param.pastDelay;
            if (!pastDelay) return null;
            if (false) {}
            return null;
        }
    };
    // Support for direct import(), eg: dynamic(import('../hello-world'))
    // Note that this is only kept for the edge case where someone is passing in a promise as first argument
    // The react-loadable babel plugin will turn dynamic(import('../hello-world')) into dynamic(() => import('../hello-world'))
    // To make sure we don't execute the import without rendering first
    if (_instanceof(dynamicOptions, Promise)) {
        loadableOptions.loader = function() {
            return dynamicOptions;
        };
    // Support for having import as a function, eg: dynamic(() => import('../hello-world'))
    } else if (typeof dynamicOptions === "function") {
        loadableOptions.loader = dynamicOptions;
    // Support for having first argument being options, eg: dynamic({loader: import('../hello-world')})
    } else if (typeof dynamicOptions === "object") {
        loadableOptions = _objectSpread({}, loadableOptions, dynamicOptions);
    }
    // Support for passing options, eg: dynamic(import('../hello-world'), {loading: () => <p>Loading something</p>})
    loadableOptions = _objectSpread({}, loadableOptions, options);
    var suspenseOptions = loadableOptions;
    // Error if Fizz rendering is not enabled and `suspense` option is set to true
    if (false) {}
    if (suspenseOptions.suspense) {
        return loadableFn(suspenseOptions);
    }
    // coming from build/babel/plugins/react-loadable-plugin.js
    if (loadableOptions.loadableGenerated) {
        loadableOptions = _objectSpread({}, loadableOptions, loadableOptions.loadableGenerated);
        delete loadableOptions.loadableGenerated;
    }
    // support for disabling server side rendering, eg: dynamic(import('../hello-world'), {ssr: false})
    if (typeof loadableOptions.ssr === "boolean") {
        if (!loadableOptions.ssr) {
            delete loadableOptions.ssr;
            return noSSR(loadableFn, loadableOptions);
        }
        delete loadableOptions.ssr;
    }
    return loadableFn(loadableOptions);
}
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var isServerSide = "object" === "undefined";
function noSSR(LoadableInitializer, loadableOptions) {
    // Removing webpack and modules means react-loadable won't try preloading
    delete loadableOptions.webpack;
    delete loadableOptions.modules;
    // This check is necessary to prevent react-loadable from initializing on the server
    if (!isServerSide) {
        return LoadableInitializer(loadableOptions);
    }
    var Loading = loadableOptions.loading;
    // This will only be rendered on the server side
    return function() {
        return /*#__PURE__*/ _react.default.createElement(Loading, {
            error: null,
            isLoading: true,
            pastDelay: false,
            timedOut: false
        });
    };
}
if (typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) {
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=dynamic.js.map


/***/ }),

/***/ 3644:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LoadableContext = void 0;
var _react = _interopRequireDefault(__webpack_require__(7294));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var LoadableContext = _react.default.createContext(null);
exports.LoadableContext = LoadableContext;
if (false) {} //# sourceMappingURL=loadable-context.js.map


/***/ }),

/***/ 4588:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
        });
    }
    return target;
}
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
var _react = _interopRequireDefault(__webpack_require__(7294));
var _useSubscription = __webpack_require__(2021);
var _loadableContext = __webpack_require__(3644);
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
var ALL_INITIALIZERS = [];
var READY_INITIALIZERS = [];
var initialized = false;
function load(loader) {
    var promise = loader();
    var state = {
        loading: true,
        loaded: null,
        error: null
    };
    state.promise = promise.then(function(loaded) {
        state.loading = false;
        state.loaded = loaded;
        return loaded;
    }).catch(function(err) {
        state.loading = false;
        state.error = err;
        throw err;
    });
    return state;
}
function resolve(obj) {
    return obj && obj.__esModule ? obj.default : obj;
}
function createLoadableComponent(loadFn, options) {
    var init = function init() {
        if (!subscription) {
            var sub = new LoadableSubscription(loadFn, opts);
            subscription = {
                getCurrentValue: sub.getCurrentValue.bind(sub),
                subscribe: sub.subscribe.bind(sub),
                retry: sub.retry.bind(sub),
                promise: sub.promise.bind(sub)
            };
        }
        return subscription.promise();
    };
    var LoadableImpl = function LoadableImpl(props, ref) {
        init();
        var context = _react.default.useContext(_loadableContext.LoadableContext);
        var state = (0, _useSubscription).useSubscription(subscription);
        _react.default.useImperativeHandle(ref, function() {
            return {
                retry: subscription.retry
            };
        }, []);
        if (context && Array.isArray(opts.modules)) {
            opts.modules.forEach(function(moduleName) {
                context(moduleName);
            });
        }
        return _react.default.useMemo(function() {
            if (state.loading || state.error) {
                return _react.default.createElement(opts.loading, {
                    isLoading: state.loading,
                    pastDelay: state.pastDelay,
                    timedOut: state.timedOut,
                    error: state.error,
                    retry: subscription.retry
                });
            } else if (state.loaded) {
                return _react.default.createElement(resolve(state.loaded), props);
            } else {
                return null;
            }
        }, [
            props,
            state
        ]);
    };
    var LazyImpl = function LazyImpl(props, ref) {
        return _react.default.createElement(opts.lazy, _objectSpread({}, props, {
            ref: ref
        }));
    };
    var opts = Object.assign({
        loader: null,
        loading: null,
        delay: 200,
        timeout: null,
        webpack: null,
        modules: null,
        suspense: false
    }, options);
    if (opts.suspense) {
        opts.lazy = _react.default.lazy(opts.loader);
    }
    var subscription = null;
    // Server only
    if (false) {}
    // Client only
    if (!initialized && "object" !== "undefined" && !opts.suspense) {
        // require.resolveWeak check is needed for environments that don't have it available like Jest
        var moduleIds = opts.webpack && "function" === "function" ? opts.webpack() : opts.modules;
        if (moduleIds) {
            READY_INITIALIZERS.push(function(ids) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                try {
                    for(var _iterator = moduleIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                        var moduleId = _step.value;
                        if (ids.indexOf(moduleId) !== -1) {
                            return init();
                        }
                    }
                } catch (err) {
                    _didIteratorError = true;
                    _iteratorError = err;
                } finally{
                    try {
                        if (!_iteratorNormalCompletion && _iterator.return != null) {
                            _iterator.return();
                        }
                    } finally{
                        if (_didIteratorError) {
                            throw _iteratorError;
                        }
                    }
                }
            });
        }
    }
    var LoadableComponent = opts.suspense ? LazyImpl : LoadableImpl;
    LoadableComponent.preload = function() {
        return !opts.suspense && init();
    };
    LoadableComponent.displayName = "LoadableComponent";
    return _react.default.forwardRef(LoadableComponent);
}
var LoadableSubscription = /*#__PURE__*/ function() {
    function LoadableSubscription(loadFn, opts) {
        _classCallCheck(this, LoadableSubscription);
        this._loadFn = loadFn;
        this._opts = opts;
        this._callbacks = new Set();
        this._delay = null;
        this._timeout = null;
        this.retry();
    }
    _createClass(LoadableSubscription, [
        {
            key: "promise",
            value: function promise() {
                return this._res.promise;
            }
        },
        {
            key: "retry",
            value: function retry() {
                var _this = this;
                this._clearTimeouts();
                this._res = this._loadFn(this._opts.loader);
                this._state = {
                    pastDelay: false,
                    timedOut: false
                };
                var ref = this, res = ref._res, opts = ref._opts;
                if (res.loading) {
                    if (typeof opts.delay === "number") {
                        if (opts.delay === 0) {
                            this._state.pastDelay = true;
                        } else {
                            var _this1 = this;
                            this._delay = setTimeout(function() {
                                _this1._update({
                                    pastDelay: true
                                });
                            }, opts.delay);
                        }
                    }
                    if (typeof opts.timeout === "number") {
                        var _this2 = this;
                        this._timeout = setTimeout(function() {
                            _this2._update({
                                timedOut: true
                            });
                        }, opts.timeout);
                    }
                }
                this._res.promise.then(function() {
                    _this._update({});
                    _this._clearTimeouts();
                }).catch(function(_err) {
                    _this._update({});
                    _this._clearTimeouts();
                });
                this._update({});
            }
        },
        {
            key: "_update",
            value: function _update(partial) {
                this._state = _objectSpread({}, this._state, {
                    error: this._res.error,
                    loaded: this._res.loaded,
                    loading: this._res.loading
                }, partial);
                this._callbacks.forEach(function(callback) {
                    return callback();
                });
            }
        },
        {
            key: "_clearTimeouts",
            value: function _clearTimeouts() {
                clearTimeout(this._delay);
                clearTimeout(this._timeout);
            }
        },
        {
            key: "getCurrentValue",
            value: function getCurrentValue() {
                return this._state;
            }
        },
        {
            key: "subscribe",
            value: function subscribe(callback) {
                var _this = this;
                this._callbacks.add(callback);
                return function() {
                    _this._callbacks.delete(callback);
                };
            }
        }
    ]);
    return LoadableSubscription;
}();
function Loadable(opts) {
    return createLoadableComponent(load, opts);
}
function flushInitializers(initializers, ids) {
    var promises = [];
    while(initializers.length){
        var init = initializers.pop();
        promises.push(init(ids));
    }
    return Promise.all(promises).then(function() {
        if (initializers.length) {
            return flushInitializers(initializers, ids);
        }
    });
}
Loadable.preloadAll = function() {
    return new Promise(function(resolveInitializers, reject) {
        flushInitializers(ALL_INITIALIZERS).then(resolveInitializers, reject);
    });
};
Loadable.preloadReady = function() {
    var ids = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return new Promise(function(resolvePreload) {
        var res = function() {
            initialized = true;
            return resolvePreload();
        };
        // We always will resolve, errors should be handled within loading UIs.
        flushInitializers(READY_INITIALIZERS, ids).then(res, res);
    });
};
if (true) {
    window.__NEXT_PRELOADREADY = Loadable.preloadReady;
}
var _default = Loadable;
exports["default"] = _default; //# sourceMappingURL=loadable.js.map


/***/ }),

/***/ 3915:
/***/ (function() {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2021:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var __dirname = "/";
(function(){"use strict";var e={800:function(e){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var r=Object.getOwnPropertySymbols;var t=Object.prototype.hasOwnProperty;var u=Object.prototype.propertyIsEnumerable;function toObject(e){if(e===null||e===undefined){throw new TypeError("Object.assign cannot be called with null or undefined")}return Object(e)}function shouldUseNative(){try{if(!Object.assign){return false}var e=new String("abc");e[5]="de";if(Object.getOwnPropertyNames(e)[0]==="5"){return false}var r={};for(var t=0;t<10;t++){r["_"+String.fromCharCode(t)]=t}var u=Object.getOwnPropertyNames(r).map((function(e){return r[e]}));if(u.join("")!=="0123456789"){return false}var n={};"abcdefghijklmnopqrst".split("").forEach((function(e){n[e]=e}));if(Object.keys(Object.assign({},n)).join("")!=="abcdefghijklmnopqrst"){return false}return true}catch(e){return false}}e.exports=shouldUseNative()?Object.assign:function(e,n){var a;var i=toObject(e);var s;for(var c=1;c<arguments.length;c++){a=Object(arguments[c]);for(var o in a){if(t.call(a,o)){i[o]=a[o]}}if(r){s=r(a);for(var f=0;f<s.length;f++){if(u.call(a,s[f])){i[s[f]]=a[s[f]]}}}}return i}},569:function(e,r,t){
/** @license React vundefined
 * use-subscription.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
if(false){}},403:function(e,r,t){
/** @license React vundefined
 * use-subscription.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var u=t(800),n=t(522);r.useSubscription=function(e){var r=e.getCurrentValue,t=e.subscribe,a=n.useState((function(){return{getCurrentValue:r,subscribe:t,value:r()}}));e=a[0];var i=a[1];a=e.value;if(e.getCurrentValue!==r||e.subscribe!==t)a=r(),i({getCurrentValue:r,subscribe:t,value:a});n.useDebugValue(a);n.useEffect((function(){function b(){if(!e){var n=r();i((function(e){return e.getCurrentValue!==r||e.subscribe!==t||e.value===n?e:u({},e,{value:n})}))}}var e=!1,n=t(b);b();return function(){e=!0;n()}}),[r,t]);return a}},138:function(e,r,t){if(true){e.exports=t(403)}else{}},522:function(e){e.exports=__webpack_require__(7294)}};var r={};function __nccwpck_require__(t){var u=r[t];if(u!==undefined){return u.exports}var n=r[t]={exports:{}};var a=true;try{e[t](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return n.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var t=__nccwpck_require__(138);module.exports=t})();

/***/ }),

/***/ 5152:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(7645)


/***/ }),

/***/ 9008:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__(3121)


/***/ }),

/***/ 7412:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractConverter = void 0;
class AbstractConverter {
    getConverter(key) {
        return null;
    }
    visit(path, input) {
        if (path.length <= 0)
            return {};
        const key = path[path.length - 1];
        const converter = this.getConverter(key);
        if (!converter)
            return {};
        return converter(this, path, input);
    }
    visitObject(path, input) {
        let result = {};
        for (let key of Object.keys(input)) {
            path.push(key);
            const element = input[key];
            if (Array.isArray(element)) {
                const converter = this.getConverter(key);
                if (converter) {
                    result = {
                        ...result,
                        ...converter(this, path, element),
                    };
                }
                else {
                    result = {
                        ...result,
                        ...this.visitArray(path, element),
                    };
                }
            }
            path.pop();
        }
        return result;
    }
    visitArray(path, input) {
        if (path.length < 1)
            return {};
        const key = path[path.length - 1];
        const result = [];
        for (let element of input) {
            if (typeof element === "string") {
                result.push(element);
            }
            else if (typeof element === 'object') {
                result.push(this.visitObject(path, element));
            }
        }
        const obj = {};
        obj[key] = result;
        return obj;
    }
}
exports.AbstractConverter = AbstractConverter;
//# sourceMappingURL=AbstractConverter.js.map

/***/ }),

/***/ 2683:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SwiftKotlinConverter = void 0;
const AbstractConverter_1 = __webpack_require__(7412);
const declaration_1 = __webpack_require__(5649);
const structDeclaration_1 = __webpack_require__(7475);
const statements_1 = __webpack_require__(9740);
const topLevelDeclaration_1 = __webpack_require__(1500);
const functionDeclaration_1 = __webpack_require__(1403);
class SwiftKotlinConverter extends AbstractConverter_1.AbstractConverter {
    swiftTable = {
        'top_level': this.convert_topLevel__kotlinFile,
        'struct_declaration': this.convert_structDeclaration__objectDeclaration,
        'statement': this.convert_statement__topLevelObject,
        'declaration': this.convert_declaration__declaration,
    };
    _kotlinTable = {};
    constructor(convertTable) {
        super();
        if (convertTable) {
            this.swiftTable = {
                ...this.swiftTable,
                ...convertTable,
            };
        }
    }
    get kotlinTable() {
        return this._kotlinTable;
    }
    set kotlinTable(table) {
        this._kotlinTable = table;
    }
    getConverter(key) {
        if (key in this.swiftTable)
            return this.swiftTable[key];
        return super.getConverter(key);
    }
    convert_topLevel__kotlinFile(self, path, input) {
        return (0, topLevelDeclaration_1.convert_topLevel__kotlinFile)(self, path, input);
    }
    convert___packageHeader(self, path, input) {
        return (0, topLevelDeclaration_1.convert___packageHeader)(self, path, input);
    }
    convert__importList(self, path, input) {
        return (0, topLevelDeclaration_1.convert__importList)(self, path, input);
    }
    convert_statements__importList(self, path, input) {
        return (0, statements_1.convert_statements__importList)(self, path, input);
    }
    convert_statements__topLevelObjectList(self, path, input) {
        return (0, statements_1.convert_statements__topLevelObjectList)(self, path, input);
    }
    convert_statement__topLevelObject(self, path, input) {
        return (0, statements_1.convert_statement__topLevelObject)(self, path, input);
    }
    convert_declaration__declaration(self, path, input) {
        return (0, declaration_1.convert_declaration__declaration)(self, path, input);
    }
    convert_structDeclaration__objectDeclaration(self, path, input) {
        return (0, structDeclaration_1.convert_structDeclaration__objectDeclaration)(self, path, input);
    }
    convert_functionDeclaration__functionDeclaration(self, path, input) {
        return (0, functionDeclaration_1.convert_functionDeclaration__functionDeclaration)(self, path, input);
    }
}
exports.SwiftKotlinConverter = SwiftKotlinConverter;
//# sourceMappingURL=SwiftKotlinConverter.js.map

/***/ }),

/***/ 5649:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convert_declaration__declaration = void 0;
const TreeWalk_1 = __webpack_require__(2648);
function convert_declaration__declaration(self, path, input) {
    const array = input.flatMap(x => {
        const [key, elements] = TreeWalk_1.TreeWalk.firstKeyValueOrNull(x);
        if (TreeWalk_1.TreeWalk.isEmptyArray(elements))
            return [];
        switch (key) {
            case 'struct_declaration': {
                const result = self.convert_structDeclaration__objectDeclaration(self, [...path, 'struct_declaration'], elements);
                if (TreeWalk_1.TreeWalk.isEmptyObject(result))
                    return [];
                return [result];
            }
            case 'function_declaration': {
                const result = self.convert_functionDeclaration__functionDeclaration(self, [...path, 'function_declaration'], elements);
                if (TreeWalk_1.TreeWalk.isEmptyObject(result))
                    return [];
                return [result];
            }
            default: {
                return [];
            }
        }
    });
    if (TreeWalk_1.TreeWalk.isEmptyArray(array))
        return {};
    return {
        declaration: array
    };
}
exports.convert_declaration__declaration = convert_declaration__declaration;
//# sourceMappingURL=declaration.js.map

/***/ }),

/***/ 1403:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convert_functionBody__functionBody = exports.convert_functionResult__type = exports.convert_parameter__functionValueParameter = exports.convert_parameterClause__functionValueParameters = exports.convert_functionDeclaration__functionDeclaration = void 0;
const identifier_1 = __webpack_require__(1825);
const TreeWalk_1 = __webpack_require__(2648);
const parameter_1 = __webpack_require__(1903);
const join_1 = __webpack_require__(3063);
const type_1 = __webpack_require__(5393);
function convert_functionDeclaration__functionDeclaration(self, path, input) {
    const _name = TreeWalk_1.TreeWalk.firstElementOrNullByKeys(["function_name", "identifier"], input);
    const _parameterClause = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['function_signature', 'parameter_clause'], input);
    const _functionResult = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['function_signature', 'function_result'], input);
    const functionValueParameters = _parameterClause ? convert_parameterClause__functionValueParameters(self, [...path, 'function_signature', 'parameter_clause'], _parameterClause) : {};
    const functionBody = convert_functionBody__functionBody(self, path, input);
    const functionResultType = _functionResult ? convert_functionResult__type(self, [...path, 'function_signature', 'function_result'], _functionResult) : {};
    return {
        "functionDeclaration": [
            "fun",
            (0, identifier_1.createSimpleIdentifier)(_name ?? ''),
            functionValueParameters,
            ...(TreeWalk_1.TreeWalk.isEmptyObject(functionResultType) ? [] : [':', functionResultType]),
            functionBody,
        ]
    };
}
exports.convert_functionDeclaration__functionDeclaration = convert_functionDeclaration__functionDeclaration;
function convert_parameterClause__functionValueParameters(self, path, input) {
    const parameters = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['parameter_list'], input);
    if (!parameters)
        return {
            "functionValueParameters": [
                "(",
                ")"
            ]
        };
    const functionValueParameterList = parameters.flatMap((x) => {
        const element = TreeWalk_1.TreeWalk.getArrayOrNull('parameter', x);
        if (element)
            return [convert_parameter__functionValueParameter(self, [...path, 'parameter_list', 'parameter'], element)];
        return [];
    });
    const functionValueParameterListWithComma = (0, join_1.joinObjectsWithComma)(functionValueParameterList);
    return {
        "functionValueParameters": [
            "(",
            ...functionValueParameterListWithComma,
            ")"
        ]
    };
}
exports.convert_parameterClause__functionValueParameters = convert_parameterClause__functionValueParameters;
function convert_parameter__functionValueParameter(self, path, input) {
    return {
        "functionValueParameter": [
            (0, parameter_1.convert_parameter_parameter)(self, path, input),
        ]
    };
}
exports.convert_parameter__functionValueParameter = convert_parameter__functionValueParameter;
function convert_functionResult__type(self, path, input) {
    const type = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['type'], input);
    if (!type)
        return {};
    return (0, type_1.convert_type__type_)(self, [...path, 'type'], type);
}
exports.convert_functionResult__type = convert_functionResult__type;
function convert_functionBody__functionBody(self, path, input) {
    return {
        "functionBody": [
            {
                "block": [
                    "{",
                    "",
                    {
                        "statements": []
                    },
                    "}"
                ]
            }
        ]
    };
}
exports.convert_functionBody__functionBody = convert_functionBody__functionBody;
//# sourceMappingURL=functionDeclaration.js.map

/***/ }),

/***/ 1903:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convert_parameter_parameter = void 0;
const TreeWalk_1 = __webpack_require__(2648);
const type_1 = __webpack_require__(5393);
const identifier_1 = __webpack_require__(1825);
function convert_parameter_parameter(self, path, input) {
    const name = TreeWalk_1.TreeWalk.firstElementOrNullByKeys(['local_parameter_name', 'identifier'], input) ?? '__UNDEFINED__';
    const type = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['type_annotation', 'type'], input) ?? [];
    return {
        "parameter": [
            (0, identifier_1.createSimpleIdentifier)(name),
            ":",
            (0, type_1.convert_type__type_)(self, [...path, 'type_annotation', 'type'], type),
        ]
    };
}
exports.convert_parameter_parameter = convert_parameter_parameter;
//# sourceMappingURL=parameter.js.map

/***/ }),

/***/ 7475:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convert_structMember__classMemberDeclaration = exports.convert_structMembers__classMemberDeclarations = exports.convert_structBody__classBody = exports.convert_structDeclaration__objectDeclaration = void 0;
const TreeWalk_1 = __webpack_require__(2648);
function convert_structDeclaration__objectDeclaration(self, path, input) {
    const matched = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['struct_name', 'identifier'], input);
    const name = matched ? matched[0] : '';
    const structBody = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['struct_body'], input);
    return {
        objectDeclaration: [
            'object',
            { simpleIdentifier: [name] },
            ...(structBody ? [convert_structBody__classBody(self, [...path, 'struct_body'], structBody)] : []),
        ]
    };
}
exports.convert_structDeclaration__objectDeclaration = convert_structDeclaration__objectDeclaration;
function convert_structBody__classBody(self, path, input) {
    // convert to struct member
    const structMembers = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['struct_members'], input);
    return {
        classBody: [
            '{',
            ...(structMembers
                ? [convert_structMembers__classMemberDeclarations(self, [...path, 'struct_members'], structMembers)]
                : []),
            '}'
        ]
    };
}
exports.convert_structBody__classBody = convert_structBody__classBody;
function convert_structMembers__classMemberDeclarations(self, path, input) {
    const classMemberDeclarations = input.flatMap((x) => {
        const array = TreeWalk_1.TreeWalk.getArrayOrNull('struct_member', x);
        if (array)
            return [convert_structMember__classMemberDeclaration(self, [...path, 'struct_member'], array)];
        return [];
    });
    return {
        classMemberDeclarations: [
            ...classMemberDeclarations,
        ],
    };
}
exports.convert_structMembers__classMemberDeclarations = convert_structMembers__classMemberDeclarations;
function convert_structMember__classMemberDeclaration(self, path, input) {
    const declarations = input.flatMap((x) => {
        const array = TreeWalk_1.TreeWalk.getArrayOrNull('declaration', x);
        if (array)
            return [self.visit([...path, 'declaration'], array)];
        return [];
    });
    return {
        classMemberDeclaration: [
            ...declarations,
        ]
    };
}
exports.convert_structMember__classMemberDeclaration = convert_structMember__classMemberDeclaration;
//# sourceMappingURL=structDeclaration.js.map

/***/ }),

/***/ 1500:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convert__importList = exports.convert___packageHeader = exports.convert_topLevel__kotlinFile = void 0;
const TreeWalk_1 = __webpack_require__(2648);
const identifier_1 = __webpack_require__(1825);
function convert_topLevel__kotlinFile(self, path, input) {
    // package
    const results = [];
    results.push(self.convert___packageHeader(self, path, input));
    const statements = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['statements'], input);
    if (statements) {
        // imports
        const kotlinImportList = self.convert_statements__importList(self, [...path, 'statements'], statements);
        if (Object.keys(kotlinImportList).length > 0) {
            results.push(kotlinImportList);
        }
        // topLevelObjects
        const topLevelObjects = self.convert_statements__topLevelObjectList(self, [...path, 'statements'], statements);
        results.push(...topLevelObjects);
    }
    return {
        kotlinFile: results,
    };
}
exports.convert_topLevel__kotlinFile = convert_topLevel__kotlinFile;
function convert___packageHeader(self, path, input) {
    return {
        packageHeader: [
            'package',
            (0, identifier_1.createIdentifier)(self.kotlinTable['package']),
        ]
    };
}
exports.convert___packageHeader = convert___packageHeader;
function convert__importList(self, path, input) {
    const importList = self.kotlinTable['importList'];
    if (importList) {
        const imports = importList.map(x => ({ importHeader: ['import', (0, identifier_1.createIdentifier)(x)] }));
        return { importList: imports };
    }
    return {};
}
exports.convert__importList = convert__importList;
//# sourceMappingURL=topLevelDeclaration.js.map

/***/ }),

/***/ 9740:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convert_statement__topLevelObject = exports.convert_statements__topLevelObjectList = exports.convert_statements__importList = void 0;
const TreeWalk_1 = __webpack_require__(2648);
function convert_statements__importList(self, path, input) {
    const importDeclaration = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['statement', 'declaration', 'import_declaration'], input);
    if (importDeclaration) {
        return self.convert__importList(self, [
            ...path, 'statement', 'declaration', 'import_declaration'
        ], importDeclaration);
    }
    else {
        return self.convert__importList(self, path, input);
    }
}
exports.convert_statements__importList = convert_statements__importList;
function convert_statements__topLevelObjectList(self, path, input) {
    return input.flatMap(x => {
        const statement = TreeWalk_1.TreeWalk.getArrayOrNull('statement', x);
        if (!statement)
            return [];
        const result = self.convert_statement__topLevelObject(self, [...path, 'statement'], statement);
        if (TreeWalk_1.TreeWalk.isEmptyObject(result))
            return [];
        return [result];
    });
}
exports.convert_statements__topLevelObjectList = convert_statements__topLevelObjectList;
function convert_statement__topLevelObject(self, path, input) {
    const declaration = TreeWalk_1.TreeWalk.firstArrayOrNullByKeys(['declaration'], input);
    if (!declaration)
        return {};
    const result = self.convert_declaration__declaration(self, [...path, 'declaration'], declaration);
    if (TreeWalk_1.TreeWalk.isEmptyObject(result))
        return {};
    return {
        topLevelObject: [
            result
        ]
    };
}
exports.convert_statement__topLevelObject = convert_statement__topLevelObject;
//# sourceMappingURL=statements.js.map

/***/ }),

/***/ 5393:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convert_arrayType__type_ = exports.convert_protocolCompositionType__type_ = exports.convert_type__type_ = void 0;
const TreeWalk_1 = __webpack_require__(2648);
const type_1 = __webpack_require__(2507);
function convert_type__type_(self, path, input) {
    if (input.length < 0)
        return {};
    const [key, elements] = TreeWalk_1.TreeWalk.firstKeyValueOrNull(input[0]);
    switch (key) {
        case 'array_type': {
            return convert_arrayType__type_(self, [...path, 'array_type'], elements);
        }
        // normal type
        case 'protocol_composition_type': {
            return convert_protocolCompositionType__type_(self, [...path, 'protocol_composition_type'], elements);
        }
        default: {
            return {};
        }
    }
}
exports.convert_type__type_ = convert_type__type_;
function convert_protocolCompositionType__type_(self, path, input) {
    const name = TreeWalk_1.TreeWalk.firstElementOrNullByKeys(['type_identifier', 'type_name', 'identifier'], input);
    return (0, type_1.createPlainUserType)(name ?? '__UNDEFINED__');
}
exports.convert_protocolCompositionType__type_ = convert_protocolCompositionType__type_;
function convert_arrayType__type_(self, path, input) {
    const name = TreeWalk_1.TreeWalk.firstElementOrNullByKeys(['type', 'protocol_composition_type', 'type_identifier', 'type_name', 'identifier'], input);
    return (0, type_1.createGenericUserType)('List', (0, type_1.createPlainUserType)(name ?? ''));
}
exports.convert_arrayType__type_ = convert_arrayType__type_;
//# sourceMappingURL=type.js.map

/***/ }),

/***/ 1825:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createSimpleIdentifier = exports.createIdentifier = void 0;
function createIdentifier(name) {
    const simpleIdentifiers = name.split('.').map(x => ({ simpleIdentifier: [x] }));
    const identifiers = [];
    for (let i = 0; i < simpleIdentifiers.length; i++) {
        identifiers.push(simpleIdentifiers[i]);
        if (i < simpleIdentifiers.length - 1) {
            identifiers.push('.');
        }
    }
    return {
        identifier: identifiers,
    };
}
exports.createIdentifier = createIdentifier;
function createSimpleIdentifier(name) {
    return {
        "simpleIdentifier": [
            name,
        ],
    };
}
exports.createSimpleIdentifier = createSimpleIdentifier;
//# sourceMappingURL=identifier.js.map

/***/ }),

/***/ 3063:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinObjectsWithComma = void 0;
function joinObjectsWithComma(objs) {
    if (objs.length < 1)
        return [];
    if (objs.length === 1)
        return objs;
    const results = [objs[0]];
    for (let i = 1; i < objs.length; i++) {
        results.push(",");
        results.push(objs[i]);
    }
    return results;
}
exports.joinObjectsWithComma = joinObjectsWithComma;
//# sourceMappingURL=join.js.map

/***/ }),

/***/ 2507:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGenericUserType = exports.createPlainUserType = void 0;
const identifier_1 = __webpack_require__(1825);
const __typeConvertTable = {
    "Bool": "Boolean",
};
function createPlainUserType(name) {
    const convertedName = __typeConvertTable[name] ?? name;
    return {
        "type_": [
            {
                "typeReference": [
                    {
                        "userType": [
                            {
                                "simpleUserType": [
                                    (0, identifier_1.createSimpleIdentifier)(convertedName),
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    };
}
exports.createPlainUserType = createPlainUserType;
function createGenericUserType(genericName, innerType) {
    return {
        "type_": [
            {
                "typeReference": [
                    {
                        "userType": [
                            {
                                "simpleUserType": [
                                    {
                                        "simpleIdentifier": [
                                            genericName,
                                        ]
                                    },
                                    {
                                        "typeArguments": [
                                            "<",
                                            {
                                                "typeProjection": [
                                                    innerType,
                                                ]
                                            },
                                            ">"
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    };
}
exports.createGenericUserType = createGenericUserType;
//# sourceMappingURL=type.js.map

/***/ }),

/***/ 7164:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Generated from ANTLRv4Parser.g4 by ANTLR 4.10.1
// jshint ignore: start
const antlr4_1 = __importDefault(__webpack_require__(7228));
// This class defines a complete generic visitor for a parse tree produced by ANTLRv4Parser.
class ANTLRv4ParserVisitor extends antlr4_1.default.tree.ParseTreeVisitor {
    // Visit a parse tree produced by ANTLRv4Parser#grammarSpec.
    visitGrammarSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#grammarDecl.
    visitGrammarDecl(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#grammarType.
    visitGrammarType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#prequelConstruct.
    visitPrequelConstruct(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#optionsSpec.
    visitOptionsSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#option.
    visitOption(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#optionValue.
    visitOptionValue(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#delegateGrammars.
    visitDelegateGrammars(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#delegateGrammar.
    visitDelegateGrammar(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#tokensSpec.
    visitTokensSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#channelsSpec.
    visitChannelsSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#idList.
    visitIdList(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#action_.
    visitAction_(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#actionScopeName.
    visitActionScopeName(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#actionBlock.
    visitActionBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#argActionBlock.
    visitArgActionBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#modeSpec.
    visitModeSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#rules.
    visitRules(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ruleSpec.
    visitRuleSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#parserRuleSpec.
    visitParserRuleSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#exceptionGroup.
    visitExceptionGroup(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#exceptionHandler.
    visitExceptionHandler(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#finallyClause.
    visitFinallyClause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#rulePrequel.
    visitRulePrequel(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ruleReturns.
    visitRuleReturns(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#throwsSpec.
    visitThrowsSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#localsSpec.
    visitLocalsSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ruleAction.
    visitRuleAction(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ruleModifiers.
    visitRuleModifiers(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ruleModifier.
    visitRuleModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ruleBlock.
    visitRuleBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ruleAltList.
    visitRuleAltList(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#labeledAlt.
    visitLabeledAlt(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerRuleSpec.
    visitLexerRuleSpec(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerRuleBlock.
    visitLexerRuleBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerAltList.
    visitLexerAltList(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerAlt.
    visitLexerAlt(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerElements.
    visitLexerElements(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerElement.
    visitLexerElement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#labeledLexerElement.
    visitLabeledLexerElement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerBlock.
    visitLexerBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerCommands.
    visitLexerCommands(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerCommand.
    visitLexerCommand(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerCommandName.
    visitLexerCommandName(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerCommandExpr.
    visitLexerCommandExpr(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#altList.
    visitAltList(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#alternative.
    visitAlternative(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#element.
    visitElement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#labeledElement.
    visitLabeledElement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ebnf.
    visitEbnf(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#blockSuffix.
    visitBlockSuffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ebnfSuffix.
    visitEbnfSuffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#lexerAtom.
    visitLexerAtom(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#atom.
    visitAtom(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#notSet.
    visitNotSet(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#blockSet.
    visitBlockSet(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#setElement.
    visitSetElement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#block.
    visitBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#ruleref.
    visitRuleref(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#characterRange.
    visitCharacterRange(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#terminal.
    visitTerminal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#elementOptions.
    visitElementOptions(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#elementOption.
    visitElementOption(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by ANTLRv4Parser#identifier.
    visitIdentifier(ctx) {
        return this.visitChildren(ctx);
    }
}
exports["default"] = ANTLRv4ParserVisitor;
//# sourceMappingURL=ANTLRv4ParserVisitor.js.map

/***/ }),

/***/ 7328:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Generated from KotlinLexer.g4 by ANTLR 4.10.1
// jshint ignore: start
const antlr4_1 = __importDefault(__webpack_require__(7228));
const serializedATN = [4, 0, 169, 2196, 6, -1, 6, -1, 6, -1, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1,
    2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10,
    2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2,
    18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25,
    7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7,
    32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39,
    2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
    47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54,
    7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7,
    61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68,
    2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2,
    76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83,
    7, 83, 2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7,
    90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97,
    2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 104,
    7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108, 2, 109, 7, 109, 2, 110,
    7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116,
    7, 116, 2, 117, 7, 117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 122,
    7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 126, 2, 127, 7, 127, 2, 128,
    7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134,
    7, 134, 2, 135, 7, 135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 140,
    7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 144, 2, 145, 7, 145, 2, 146,
    7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152,
    7, 152, 2, 153, 7, 153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2, 158,
    7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 162, 2, 163, 7, 163, 2, 164,
    7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170,
    7, 170, 2, 171, 7, 171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2, 176,
    7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 180, 2, 181, 7, 181, 2, 182,
    7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188,
    7, 188, 2, 189, 7, 189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2, 194,
    7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 198, 2, 199, 7, 199, 2, 200,
    7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206,
    7, 206, 2, 207, 7, 207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2, 212,
    7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 216, 2, 217, 7, 217, 2, 218,
    7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224,
    7, 224, 2, 225, 7, 225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2, 230,
    7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7, 234, 2, 235, 7, 235, 2, 236,
    7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2, 239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242,
    7, 242, 2, 243, 7, 243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2, 248,
    7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7, 252, 2, 253, 7, 253, 2, 254,
    7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2, 257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260,
    7, 260, 2, 261, 7, 261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2, 266,
    7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7, 270, 2, 271, 7, 271, 2, 272,
    7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2, 275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278,
    7, 278, 2, 279, 7, 279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2, 284,
    7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7, 288, 2, 289, 7, 289, 2, 290,
    7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2, 293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296,
    7, 296, 2, 297, 7, 297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2, 302,
    7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7, 306, 2, 307, 7, 307, 1, 0, 1,
    0, 1, 0, 1, 0, 5, 0, 625, 8, 0, 10, 0, 12, 0, 628, 9, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 635, 8, 1,
    10, 1, 12, 1, 638, 9, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 5, 2, 649, 8, 2, 10, 2, 12,
    2, 652, 9, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 3, 4, 663, 8, 4, 3, 4, 665, 8, 4, 1,
    5, 1, 5, 1, 5, 3, 5, 670, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1,
    10, 1, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13,
    1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 19, 1,
    19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24,
    1, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1,
    30, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35,
    1, 35, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 40, 1, 40, 1,
    41, 1, 41, 1, 41, 3, 41, 774, 8, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45,
    1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 50, 1,
    50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54,
    1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1,
    55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 57,
    1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1,
    58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
    1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
    62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
    1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1,
    67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68,
    1, 68, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1,
    71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
    1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
    76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79,
    1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1,
    81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84,
    1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1,
    87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89,
    1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3,
    92, 1060, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1068, 8, 93, 1, 94, 1, 94, 1, 94,
    1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1,
    97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99,
    1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1,
    101, 1, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1,
    103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1,
    104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1,
    106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1,
    107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1,
    108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 110, 1,
    110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1,
    111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1,
    113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1,
    115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
    116, 1, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 118, 1,
    118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1,
    120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121, 1,
    121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1,
    122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 124, 1,
    124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 126, 1, 126, 1,
    126, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1,
    127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1,
    129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1,
    130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1,
    131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1,
    133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1,
    135, 1, 136, 1, 136, 3, 136, 1381, 8, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 3, 137,
    1389, 8, 137, 1, 138, 1, 138, 3, 138, 1393, 8, 138, 1, 139, 1, 139, 5, 139, 1397, 8, 139, 10,
    139, 12, 139, 1400, 9, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1405, 8, 139, 1, 140, 1, 140, 3, 140,
    1409, 8, 140, 1, 140, 1, 140, 1, 141, 3, 141, 1414, 8, 141, 1, 141, 1, 141, 1, 141, 3, 141, 1419,
    8, 141, 1, 141, 1, 141, 1, 141, 3, 141, 1424, 8, 141, 1, 142, 1, 142, 1, 142, 3, 142, 1429, 8,
    142, 1, 142, 1, 142, 1, 143, 1, 143, 5, 143, 1435, 8, 143, 10, 143, 12, 143, 1438, 9, 143, 1,
    143, 1, 143, 1, 143, 3, 143, 1443, 8, 143, 1, 144, 1, 144, 1, 145, 1, 145, 1, 146, 1, 146, 1, 147,
    1, 147, 3, 147, 1453, 8, 147, 1, 148, 1, 148, 1, 148, 1, 148, 5, 148, 1459, 8, 148, 10, 148, 12,
    148, 1462, 9, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 1469, 8, 148, 1, 149, 1, 149,
    1, 150, 1, 150, 3, 150, 1475, 8, 150, 1, 151, 1, 151, 1, 151, 1, 151, 5, 151, 1481, 8, 151, 10,
    151, 12, 151, 1484, 9, 151, 1, 151, 1, 151, 1, 151, 1, 151, 1, 151, 3, 151, 1491, 8, 151, 1, 152,
    1, 152, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 3, 153, 1504, 8,
    153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 155, 1, 155, 3, 155, 1513, 8, 155, 1, 155, 1, 155,
    1, 155, 5, 155, 1518, 8, 155, 10, 155, 12, 155, 1521, 9, 155, 1, 155, 1, 155, 4, 155, 1525, 8,
    155, 11, 155, 12, 155, 1526, 1, 155, 3, 155, 1530, 8, 155, 1, 156, 1, 156, 1, 156, 1, 156, 1,
    156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1,
    156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1,
    156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 3,
    156, 1572, 8, 156, 1, 157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 3, 159,
    1583, 8, 159, 1, 159, 1, 159, 1, 160, 1, 160, 3, 160, 1589, 8, 160, 1, 161, 1, 161, 1, 161, 1,
    161, 1, 161, 1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1,
    163, 3, 163, 1607, 8, 163, 1, 164, 1, 164, 1, 165, 1, 165, 1, 166, 1, 166, 1, 167, 1, 167, 1, 168,
    1, 168, 1, 169, 1, 169, 1, 170, 1, 170, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172,
    1, 173, 1, 173, 1, 173, 1, 173, 1, 173, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 175, 1, 175,
    1, 175, 1, 175, 1, 175, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 177, 1, 177, 1, 177, 1, 177,
    1, 177, 1, 178, 1, 178, 1, 178, 1, 178, 1, 179, 1, 179, 1, 179, 1, 179, 1, 180, 1, 180, 1, 180,
    1, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 182, 1, 182, 1, 182, 1, 182, 1, 183, 1, 183, 1, 183,
    1, 183, 1, 184, 1, 184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1, 186, 1, 186, 1, 186,
    1, 186, 1, 187, 1, 187, 1, 187, 1, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 189, 1, 189, 1, 189,
    3, 189, 1702, 8, 189, 1, 189, 1, 189, 1, 190, 1, 190, 1, 190, 1, 190, 1, 191, 1, 191, 1, 191, 1,
    191, 1, 192, 1, 192, 1, 192, 1, 192, 1, 193, 1, 193, 1, 193, 1, 193, 1, 194, 1, 194, 1, 194, 1,
    194, 1, 195, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196, 1, 196, 1, 196, 1, 197, 1, 197, 1, 197, 1,
    197, 1, 198, 1, 198, 1, 198, 1, 198, 1, 199, 1, 199, 1, 199, 1, 199, 1, 200, 1, 200, 1, 200, 1,
    200, 1, 201, 1, 201, 1, 201, 1, 201, 1, 202, 1, 202, 1, 202, 1, 202, 1, 203, 1, 203, 1, 203, 1,
    203, 1, 204, 1, 204, 1, 204, 1, 204, 1, 205, 1, 205, 1, 205, 1, 205, 1, 206, 1, 206, 1, 206, 1,
    206, 1, 207, 1, 207, 1, 207, 3, 207, 1777, 8, 207, 1, 207, 1, 207, 1, 208, 1, 208, 1, 208, 1, 208,
    1, 209, 1, 209, 1, 209, 1, 209, 1, 210, 1, 210, 1, 210, 1, 210, 1, 211, 1, 211, 1, 211, 1, 211,
    1, 212, 1, 212, 1, 212, 1, 212, 1, 213, 1, 213, 1, 213, 1, 213, 1, 214, 1, 214, 1, 214, 1, 214,
    1, 215, 1, 215, 1, 215, 1, 215, 1, 216, 1, 216, 1, 216, 1, 216, 1, 217, 1, 217, 1, 217, 1, 217,
    1, 218, 1, 218, 1, 218, 1, 218, 1, 219, 1, 219, 1, 219, 1, 219, 1, 220, 1, 220, 1, 220, 1, 220,
    1, 221, 1, 221, 1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 1, 222, 1, 223, 1, 223, 1, 223, 1, 223,
    1, 223, 1, 224, 1, 224, 1, 224, 1, 224, 1, 224, 1, 225, 1, 225, 1, 225, 1, 225, 1, 226, 1, 226,
    1, 226, 1, 226, 1, 227, 1, 227, 1, 227, 1, 227, 1, 228, 1, 228, 1, 228, 1, 228, 1, 229, 1, 229,
    1, 229, 1, 229, 1, 230, 1, 230, 1, 230, 1, 230, 1, 231, 1, 231, 1, 231, 1, 231, 1, 232, 1, 232,
    1, 232, 1, 232, 1, 233, 1, 233, 1, 233, 1, 233, 1, 234, 1, 234, 1, 234, 1, 234, 1, 235, 1, 235,
    1, 235, 1, 235, 1, 236, 1, 236, 1, 236, 1, 236, 1, 237, 1, 237, 1, 237, 1, 237, 1, 238, 1, 238,
    1, 238, 1, 238, 1, 239, 1, 239, 1, 239, 1, 239, 1, 240, 1, 240, 1, 240, 1, 240, 1, 241, 1, 241,
    1, 241, 1, 241, 1, 242, 1, 242, 1, 242, 1, 242, 1, 243, 1, 243, 1, 243, 1, 243, 1, 244, 1, 244,
    1, 244, 1, 244, 1, 245, 1, 245, 1, 245, 1, 245, 1, 246, 1, 246, 1, 246, 1, 246, 1, 247, 1, 247,
    1, 247, 1, 247, 1, 248, 1, 248, 1, 248, 1, 248, 1, 249, 1, 249, 1, 249, 1, 249, 1, 250, 1, 250,
    1, 250, 1, 250, 1, 251, 1, 251, 1, 251, 1, 251, 1, 252, 1, 252, 1, 252, 1, 252, 1, 253, 1, 253,
    1, 253, 1, 253, 1, 254, 1, 254, 1, 254, 1, 254, 1, 255, 1, 255, 1, 255, 1, 255, 1, 256, 1, 256,
    1, 256, 1, 256, 1, 257, 1, 257, 1, 257, 1, 257, 1, 258, 1, 258, 1, 258, 1, 258, 1, 259, 1, 259,
    1, 259, 1, 259, 1, 260, 1, 260, 1, 260, 1, 260, 1, 261, 1, 261, 1, 261, 1, 261, 1, 262, 1, 262,
    1, 262, 1, 262, 1, 263, 1, 263, 1, 263, 1, 263, 1, 264, 1, 264, 1, 264, 1, 264, 1, 265, 1, 265,
    1, 265, 1, 265, 1, 266, 1, 266, 1, 266, 1, 266, 1, 267, 1, 267, 1, 267, 1, 267, 1, 268, 1, 268,
    1, 268, 1, 268, 1, 269, 1, 269, 1, 269, 1, 269, 1, 270, 1, 270, 1, 270, 1, 270, 1, 271, 1, 271,
    1, 271, 1, 271, 1, 272, 1, 272, 1, 272, 1, 272, 1, 273, 1, 273, 1, 273, 1, 273, 1, 274, 1, 274,
    1, 274, 1, 274, 1, 275, 1, 275, 1, 275, 1, 275, 1, 276, 1, 276, 1, 276, 1, 276, 1, 277, 1, 277,
    1, 277, 1, 277, 1, 278, 1, 278, 1, 278, 1, 278, 1, 279, 1, 279, 1, 279, 1, 279, 1, 280, 1, 280,
    1, 280, 1, 280, 1, 281, 1, 281, 1, 281, 1, 281, 1, 282, 1, 282, 1, 282, 1, 282, 1, 283, 1, 283,
    1, 283, 1, 283, 1, 284, 1, 284, 1, 284, 1, 284, 1, 285, 1, 285, 1, 285, 1, 285, 1, 286, 1, 286,
    1, 286, 1, 286, 1, 287, 1, 287, 1, 287, 1, 287, 1, 288, 1, 288, 1, 288, 1, 288, 1, 289, 1, 289,
    1, 289, 1, 289, 1, 290, 1, 290, 1, 290, 1, 290, 1, 291, 1, 291, 1, 291, 1, 291, 1, 292, 1, 292,
    1, 292, 1, 292, 1, 293, 1, 293, 1, 293, 1, 293, 1, 294, 1, 294, 3, 294, 2129, 8, 294, 1, 294, 1,
    294, 1, 295, 1, 295, 1, 295, 1, 295, 1, 296, 1, 296, 1, 296, 1, 296, 1, 297, 1, 297, 1, 297, 1,
    297, 1, 298, 1, 298, 1, 299, 4, 299, 2148, 8, 299, 11, 299, 12, 299, 2149, 1, 299, 3, 299, 2153,
    8, 299, 1, 300, 1, 300, 3, 300, 2157, 8, 300, 1, 301, 1, 301, 1, 301, 1, 301, 1, 301, 1, 302, 3,
    302, 2165, 8, 302, 1, 302, 1, 302, 1, 302, 1, 302, 1, 302, 1, 302, 1, 303, 4, 303, 2174, 8, 303,
    11, 303, 12, 303, 2175, 1, 304, 1, 304, 1, 305, 4, 305, 2181, 8, 305, 11, 305, 12, 305, 2182,
    1, 305, 3, 305, 2186, 8, 305, 1, 306, 1, 306, 1, 306, 1, 306, 1, 306, 1, 307, 1, 307, 1, 307, 1,
    307, 1, 636, 0, 308, 4, 1, 6, 2, 8, 3, 10, 4, 12, 5, 14, 0, 16, 6, 18, 7, 20, 8, 22, 9, 24, 10, 26,
    11, 28, 12, 30, 13, 32, 14, 34, 15, 36, 16, 38, 17, 40, 18, 42, 19, 44, 20, 46, 21, 48, 22, 50,
    23, 52, 24, 54, 25, 56, 26, 58, 27, 60, 28, 62, 29, 64, 30, 66, 31, 68, 32, 70, 33, 72, 34, 74,
    35, 76, 36, 78, 37, 80, 38, 82, 39, 84, 40, 86, 41, 88, 42, 90, 43, 92, 44, 94, 45, 96, 46, 98,
    47, 100, 48, 102, 49, 104, 50, 106, 51, 108, 52, 110, 53, 112, 54, 114, 55, 116, 56, 118, 57,
    120, 58, 122, 59, 124, 60, 126, 61, 128, 62, 130, 63, 132, 64, 134, 65, 136, 66, 138, 67, 140,
    68, 142, 69, 144, 70, 146, 71, 148, 72, 150, 73, 152, 74, 154, 75, 156, 76, 158, 77, 160, 78,
    162, 79, 164, 80, 166, 81, 168, 82, 170, 83, 172, 84, 174, 85, 176, 86, 178, 87, 180, 88, 182,
    89, 184, 90, 186, 91, 188, 92, 190, 93, 192, 94, 194, 95, 196, 96, 198, 97, 200, 98, 202, 99,
    204, 100, 206, 101, 208, 102, 210, 103, 212, 104, 214, 105, 216, 106, 218, 107, 220, 108,
    222, 109, 224, 110, 226, 111, 228, 112, 230, 113, 232, 114, 234, 115, 236, 116, 238, 117,
    240, 118, 242, 119, 244, 120, 246, 121, 248, 122, 250, 123, 252, 124, 254, 125, 256, 126,
    258, 127, 260, 128, 262, 129, 264, 130, 266, 131, 268, 132, 270, 133, 272, 134, 274, 135,
    276, 136, 278, 137, 280, 0, 282, 0, 284, 0, 286, 138, 288, 139, 290, 140, 292, 0, 294, 0, 296,
    0, 298, 0, 300, 141, 302, 0, 304, 0, 306, 142, 308, 0, 310, 143, 312, 144, 314, 145, 316, 0,
    318, 146, 320, 147, 322, 148, 324, 0, 326, 0, 328, 0, 330, 0, 332, 149, 334, 150, 336, 151,
    338, 152, 340, 153, 342, 154, 344, 155, 346, 156, 348, 0, 350, 0, 352, 0, 354, 0, 356, 0, 358,
    0, 360, 0, 362, 0, 364, 0, 366, 0, 368, 0, 370, 0, 372, 0, 374, 0, 376, 0, 378, 0, 380, 0, 382,
    0, 384, 0, 386, 0, 388, 0, 390, 0, 392, 0, 394, 0, 396, 0, 398, 0, 400, 0, 402, 0, 404, 0, 406,
    0, 408, 0, 410, 0, 412, 0, 414, 0, 416, 0, 418, 0, 420, 0, 422, 0, 424, 0, 426, 0, 428, 0, 430,
    0, 432, 0, 434, 0, 436, 0, 438, 0, 440, 0, 442, 0, 444, 0, 446, 0, 448, 0, 450, 0, 452, 0, 454,
    0, 456, 0, 458, 0, 460, 0, 462, 0, 464, 0, 466, 0, 468, 0, 470, 0, 472, 0, 474, 0, 476, 0, 478,
    0, 480, 0, 482, 0, 484, 0, 486, 0, 488, 0, 490, 0, 492, 0, 494, 0, 496, 0, 498, 0, 500, 0, 502,
    0, 504, 0, 506, 0, 508, 0, 510, 0, 512, 0, 514, 0, 516, 0, 518, 0, 520, 0, 522, 0, 524, 0, 526,
    0, 528, 0, 530, 0, 532, 0, 534, 0, 536, 0, 538, 0, 540, 0, 542, 0, 544, 0, 546, 0, 548, 0, 550,
    0, 552, 0, 554, 0, 556, 0, 558, 0, 560, 0, 562, 0, 564, 0, 566, 0, 568, 0, 570, 0, 572, 0, 574,
    0, 576, 0, 578, 0, 580, 0, 582, 0, 584, 0, 586, 0, 588, 0, 590, 0, 592, 157, 594, 158, 596, 159,
    598, 160, 600, 161, 602, 162, 604, 163, 606, 164, 608, 165, 610, 166, 612, 167, 614, 168,
    616, 169, 618, 0, 4, 0, 1, 2, 3, 21, 2, 0, 10, 10, 13, 13, 3, 0, 9, 9, 12, 12, 32, 32, 2, 0, 70, 70,
    102, 102, 2, 0, 69, 69, 101, 101, 2, 0, 43, 43, 45, 45, 2, 0, 88, 88, 120, 120, 3, 0, 48, 57, 65,
    70, 97, 102, 2, 0, 66, 66, 98, 98, 1, 0, 48, 49, 7, 0, 10, 10, 13, 13, 60, 60, 62, 62, 91, 91, 93,
    93, 96, 96, 4, 0, 10, 10, 13, 13, 39, 39, 92, 92, 8, 0, 34, 34, 36, 36, 39, 39, 92, 92, 98, 98, 110,
    110, 114, 114, 116, 116, 582, 0, 97, 122, 181, 181, 223, 246, 248, 255, 257, 257, 259, 259,
    261, 261, 263, 263, 265, 265, 267, 267, 269, 269, 271, 271, 273, 273, 275, 275, 277, 277,
    279, 279, 281, 281, 283, 283, 285, 285, 287, 287, 289, 289, 291, 291, 293, 293, 295, 295,
    297, 297, 299, 299, 301, 301, 303, 303, 305, 305, 307, 307, 309, 309, 311, 312, 314, 314,
    316, 316, 318, 318, 320, 320, 322, 322, 324, 324, 326, 326, 328, 329, 331, 331, 333, 333,
    335, 335, 337, 337, 339, 339, 341, 341, 343, 343, 345, 345, 347, 347, 349, 349, 351, 351,
    353, 353, 355, 355, 357, 357, 359, 359, 361, 361, 363, 363, 365, 365, 367, 367, 369, 369,
    371, 371, 373, 373, 375, 375, 378, 378, 380, 380, 382, 384, 387, 387, 389, 389, 392, 392,
    396, 397, 402, 402, 405, 405, 409, 411, 414, 414, 417, 417, 419, 419, 421, 421, 424, 424,
    426, 427, 429, 429, 432, 432, 436, 436, 438, 438, 441, 442, 445, 447, 454, 454, 457, 457,
    460, 460, 462, 462, 464, 464, 466, 466, 468, 468, 470, 470, 472, 472, 474, 474, 476, 477,
    479, 479, 481, 481, 483, 483, 485, 485, 487, 487, 489, 489, 491, 491, 493, 493, 495, 496,
    499, 499, 501, 501, 505, 505, 507, 507, 509, 509, 511, 511, 513, 513, 515, 515, 517, 517,
    519, 519, 521, 521, 523, 523, 525, 525, 527, 527, 529, 529, 531, 531, 533, 533, 535, 535,
    537, 537, 539, 539, 541, 541, 543, 543, 545, 545, 547, 547, 549, 549, 551, 551, 553, 553,
    555, 555, 557, 557, 559, 559, 561, 561, 563, 569, 572, 572, 575, 576, 578, 578, 583, 583,
    585, 585, 587, 587, 589, 589, 591, 659, 661, 687, 881, 881, 883, 883, 887, 887, 891, 893,
    912, 912, 940, 974, 976, 977, 981, 983, 985, 985, 987, 987, 989, 989, 991, 991, 993, 993,
    995, 995, 997, 997, 999, 999, 1001, 1001, 1003, 1003, 1005, 1005, 1007, 1011, 1013, 1013,
    1016, 1016, 1019, 1020, 1072, 1119, 1121, 1121, 1123, 1123, 1125, 1125, 1127, 1127, 1129,
    1129, 1131, 1131, 1133, 1133, 1135, 1135, 1137, 1137, 1139, 1139, 1141, 1141, 1143, 1143,
    1145, 1145, 1147, 1147, 1149, 1149, 1151, 1151, 1153, 1153, 1163, 1163, 1165, 1165, 1167,
    1167, 1169, 1169, 1171, 1171, 1173, 1173, 1175, 1175, 1177, 1177, 1179, 1179, 1181, 1181,
    1183, 1183, 1185, 1185, 1187, 1187, 1189, 1189, 1191, 1191, 1193, 1193, 1195, 1195, 1197,
    1197, 1199, 1199, 1201, 1201, 1203, 1203, 1205, 1205, 1207, 1207, 1209, 1209, 1211, 1211,
    1213, 1213, 1215, 1215, 1218, 1218, 1220, 1220, 1222, 1222, 1224, 1224, 1226, 1226, 1228,
    1228, 1230, 1231, 1233, 1233, 1235, 1235, 1237, 1237, 1239, 1239, 1241, 1241, 1243, 1243,
    1245, 1245, 1247, 1247, 1249, 1249, 1251, 1251, 1253, 1253, 1255, 1255, 1257, 1257, 1259,
    1259, 1261, 1261, 1263, 1263, 1265, 1265, 1267, 1267, 1269, 1269, 1271, 1271, 1273, 1273,
    1275, 1275, 1277, 1277, 1279, 1279, 1281, 1281, 1283, 1283, 1285, 1285, 1287, 1287, 1289,
    1289, 1291, 1291, 1293, 1293, 1295, 1295, 1297, 1297, 1299, 1299, 1301, 1301, 1303, 1303,
    1305, 1305, 1307, 1307, 1309, 1309, 1311, 1311, 1313, 1313, 1315, 1315, 1317, 1317, 1319,
    1319, 1377, 1415, 7424, 7467, 7531, 7543, 7545, 7578, 7681, 7681, 7683, 7683, 7685, 7685,
    7687, 7687, 7689, 7689, 7691, 7691, 7693, 7693, 7695, 7695, 7697, 7697, 7699, 7699, 7701,
    7701, 7703, 7703, 7705, 7705, 7707, 7707, 7709, 7709, 7711, 7711, 7713, 7713, 7715, 7715,
    7717, 7717, 7719, 7719, 7721, 7721, 7723, 7723, 7725, 7725, 7727, 7727, 7729, 7729, 7731,
    7731, 7733, 7733, 7735, 7735, 7737, 7737, 7739, 7739, 7741, 7741, 7743, 7743, 7745, 7745,
    7747, 7747, 7749, 7749, 7751, 7751, 7753, 7753, 7755, 7755, 7757, 7757, 7759, 7759, 7761,
    7761, 7763, 7763, 7765, 7765, 7767, 7767, 7769, 7769, 7771, 7771, 7773, 7773, 7775, 7775,
    7777, 7777, 7779, 7779, 7781, 7781, 7783, 7783, 7785, 7785, 7787, 7787, 7789, 7789, 7791,
    7791, 7793, 7793, 7795, 7795, 7797, 7797, 7799, 7799, 7801, 7801, 7803, 7803, 7805, 7805,
    7807, 7807, 7809, 7809, 7811, 7811, 7813, 7813, 7815, 7815, 7817, 7817, 7819, 7819, 7821,
    7821, 7823, 7823, 7825, 7825, 7827, 7827, 7829, 7837, 7839, 7839, 7841, 7841, 7843, 7843,
    7845, 7845, 7847, 7847, 7849, 7849, 7851, 7851, 7853, 7853, 7855, 7855, 7857, 7857, 7859,
    7859, 7861, 7861, 7863, 7863, 7865, 7865, 7867, 7867, 7869, 7869, 7871, 7871, 7873, 7873,
    7875, 7875, 7877, 7877, 7879, 7879, 7881, 7881, 7883, 7883, 7885, 7885, 7887, 7887, 7889,
    7889, 7891, 7891, 7893, 7893, 7895, 7895, 7897, 7897, 7899, 7899, 7901, 7901, 7903, 7903,
    7905, 7905, 7907, 7907, 7909, 7909, 7911, 7911, 7913, 7913, 7915, 7915, 7917, 7917, 7919,
    7919, 7921, 7921, 7923, 7923, 7925, 7925, 7927, 7927, 7929, 7929, 7931, 7931, 7933, 7933,
    7935, 7943, 7952, 7957, 7968, 7975, 7984, 7991, 8000, 8005, 8016, 8023, 8032, 8039, 8048,
    8061, 8064, 8071, 8080, 8087, 8096, 8103, 8112, 8116, 8118, 8119, 8126, 8126, 8130, 8132,
    8134, 8135, 8144, 8147, 8150, 8151, 8160, 8167, 8178, 8180, 8182, 8183, 8458, 8458, 8462,
    8463, 8467, 8467, 8495, 8495, 8500, 8500, 8505, 8505, 8508, 8509, 8518, 8521, 8526, 8526,
    8580, 8580, 11312, 11358, 11361, 11361, 11365, 11366, 11368, 11368, 11370, 11370, 11372,
    11372, 11377, 11377, 11379, 11380, 11382, 11387, 11393, 11393, 11395, 11395, 11397,
    11397, 11399, 11399, 11401, 11401, 11403, 11403, 11405, 11405, 11407, 11407, 11409,
    11409, 11411, 11411, 11413, 11413, 11415, 11415, 11417, 11417, 11419, 11419, 11421,
    11421, 11423, 11423, 11425, 11425, 11427, 11427, 11429, 11429, 11431, 11431, 11433,
    11433, 11435, 11435, 11437, 11437, 11439, 11439, 11441, 11441, 11443, 11443, 11445,
    11445, 11447, 11447, 11449, 11449, 11451, 11451, 11453, 11453, 11455, 11455, 11457,
    11457, 11459, 11459, 11461, 11461, 11463, 11463, 11465, 11465, 11467, 11467, 11469,
    11469, 11471, 11471, 11473, 11473, 11475, 11475, 11477, 11477, 11479, 11479, 11481,
    11481, 11483, 11483, 11485, 11485, 11487, 11487, 11489, 11489, 11491, 11492, 11500,
    11500, 11502, 11502, 11507, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 42561,
    42561, 42563, 42563, 42565, 42565, 42567, 42567, 42569, 42569, 42571, 42571, 42573,
    42573, 42575, 42575, 42577, 42577, 42579, 42579, 42581, 42581, 42583, 42583, 42585,
    42585, 42587, 42587, 42589, 42589, 42591, 42591, 42593, 42593, 42595, 42595, 42597,
    42597, 42599, 42599, 42601, 42601, 42603, 42603, 42605, 42605, 42625, 42625, 42627,
    42627, 42629, 42629, 42631, 42631, 42633, 42633, 42635, 42635, 42637, 42637, 42639,
    42639, 42641, 42641, 42643, 42643, 42645, 42645, 42647, 42647, 42787, 42787, 42789,
    42789, 42791, 42791, 42793, 42793, 42795, 42795, 42797, 42797, 42799, 42801, 42803,
    42803, 42805, 42805, 42807, 42807, 42809, 42809, 42811, 42811, 42813, 42813, 42815,
    42815, 42817, 42817, 42819, 42819, 42821, 42821, 42823, 42823, 42825, 42825, 42827,
    42827, 42829, 42829, 42831, 42831, 42833, 42833, 42835, 42835, 42837, 42837, 42839,
    42839, 42841, 42841, 42843, 42843, 42845, 42845, 42847, 42847, 42849, 42849, 42851,
    42851, 42853, 42853, 42855, 42855, 42857, 42857, 42859, 42859, 42861, 42861, 42863,
    42863, 42865, 42872, 42874, 42874, 42876, 42876, 42879, 42879, 42881, 42881, 42883,
    42883, 42885, 42885, 42887, 42887, 42892, 42892, 42894, 42894, 42897, 42897, 42899,
    42899, 42913, 42913, 42915, 42915, 42917, 42917, 42919, 42919, 42921, 42921, 43002,
    43002, 64256, 64262, 64275, 64279, 65345, 65370, 51, 0, 688, 705, 710, 721, 736, 740, 748,
    748, 750, 750, 884, 884, 890, 890, 1369, 1369, 1600, 1600, 1765, 1766, 2036, 2037, 2042,
    2042, 2074, 2074, 2084, 2084, 2088, 2088, 2417, 2417, 3654, 3654, 3782, 3782, 4348, 4348,
    6103, 6103, 6211, 6211, 6823, 6823, 7288, 7293, 7468, 7530, 7544, 7544, 7579, 7615, 8305,
    8305, 8319, 8319, 8336, 8348, 11388, 11389, 11631, 11631, 11823, 11823, 12293, 12293,
    12337, 12341, 12347, 12347, 12445, 12446, 12540, 12542, 40981, 40981, 42232, 42237,
    42508, 42508, 42623, 42623, 42775, 42783, 42864, 42864, 42888, 42888, 43000, 43001,
    43471, 43471, 43632, 43632, 43741, 43741, 43763, 43764, 65392, 65392, 65438, 65439,
    287, 0, 170, 170, 186, 186, 443, 443, 448, 451, 660, 660, 1488, 1514, 1520, 1522, 1568, 1599,
    1601, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1774, 1775, 1786, 1788, 1791, 1791, 1808,
    1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2048, 2069, 2112, 2136, 2208, 2208,
    2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2418, 2423, 2425, 2431, 2437,
    2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510,
    2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610,
    2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,
    2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821,
    2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909,
    2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972,
    2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088,
    3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214,
    3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314,
    3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461,
    3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3653,
    3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745,
    3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780,
    3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176,
    4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4304, 4346,
    4349, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752,
    4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885,
    4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5888,
    5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6108, 6108,
    6176, 6210, 6212, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512,
    6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6917, 6963, 6981, 6987, 7043, 7072,
    7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7287, 7401, 7404, 7406, 7409, 7413,
    7414, 8501, 8504, 11568, 11623, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702,
    11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12294, 12294,
    12348, 12348, 12353, 12438, 12447, 12447, 12449, 12538, 12543, 12543, 12549, 12589,
    12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 40980,
    40982, 42124, 42192, 42231, 42240, 42507, 42512, 42527, 42538, 42539, 42606, 42606,
    42656, 42725, 43003, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123,
    43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388,
    43396, 43442, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43631, 43633, 43638,
    43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712,
    43714, 43714, 43739, 43740, 43744, 43754, 43762, 43762, 43777, 43782, 43785, 43790,
    43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032, 55203, 55203,
    55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64285, 64285, 64287, 64296,
    64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433,
    64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276,
    65382, 65391, 65393, 65437, 65440, 65470, 65474, 65479, 65482, 65487, 65490, 65495,
    65498, 65500, 10, 0, 453, 453, 456, 456, 459, 459, 498, 498, 8072, 8079, 8088, 8095, 8104,
    8111, 8124, 8124, 8140, 8140, 8188, 8188, 576, 0, 65, 90, 192, 214, 216, 222, 256, 256, 258,
    258, 260, 260, 262, 262, 264, 264, 266, 266, 268, 268, 270, 270, 272, 272, 274, 274, 276,
    276, 278, 278, 280, 280, 282, 282, 284, 284, 286, 286, 288, 288, 290, 290, 292, 292, 294,
    294, 296, 296, 298, 298, 300, 300, 302, 302, 304, 304, 306, 306, 308, 308, 310, 310, 313,
    313, 315, 315, 317, 317, 319, 319, 321, 321, 323, 323, 325, 325, 327, 327, 330, 330, 332,
    332, 334, 334, 336, 336, 338, 338, 340, 340, 342, 342, 344, 344, 346, 346, 348, 348, 350,
    350, 352, 352, 354, 354, 356, 356, 358, 358, 360, 360, 362, 362, 364, 364, 366, 366, 368,
    368, 370, 370, 372, 372, 374, 374, 376, 377, 379, 379, 381, 381, 385, 386, 388, 388, 390,
    391, 393, 395, 398, 401, 403, 404, 406, 408, 412, 413, 415, 416, 418, 418, 420, 420, 422,
    423, 425, 425, 428, 428, 430, 431, 433, 435, 437, 437, 439, 440, 444, 444, 452, 452, 455,
    455, 458, 458, 461, 461, 463, 463, 465, 465, 467, 467, 469, 469, 471, 471, 473, 473, 475,
    475, 478, 478, 480, 480, 482, 482, 484, 484, 486, 486, 488, 488, 490, 490, 492, 492, 494,
    494, 497, 497, 500, 500, 502, 504, 506, 506, 508, 508, 510, 510, 512, 512, 514, 514, 516,
    516, 518, 518, 520, 520, 522, 522, 524, 524, 526, 526, 528, 528, 530, 530, 532, 532, 534,
    534, 536, 536, 538, 538, 540, 540, 542, 542, 544, 544, 546, 546, 548, 548, 550, 550, 552,
    552, 554, 554, 556, 556, 558, 558, 560, 560, 562, 562, 570, 571, 573, 574, 577, 577, 579,
    582, 584, 584, 586, 586, 588, 588, 590, 590, 880, 880, 882, 882, 886, 886, 902, 902, 904,
    906, 908, 908, 910, 911, 913, 929, 931, 939, 975, 975, 978, 980, 984, 984, 986, 986, 988,
    988, 990, 990, 992, 992, 994, 994, 996, 996, 998, 998, 1000, 1000, 1002, 1002, 1004, 1004,
    1006, 1006, 1012, 1012, 1015, 1015, 1017, 1018, 1021, 1071, 1120, 1120, 1122, 1122, 1124,
    1124, 1126, 1126, 1128, 1128, 1130, 1130, 1132, 1132, 1134, 1134, 1136, 1136, 1138, 1138,
    1140, 1140, 1142, 1142, 1144, 1144, 1146, 1146, 1148, 1148, 1150, 1150, 1152, 1152, 1162,
    1162, 1164, 1164, 1166, 1166, 1168, 1168, 1170, 1170, 1172, 1172, 1174, 1174, 1176, 1176,
    1178, 1178, 1180, 1180, 1182, 1182, 1184, 1184, 1186, 1186, 1188, 1188, 1190, 1190, 1192,
    1192, 1194, 1194, 1196, 1196, 1198, 1198, 1200, 1200, 1202, 1202, 1204, 1204, 1206, 1206,
    1208, 1208, 1210, 1210, 1212, 1212, 1214, 1214, 1216, 1217, 1219, 1219, 1221, 1221, 1223,
    1223, 1225, 1225, 1227, 1227, 1229, 1229, 1232, 1232, 1234, 1234, 1236, 1236, 1238, 1238,
    1240, 1240, 1242, 1242, 1244, 1244, 1246, 1246, 1248, 1248, 1250, 1250, 1252, 1252, 1254,
    1254, 1256, 1256, 1258, 1258, 1260, 1260, 1262, 1262, 1264, 1264, 1266, 1266, 1268, 1268,
    1270, 1270, 1272, 1272, 1274, 1274, 1276, 1276, 1278, 1278, 1280, 1280, 1282, 1282, 1284,
    1284, 1286, 1286, 1288, 1288, 1290, 1290, 1292, 1292, 1294, 1294, 1296, 1296, 1298, 1298,
    1300, 1300, 1302, 1302, 1304, 1304, 1306, 1306, 1308, 1308, 1310, 1310, 1312, 1312, 1314,
    1314, 1316, 1316, 1318, 1318, 1329, 1366, 4256, 4293, 4295, 4295, 4301, 4301, 7680, 7680,
    7682, 7682, 7684, 7684, 7686, 7686, 7688, 7688, 7690, 7690, 7692, 7692, 7694, 7694, 7696,
    7696, 7698, 7698, 7700, 7700, 7702, 7702, 7704, 7704, 7706, 7706, 7708, 7708, 7710, 7710,
    7712, 7712, 7714, 7714, 7716, 7716, 7718, 7718, 7720, 7720, 7722, 7722, 7724, 7724, 7726,
    7726, 7728, 7728, 7730, 7730, 7732, 7732, 7734, 7734, 7736, 7736, 7738, 7738, 7740, 7740,
    7742, 7742, 7744, 7744, 7746, 7746, 7748, 7748, 7750, 7750, 7752, 7752, 7754, 7754, 7756,
    7756, 7758, 7758, 7760, 7760, 7762, 7762, 7764, 7764, 7766, 7766, 7768, 7768, 7770, 7770,
    7772, 7772, 7774, 7774, 7776, 7776, 7778, 7778, 7780, 7780, 7782, 7782, 7784, 7784, 7786,
    7786, 7788, 7788, 7790, 7790, 7792, 7792, 7794, 7794, 7796, 7796, 7798, 7798, 7800, 7800,
    7802, 7802, 7804, 7804, 7806, 7806, 7808, 7808, 7810, 7810, 7812, 7812, 7814, 7814, 7816,
    7816, 7818, 7818, 7820, 7820, 7822, 7822, 7824, 7824, 7826, 7826, 7828, 7828, 7838, 7838,
    7840, 7840, 7842, 7842, 7844, 7844, 7846, 7846, 7848, 7848, 7850, 7850, 7852, 7852, 7854,
    7854, 7856, 7856, 7858, 7858, 7860, 7860, 7862, 7862, 7864, 7864, 7866, 7866, 7868, 7868,
    7870, 7870, 7872, 7872, 7874, 7874, 7876, 7876, 7878, 7878, 7880, 7880, 7882, 7882, 7884,
    7884, 7886, 7886, 7888, 7888, 7890, 7890, 7892, 7892, 7894, 7894, 7896, 7896, 7898, 7898,
    7900, 7900, 7902, 7902, 7904, 7904, 7906, 7906, 7908, 7908, 7910, 7910, 7912, 7912, 7914,
    7914, 7916, 7916, 7918, 7918, 7920, 7920, 7922, 7922, 7924, 7924, 7926, 7926, 7928, 7928,
    7930, 7930, 7932, 7932, 7934, 7934, 7944, 7951, 7960, 7965, 7976, 7983, 7992, 7999, 8008,
    8013, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8031, 8040, 8047, 8120, 8123, 8136, 8139,
    8152, 8155, 8168, 8172, 8184, 8187, 8450, 8450, 8455, 8455, 8459, 8461, 8464, 8466, 8469,
    8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8496, 8499, 8510, 8511,
    8517, 8517, 8579, 8579, 11264, 11310, 11360, 11360, 11362, 11364, 11367, 11367, 11369,
    11369, 11371, 11371, 11373, 11376, 11378, 11378, 11381, 11381, 11390, 11392, 11394,
    11394, 11396, 11396, 11398, 11398, 11400, 11400, 11402, 11402, 11404, 11404, 11406,
    11406, 11408, 11408, 11410, 11410, 11412, 11412, 11414, 11414, 11416, 11416, 11418,
    11418, 11420, 11420, 11422, 11422, 11424, 11424, 11426, 11426, 11428, 11428, 11430,
    11430, 11432, 11432, 11434, 11434, 11436, 11436, 11438, 11438, 11440, 11440, 11442,
    11442, 11444, 11444, 11446, 11446, 11448, 11448, 11450, 11450, 11452, 11452, 11454,
    11454, 11456, 11456, 11458, 11458, 11460, 11460, 11462, 11462, 11464, 11464, 11466,
    11466, 11468, 11468, 11470, 11470, 11472, 11472, 11474, 11474, 11476, 11476, 11478,
    11478, 11480, 11480, 11482, 11482, 11484, 11484, 11486, 11486, 11488, 11488, 11490,
    11490, 11499, 11499, 11501, 11501, 11506, 11506, 42560, 42560, 42562, 42562, 42564,
    42564, 42566, 42566, 42568, 42568, 42570, 42570, 42572, 42572, 42574, 42574, 42576,
    42576, 42578, 42578, 42580, 42580, 42582, 42582, 42584, 42584, 42586, 42586, 42588,
    42588, 42590, 42590, 42592, 42592, 42594, 42594, 42596, 42596, 42598, 42598, 42600,
    42600, 42602, 42602, 42604, 42604, 42624, 42624, 42626, 42626, 42628, 42628, 42630,
    42630, 42632, 42632, 42634, 42634, 42636, 42636, 42638, 42638, 42640, 42640, 42642,
    42642, 42644, 42644, 42646, 42646, 42786, 42786, 42788, 42788, 42790, 42790, 42792,
    42792, 42794, 42794, 42796, 42796, 42798, 42798, 42802, 42802, 42804, 42804, 42806,
    42806, 42808, 42808, 42810, 42810, 42812, 42812, 42814, 42814, 42816, 42816, 42818,
    42818, 42820, 42820, 42822, 42822, 42824, 42824, 42826, 42826, 42828, 42828, 42830,
    42830, 42832, 42832, 42834, 42834, 42836, 42836, 42838, 42838, 42840, 42840, 42842,
    42842, 42844, 42844, 42846, 42846, 42848, 42848, 42850, 42850, 42852, 42852, 42854,
    42854, 42856, 42856, 42858, 42858, 42860, 42860, 42862, 42862, 42873, 42873, 42875,
    42875, 42877, 42878, 42880, 42880, 42882, 42882, 42884, 42884, 42886, 42886, 42891,
    42891, 42893, 42893, 42896, 42896, 42898, 42898, 42912, 42912, 42914, 42914, 42916,
    42916, 42918, 42918, 42920, 42920, 42922, 42922, 65313, 65338, 35, 0, 48, 57, 1632, 1641,
    1776, 1785, 1984, 1993, 2406, 2415, 2534, 2543, 2662, 2671, 2790, 2799, 2918, 2927, 3046,
    3055, 3174, 3183, 3302, 3311, 3430, 3439, 3664, 3673, 3792, 3801, 3872, 3881, 4160, 4169,
    4240, 4249, 6112, 6121, 6160, 6169, 6470, 6479, 6608, 6617, 6784, 6793, 6800, 6809, 6992,
    7001, 7088, 7097, 7232, 7241, 7248, 7257, 42528, 42537, 43216, 43225, 43264, 43273, 43472,
    43481, 43600, 43609, 44016, 44025, 65296, 65305, 7, 0, 5870, 5872, 8544, 8578, 8581, 8584,
    12295, 12295, 12321, 12329, 12344, 12346, 42726, 42735, 3, 0, 34, 34, 36, 36, 92, 92, 2,
    0, 34, 34, 36, 36, 2269, 0, 4, 1, 0, 0, 0, 0, 6, 1, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 12,
    1, 0, 0, 0, 0, 16, 1, 0, 0, 0, 0, 18, 1, 0, 0, 0, 0, 20, 1, 0, 0, 0, 0, 22, 1, 0, 0, 0, 0, 24, 1, 0, 0, 0,
    0, 26, 1, 0, 0, 0, 0, 28, 1, 0, 0, 0, 0, 30, 1, 0, 0, 0, 0, 32, 1, 0, 0, 0, 0, 34, 1, 0, 0, 0, 0, 36, 1,
    0, 0, 0, 0, 38, 1, 0, 0, 0, 0, 40, 1, 0, 0, 0, 0, 42, 1, 0, 0, 0, 0, 44, 1, 0, 0, 0, 0, 46, 1, 0, 0, 0, 0,
    48, 1, 0, 0, 0, 0, 50, 1, 0, 0, 0, 0, 52, 1, 0, 0, 0, 0, 54, 1, 0, 0, 0, 0, 56, 1, 0, 0, 0, 0, 58, 1, 0,
    0, 0, 0, 60, 1, 0, 0, 0, 0, 62, 1, 0, 0, 0, 0, 64, 1, 0, 0, 0, 0, 66, 1, 0, 0, 0, 0, 68, 1, 0, 0, 0, 0, 70,
    1, 0, 0, 0, 0, 72, 1, 0, 0, 0, 0, 74, 1, 0, 0, 0, 0, 76, 1, 0, 0, 0, 0, 78, 1, 0, 0, 0, 0, 80, 1, 0, 0, 0,
    0, 82, 1, 0, 0, 0, 0, 84, 1, 0, 0, 0, 0, 86, 1, 0, 0, 0, 0, 88, 1, 0, 0, 0, 0, 90, 1, 0, 0, 0, 0, 92, 1,
    0, 0, 0, 0, 94, 1, 0, 0, 0, 0, 96, 1, 0, 0, 0, 0, 98, 1, 0, 0, 0, 0, 100, 1, 0, 0, 0, 0, 102, 1, 0, 0, 0,
    0, 104, 1, 0, 0, 0, 0, 106, 1, 0, 0, 0, 0, 108, 1, 0, 0, 0, 0, 110, 1, 0, 0, 0, 0, 112, 1, 0, 0, 0, 0,
    114, 1, 0, 0, 0, 0, 116, 1, 0, 0, 0, 0, 118, 1, 0, 0, 0, 0, 120, 1, 0, 0, 0, 0, 122, 1, 0, 0, 0, 0, 124,
    1, 0, 0, 0, 0, 126, 1, 0, 0, 0, 0, 128, 1, 0, 0, 0, 0, 130, 1, 0, 0, 0, 0, 132, 1, 0, 0, 0, 0, 134, 1,
    0, 0, 0, 0, 136, 1, 0, 0, 0, 0, 138, 1, 0, 0, 0, 0, 140, 1, 0, 0, 0, 0, 142, 1, 0, 0, 0, 0, 144, 1, 0,
    0, 0, 0, 146, 1, 0, 0, 0, 0, 148, 1, 0, 0, 0, 0, 150, 1, 0, 0, 0, 0, 152, 1, 0, 0, 0, 0, 154, 1, 0, 0,
    0, 0, 156, 1, 0, 0, 0, 0, 158, 1, 0, 0, 0, 0, 160, 1, 0, 0, 0, 0, 162, 1, 0, 0, 0, 0, 164, 1, 0, 0, 0,
    0, 166, 1, 0, 0, 0, 0, 168, 1, 0, 0, 0, 0, 170, 1, 0, 0, 0, 0, 172, 1, 0, 0, 0, 0, 174, 1, 0, 0, 0, 0,
    176, 1, 0, 0, 0, 0, 178, 1, 0, 0, 0, 0, 180, 1, 0, 0, 0, 0, 182, 1, 0, 0, 0, 0, 184, 1, 0, 0, 0, 0, 186,
    1, 0, 0, 0, 0, 188, 1, 0, 0, 0, 0, 190, 1, 0, 0, 0, 0, 192, 1, 0, 0, 0, 0, 194, 1, 0, 0, 0, 0, 196, 1,
    0, 0, 0, 0, 198, 1, 0, 0, 0, 0, 200, 1, 0, 0, 0, 0, 202, 1, 0, 0, 0, 0, 204, 1, 0, 0, 0, 0, 206, 1, 0,
    0, 0, 0, 208, 1, 0, 0, 0, 0, 210, 1, 0, 0, 0, 0, 212, 1, 0, 0, 0, 0, 214, 1, 0, 0, 0, 0, 216, 1, 0, 0,
    0, 0, 218, 1, 0, 0, 0, 0, 220, 1, 0, 0, 0, 0, 222, 1, 0, 0, 0, 0, 224, 1, 0, 0, 0, 0, 226, 1, 0, 0, 0,
    0, 228, 1, 0, 0, 0, 0, 230, 1, 0, 0, 0, 0, 232, 1, 0, 0, 0, 0, 234, 1, 0, 0, 0, 0, 236, 1, 0, 0, 0, 0,
    238, 1, 0, 0, 0, 0, 240, 1, 0, 0, 0, 0, 242, 1, 0, 0, 0, 0, 244, 1, 0, 0, 0, 0, 246, 1, 0, 0, 0, 0, 248,
    1, 0, 0, 0, 0, 250, 1, 0, 0, 0, 0, 252, 1, 0, 0, 0, 0, 254, 1, 0, 0, 0, 0, 256, 1, 0, 0, 0, 0, 258, 1,
    0, 0, 0, 0, 260, 1, 0, 0, 0, 0, 262, 1, 0, 0, 0, 0, 264, 1, 0, 0, 0, 0, 266, 1, 0, 0, 0, 0, 268, 1, 0,
    0, 0, 0, 270, 1, 0, 0, 0, 0, 272, 1, 0, 0, 0, 0, 274, 1, 0, 0, 0, 0, 276, 1, 0, 0, 0, 0, 278, 1, 0, 0,
    0, 0, 286, 1, 0, 0, 0, 0, 288, 1, 0, 0, 0, 0, 290, 1, 0, 0, 0, 0, 300, 1, 0, 0, 0, 0, 306, 1, 0, 0, 0,
    0, 310, 1, 0, 0, 0, 0, 312, 1, 0, 0, 0, 0, 314, 1, 0, 0, 0, 0, 318, 1, 0, 0, 0, 0, 320, 1, 0, 0, 0, 0,
    322, 1, 0, 0, 0, 0, 332, 1, 0, 0, 0, 0, 334, 1, 0, 0, 0, 0, 336, 1, 0, 0, 0, 0, 338, 1, 0, 0, 0, 0, 340,
    1, 0, 0, 0, 0, 342, 1, 0, 0, 0, 0, 344, 1, 0, 0, 0, 0, 346, 1, 0, 0, 0, 1, 348, 1, 0, 0, 0, 1, 350, 1,
    0, 0, 0, 1, 352, 1, 0, 0, 0, 1, 354, 1, 0, 0, 0, 1, 356, 1, 0, 0, 0, 1, 358, 1, 0, 0, 0, 1, 360, 1, 0,
    0, 0, 1, 362, 1, 0, 0, 0, 1, 364, 1, 0, 0, 0, 1, 366, 1, 0, 0, 0, 1, 368, 1, 0, 0, 0, 1, 370, 1, 0, 0,
    0, 1, 372, 1, 0, 0, 0, 1, 374, 1, 0, 0, 0, 1, 376, 1, 0, 0, 0, 1, 378, 1, 0, 0, 0, 1, 380, 1, 0, 0, 0,
    1, 382, 1, 0, 0, 0, 1, 384, 1, 0, 0, 0, 1, 386, 1, 0, 0, 0, 1, 388, 1, 0, 0, 0, 1, 390, 1, 0, 0, 0, 1,
    392, 1, 0, 0, 0, 1, 394, 1, 0, 0, 0, 1, 396, 1, 0, 0, 0, 1, 398, 1, 0, 0, 0, 1, 400, 1, 0, 0, 0, 1, 402,
    1, 0, 0, 0, 1, 404, 1, 0, 0, 0, 1, 406, 1, 0, 0, 0, 1, 408, 1, 0, 0, 0, 1, 410, 1, 0, 0, 0, 1, 412, 1,
    0, 0, 0, 1, 414, 1, 0, 0, 0, 1, 416, 1, 0, 0, 0, 1, 418, 1, 0, 0, 0, 1, 420, 1, 0, 0, 0, 1, 422, 1, 0,
    0, 0, 1, 424, 1, 0, 0, 0, 1, 426, 1, 0, 0, 0, 1, 428, 1, 0, 0, 0, 1, 430, 1, 0, 0, 0, 1, 432, 1, 0, 0,
    0, 1, 434, 1, 0, 0, 0, 1, 436, 1, 0, 0, 0, 1, 438, 1, 0, 0, 0, 1, 440, 1, 0, 0, 0, 1, 442, 1, 0, 0, 0,
    1, 444, 1, 0, 0, 0, 1, 446, 1, 0, 0, 0, 1, 448, 1, 0, 0, 0, 1, 450, 1, 0, 0, 0, 1, 452, 1, 0, 0, 0, 1,
    454, 1, 0, 0, 0, 1, 456, 1, 0, 0, 0, 1, 458, 1, 0, 0, 0, 1, 460, 1, 0, 0, 0, 1, 462, 1, 0, 0, 0, 1, 464,
    1, 0, 0, 0, 1, 466, 1, 0, 0, 0, 1, 468, 1, 0, 0, 0, 1, 470, 1, 0, 0, 0, 1, 472, 1, 0, 0, 0, 1, 474, 1,
    0, 0, 0, 1, 476, 1, 0, 0, 0, 1, 478, 1, 0, 0, 0, 1, 480, 1, 0, 0, 0, 1, 482, 1, 0, 0, 0, 1, 484, 1, 0,
    0, 0, 1, 486, 1, 0, 0, 0, 1, 488, 1, 0, 0, 0, 1, 490, 1, 0, 0, 0, 1, 492, 1, 0, 0, 0, 1, 494, 1, 0, 0,
    0, 1, 496, 1, 0, 0, 0, 1, 498, 1, 0, 0, 0, 1, 500, 1, 0, 0, 0, 1, 502, 1, 0, 0, 0, 1, 504, 1, 0, 0, 0,
    1, 506, 1, 0, 0, 0, 1, 508, 1, 0, 0, 0, 1, 510, 1, 0, 0, 0, 1, 512, 1, 0, 0, 0, 1, 514, 1, 0, 0, 0, 1,
    516, 1, 0, 0, 0, 1, 518, 1, 0, 0, 0, 1, 520, 1, 0, 0, 0, 1, 522, 1, 0, 0, 0, 1, 524, 1, 0, 0, 0, 1, 526,
    1, 0, 0, 0, 1, 528, 1, 0, 0, 0, 1, 530, 1, 0, 0, 0, 1, 532, 1, 0, 0, 0, 1, 534, 1, 0, 0, 0, 1, 536, 1,
    0, 0, 0, 1, 538, 1, 0, 0, 0, 1, 540, 1, 0, 0, 0, 1, 542, 1, 0, 0, 0, 1, 544, 1, 0, 0, 0, 1, 546, 1, 0,
    0, 0, 1, 548, 1, 0, 0, 0, 1, 550, 1, 0, 0, 0, 1, 552, 1, 0, 0, 0, 1, 554, 1, 0, 0, 0, 1, 556, 1, 0, 0,
    0, 1, 558, 1, 0, 0, 0, 1, 560, 1, 0, 0, 0, 1, 562, 1, 0, 0, 0, 1, 564, 1, 0, 0, 0, 1, 566, 1, 0, 0, 0,
    1, 568, 1, 0, 0, 0, 1, 570, 1, 0, 0, 0, 1, 572, 1, 0, 0, 0, 1, 574, 1, 0, 0, 0, 1, 576, 1, 0, 0, 0, 1,
    578, 1, 0, 0, 0, 1, 580, 1, 0, 0, 0, 1, 582, 1, 0, 0, 0, 1, 584, 1, 0, 0, 0, 1, 586, 1, 0, 0, 0, 1, 588,
    1, 0, 0, 0, 1, 590, 1, 0, 0, 0, 1, 592, 1, 0, 0, 0, 1, 594, 1, 0, 0, 0, 1, 596, 1, 0, 0, 0, 2, 598, 1,
    0, 0, 0, 2, 600, 1, 0, 0, 0, 2, 602, 1, 0, 0, 0, 2, 604, 1, 0, 0, 0, 2, 606, 1, 0, 0, 0, 3, 608, 1, 0,
    0, 0, 3, 610, 1, 0, 0, 0, 3, 612, 1, 0, 0, 0, 3, 614, 1, 0, 0, 0, 3, 616, 1, 0, 0, 0, 3, 618, 1, 0, 0,
    0, 4, 620, 1, 0, 0, 0, 6, 629, 1, 0, 0, 0, 8, 644, 1, 0, 0, 0, 10, 655, 1, 0, 0, 0, 12, 664, 1, 0, 0,
    0, 14, 669, 1, 0, 0, 0, 16, 671, 1, 0, 0, 0, 18, 675, 1, 0, 0, 0, 20, 677, 1, 0, 0, 0, 22, 679, 1, 0,
    0, 0, 24, 683, 1, 0, 0, 0, 26, 687, 1, 0, 0, 0, 28, 691, 1, 0, 0, 0, 30, 695, 1, 0, 0, 0, 32, 699, 1,
    0, 0, 0, 34, 703, 1, 0, 0, 0, 36, 705, 1, 0, 0, 0, 38, 707, 1, 0, 0, 0, 40, 709, 1, 0, 0, 0, 42, 711,
    1, 0, 0, 0, 44, 713, 1, 0, 0, 0, 46, 716, 1, 0, 0, 0, 48, 719, 1, 0, 0, 0, 50, 722, 1, 0, 0, 0, 52, 725,
    1, 0, 0, 0, 54, 728, 1, 0, 0, 0, 56, 730, 1, 0, 0, 0, 58, 732, 1, 0, 0, 0, 60, 734, 1, 0, 0, 0, 62, 736,
    1, 0, 0, 0, 64, 739, 1, 0, 0, 0, 66, 742, 1, 0, 0, 0, 68, 745, 1, 0, 0, 0, 70, 748, 1, 0, 0, 0, 72, 751,
    1, 0, 0, 0, 74, 754, 1, 0, 0, 0, 76, 757, 1, 0, 0, 0, 78, 760, 1, 0, 0, 0, 80, 763, 1, 0, 0, 0, 82, 766,
    1, 0, 0, 0, 84, 768, 1, 0, 0, 0, 86, 770, 1, 0, 0, 0, 88, 775, 1, 0, 0, 0, 90, 778, 1, 0, 0, 0, 92, 780,
    1, 0, 0, 0, 94, 782, 1, 0, 0, 0, 96, 784, 1, 0, 0, 0, 98, 787, 1, 0, 0, 0, 100, 790, 1, 0, 0, 0, 102,
    793, 1, 0, 0, 0, 104, 797, 1, 0, 0, 0, 106, 801, 1, 0, 0, 0, 108, 804, 1, 0, 0, 0, 110, 808, 1, 0,
    0, 0, 112, 810, 1, 0, 0, 0, 114, 820, 1, 0, 0, 0, 116, 832, 1, 0, 0, 0, 118, 841, 1, 0, 0, 0, 120,
    849, 1, 0, 0, 0, 122, 858, 1, 0, 0, 0, 124, 866, 1, 0, 0, 0, 126, 873, 1, 0, 0, 0, 128, 879, 1, 0,
    0, 0, 130, 889, 1, 0, 0, 0, 132, 893, 1, 0, 0, 0, 134, 900, 1, 0, 0, 0, 136, 904, 1, 0, 0, 0, 138,
    908, 1, 0, 0, 0, 140, 918, 1, 0, 0, 0, 142, 930, 1, 0, 0, 0, 144, 933, 1, 0, 0, 0, 146, 943, 1, 0,
    0, 0, 148, 948, 1, 0, 0, 0, 150, 953, 1, 0, 0, 0, 152, 959, 1, 0, 0, 0, 154, 966, 1, 0, 0, 0, 156,
    972, 1, 0, 0, 0, 158, 975, 1, 0, 0, 0, 160, 980, 1, 0, 0, 0, 162, 985, 1, 0, 0, 0, 164, 989, 1, 0,
    0, 0, 166, 995, 1, 0, 0, 0, 168, 1003, 1, 0, 0, 0, 170, 1007, 1, 0, 0, 0, 172, 1010, 1, 0, 0, 0, 174,
    1016, 1, 0, 0, 0, 176, 1022, 1, 0, 0, 0, 178, 1029, 1, 0, 0, 0, 180, 1038, 1, 0, 0, 0, 182, 1044,
    1, 0, 0, 0, 184, 1047, 1, 0, 0, 0, 186, 1050, 1, 0, 0, 0, 188, 1053, 1, 0, 0, 0, 190, 1061, 1, 0,
    0, 0, 192, 1069, 1, 0, 0, 0, 194, 1073, 1, 0, 0, 0, 196, 1077, 1, 0, 0, 0, 198, 1081, 1, 0, 0, 0,
    200, 1089, 1, 0, 0, 0, 202, 1095, 1, 0, 0, 0, 204, 1102, 1, 0, 0, 0, 206, 1112, 1, 0, 0, 0, 208,
    1117, 1, 0, 0, 0, 210, 1122, 1, 0, 0, 0, 212, 1132, 1, 0, 0, 0, 214, 1139, 1, 0, 0, 0, 216, 1149,
    1, 0, 0, 0, 218, 1159, 1, 0, 0, 0, 220, 1166, 1, 0, 0, 0, 222, 1174, 1, 0, 0, 0, 224, 1184, 1, 0,
    0, 0, 226, 1193, 1, 0, 0, 0, 228, 1198, 1, 0, 0, 0, 230, 1205, 1, 0, 0, 0, 232, 1216, 1, 0, 0, 0,
    234, 1221, 1, 0, 0, 0, 236, 1227, 1, 0, 0, 0, 238, 1235, 1, 0, 0, 0, 240, 1244, 1, 0, 0, 0, 242,
    1251, 1, 0, 0, 0, 244, 1257, 1, 0, 0, 0, 246, 1266, 1, 0, 0, 0, 248, 1274, 1, 0, 0, 0, 250, 1283,
    1, 0, 0, 0, 252, 1292, 1, 0, 0, 0, 254, 1298, 1, 0, 0, 0, 256, 1303, 1, 0, 0, 0, 258, 1309, 1, 0,
    0, 0, 260, 1318, 1, 0, 0, 0, 262, 1325, 1, 0, 0, 0, 264, 1334, 1, 0, 0, 0, 266, 1346, 1, 0, 0, 0,
    268, 1354, 1, 0, 0, 0, 270, 1361, 1, 0, 0, 0, 272, 1368, 1, 0, 0, 0, 274, 1372, 1, 0, 0, 0, 276,
    1380, 1, 0, 0, 0, 278, 1388, 1, 0, 0, 0, 280, 1392, 1, 0, 0, 0, 282, 1404, 1, 0, 0, 0, 284, 1406,
    1, 0, 0, 0, 286, 1423, 1, 0, 0, 0, 288, 1428, 1, 0, 0, 0, 290, 1442, 1, 0, 0, 0, 292, 1444, 1, 0,
    0, 0, 294, 1446, 1, 0, 0, 0, 296, 1448, 1, 0, 0, 0, 298, 1452, 1, 0, 0, 0, 300, 1468, 1, 0, 0, 0,
    302, 1470, 1, 0, 0, 0, 304, 1474, 1, 0, 0, 0, 306, 1490, 1, 0, 0, 0, 308, 1492, 1, 0, 0, 0, 310,
    1503, 1, 0, 0, 0, 312, 1505, 1, 0, 0, 0, 314, 1529, 1, 0, 0, 0, 316, 1571, 1, 0, 0, 0, 318, 1573,
    1, 0, 0, 0, 320, 1576, 1, 0, 0, 0, 322, 1579, 1, 0, 0, 0, 324, 1588, 1, 0, 0, 0, 326, 1590, 1, 0,
    0, 0, 328, 1597, 1, 0, 0, 0, 330, 1606, 1, 0, 0, 0, 332, 1608, 1, 0, 0, 0, 334, 1610, 1, 0, 0, 0,
    336, 1612, 1, 0, 0, 0, 338, 1614, 1, 0, 0, 0, 340, 1616, 1, 0, 0, 0, 342, 1618, 1, 0, 0, 0, 344,
    1620, 1, 0, 0, 0, 346, 1622, 1, 0, 0, 0, 348, 1624, 1, 0, 0, 0, 350, 1629, 1, 0, 0, 0, 352, 1634,
    1, 0, 0, 0, 354, 1639, 1, 0, 0, 0, 356, 1644, 1, 0, 0, 0, 358, 1649, 1, 0, 0, 0, 360, 1654, 1, 0,
    0, 0, 362, 1658, 1, 0, 0, 0, 364, 1662, 1, 0, 0, 0, 366, 1666, 1, 0, 0, 0, 368, 1670, 1, 0, 0, 0,
    370, 1674, 1, 0, 0, 0, 372, 1678, 1, 0, 0, 0, 374, 1682, 1, 0, 0, 0, 376, 1686, 1, 0, 0, 0, 378,
    1690, 1, 0, 0, 0, 380, 1694, 1, 0, 0, 0, 382, 1698, 1, 0, 0, 0, 384, 1705, 1, 0, 0, 0, 386, 1709,
    1, 0, 0, 0, 388, 1713, 1, 0, 0, 0, 390, 1717, 1, 0, 0, 0, 392, 1721, 1, 0, 0, 0, 394, 1725, 1, 0,
    0, 0, 396, 1729, 1, 0, 0, 0, 398, 1733, 1, 0, 0, 0, 400, 1737, 1, 0, 0, 0, 402, 1741, 1, 0, 0, 0,
    404, 1745, 1, 0, 0, 0, 406, 1749, 1, 0, 0, 0, 408, 1753, 1, 0, 0, 0, 410, 1757, 1, 0, 0, 0, 412,
    1761, 1, 0, 0, 0, 414, 1765, 1, 0, 0, 0, 416, 1769, 1, 0, 0, 0, 418, 1773, 1, 0, 0, 0, 420, 1780,
    1, 0, 0, 0, 422, 1784, 1, 0, 0, 0, 424, 1788, 1, 0, 0, 0, 426, 1792, 1, 0, 0, 0, 428, 1796, 1, 0,
    0, 0, 430, 1800, 1, 0, 0, 0, 432, 1804, 1, 0, 0, 0, 434, 1808, 1, 0, 0, 0, 436, 1812, 1, 0, 0, 0,
    438, 1816, 1, 0, 0, 0, 440, 1820, 1, 0, 0, 0, 442, 1824, 1, 0, 0, 0, 444, 1828, 1, 0, 0, 0, 446,
    1832, 1, 0, 0, 0, 448, 1836, 1, 0, 0, 0, 450, 1840, 1, 0, 0, 0, 452, 1845, 1, 0, 0, 0, 454, 1850,
    1, 0, 0, 0, 456, 1854, 1, 0, 0, 0, 458, 1858, 1, 0, 0, 0, 460, 1862, 1, 0, 0, 0, 462, 1866, 1, 0,
    0, 0, 464, 1870, 1, 0, 0, 0, 466, 1874, 1, 0, 0, 0, 468, 1878, 1, 0, 0, 0, 470, 1882, 1, 0, 0, 0,
    472, 1886, 1, 0, 0, 0, 474, 1890, 1, 0, 0, 0, 476, 1894, 1, 0, 0, 0, 478, 1898, 1, 0, 0, 0, 480,
    1902, 1, 0, 0, 0, 482, 1906, 1, 0, 0, 0, 484, 1910, 1, 0, 0, 0, 486, 1914, 1, 0, 0, 0, 488, 1918,
    1, 0, 0, 0, 490, 1922, 1, 0, 0, 0, 492, 1926, 1, 0, 0, 0, 494, 1930, 1, 0, 0, 0, 496, 1934, 1, 0,
    0, 0, 498, 1938, 1, 0, 0, 0, 500, 1942, 1, 0, 0, 0, 502, 1946, 1, 0, 0, 0, 504, 1950, 1, 0, 0, 0,
    506, 1954, 1, 0, 0, 0, 508, 1958, 1, 0, 0, 0, 510, 1962, 1, 0, 0, 0, 512, 1966, 1, 0, 0, 0, 514,
    1970, 1, 0, 0, 0, 516, 1974, 1, 0, 0, 0, 518, 1978, 1, 0, 0, 0, 520, 1982, 1, 0, 0, 0, 522, 1986,
    1, 0, 0, 0, 524, 1990, 1, 0, 0, 0, 526, 1994, 1, 0, 0, 0, 528, 1998, 1, 0, 0, 0, 530, 2002, 1, 0,
    0, 0, 532, 2006, 1, 0, 0, 0, 534, 2010, 1, 0, 0, 0, 536, 2014, 1, 0, 0, 0, 538, 2018, 1, 0, 0, 0,
    540, 2022, 1, 0, 0, 0, 542, 2026, 1, 0, 0, 0, 544, 2030, 1, 0, 0, 0, 546, 2034, 1, 0, 0, 0, 548,
    2038, 1, 0, 0, 0, 550, 2042, 1, 0, 0, 0, 552, 2046, 1, 0, 0, 0, 554, 2050, 1, 0, 0, 0, 556, 2054,
    1, 0, 0, 0, 558, 2058, 1, 0, 0, 0, 560, 2062, 1, 0, 0, 0, 562, 2066, 1, 0, 0, 0, 564, 2070, 1, 0,
    0, 0, 566, 2074, 1, 0, 0, 0, 568, 2078, 1, 0, 0, 0, 570, 2082, 1, 0, 0, 0, 572, 2086, 1, 0, 0, 0,
    574, 2090, 1, 0, 0, 0, 576, 2094, 1, 0, 0, 0, 578, 2098, 1, 0, 0, 0, 580, 2102, 1, 0, 0, 0, 582,
    2106, 1, 0, 0, 0, 584, 2110, 1, 0, 0, 0, 586, 2114, 1, 0, 0, 0, 588, 2118, 1, 0, 0, 0, 590, 2122,
    1, 0, 0, 0, 592, 2128, 1, 0, 0, 0, 594, 2132, 1, 0, 0, 0, 596, 2136, 1, 0, 0, 0, 598, 2140, 1, 0,
    0, 0, 600, 2144, 1, 0, 0, 0, 602, 2152, 1, 0, 0, 0, 604, 2156, 1, 0, 0, 0, 606, 2158, 1, 0, 0, 0,
    608, 2164, 1, 0, 0, 0, 610, 2173, 1, 0, 0, 0, 612, 2177, 1, 0, 0, 0, 614, 2185, 1, 0, 0, 0, 616,
    2187, 1, 0, 0, 0, 618, 2192, 1, 0, 0, 0, 620, 621, 5, 35, 0, 0, 621, 622, 5, 33, 0, 0, 622, 626,
    1, 0, 0, 0, 623, 625, 8, 0, 0, 0, 624, 623, 1, 0, 0, 0, 625, 628, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0,
    626, 627, 1, 0, 0, 0, 627, 5, 1, 0, 0, 0, 628, 626, 1, 0, 0, 0, 629, 630, 5, 47, 0, 0, 630, 631, 5,
    42, 0, 0, 631, 636, 1, 0, 0, 0, 632, 635, 3, 6, 1, 0, 633, 635, 9, 0, 0, 0, 634, 632, 1, 0, 0, 0, 634,
    633, 1, 0, 0, 0, 635, 638, 1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 637, 639, 1, 0,
    0, 0, 638, 636, 1, 0, 0, 0, 639, 640, 5, 42, 0, 0, 640, 641, 5, 47, 0, 0, 641, 642, 1, 0, 0, 0, 642,
    643, 6, 1, 0, 0, 643, 7, 1, 0, 0, 0, 644, 645, 5, 47, 0, 0, 645, 646, 5, 47, 0, 0, 646, 650, 1, 0,
    0, 0, 647, 649, 8, 0, 0, 0, 648, 647, 1, 0, 0, 0, 649, 652, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 650,
    651, 1, 0, 0, 0, 651, 653, 1, 0, 0, 0, 652, 650, 1, 0, 0, 0, 653, 654, 6, 2, 0, 0, 654, 9, 1, 0, 0,
    0, 655, 656, 7, 1, 0, 0, 656, 657, 1, 0, 0, 0, 657, 658, 6, 3, 0, 0, 658, 11, 1, 0, 0, 0, 659, 665,
    5, 10, 0, 0, 660, 662, 5, 13, 0, 0, 661, 663, 5, 10, 0, 0, 662, 661, 1, 0, 0, 0, 662, 663, 1, 0, 0,
    0, 663, 665, 1, 0, 0, 0, 664, 659, 1, 0, 0, 0, 664, 660, 1, 0, 0, 0, 665, 13, 1, 0, 0, 0, 666, 670,
    3, 6, 1, 0, 667, 670, 3, 8, 2, 0, 668, 670, 3, 10, 3, 0, 669, 666, 1, 0, 0, 0, 669, 667, 1, 0, 0, 0,
    669, 668, 1, 0, 0, 0, 670, 15, 1, 0, 0, 0, 671, 672, 5, 46, 0, 0, 672, 673, 5, 46, 0, 0, 673, 674,
    5, 46, 0, 0, 674, 17, 1, 0, 0, 0, 675, 676, 5, 46, 0, 0, 676, 19, 1, 0, 0, 0, 677, 678, 5, 44, 0, 0,
    678, 21, 1, 0, 0, 0, 679, 680, 5, 40, 0, 0, 680, 681, 1, 0, 0, 0, 681, 682, 6, 9, 1, 0, 682, 23, 1,
    0, 0, 0, 683, 684, 5, 41, 0, 0, 684, 685, 1, 0, 0, 0, 685, 686, 6, 10, 2, 0, 686, 25, 1, 0, 0, 0, 687,
    688, 5, 91, 0, 0, 688, 689, 1, 0, 0, 0, 689, 690, 6, 11, 1, 0, 690, 27, 1, 0, 0, 0, 691, 692, 5, 93,
    0, 0, 692, 693, 1, 0, 0, 0, 693, 694, 6, 12, 2, 0, 694, 29, 1, 0, 0, 0, 695, 696, 5, 123, 0, 0, 696,
    697, 1, 0, 0, 0, 697, 698, 6, 13, 3, 0, 698, 31, 1, 0, 0, 0, 699, 700, 5, 125, 0, 0, 700, 701, 1,
    0, 0, 0, 701, 702, 6, 14, 2, 0, 702, 33, 1, 0, 0, 0, 703, 704, 5, 42, 0, 0, 704, 35, 1, 0, 0, 0, 705,
    706, 5, 37, 0, 0, 706, 37, 1, 0, 0, 0, 707, 708, 5, 47, 0, 0, 708, 39, 1, 0, 0, 0, 709, 710, 5, 43,
    0, 0, 710, 41, 1, 0, 0, 0, 711, 712, 5, 45, 0, 0, 712, 43, 1, 0, 0, 0, 713, 714, 5, 43, 0, 0, 714,
    715, 5, 43, 0, 0, 715, 45, 1, 0, 0, 0, 716, 717, 5, 45, 0, 0, 717, 718, 5, 45, 0, 0, 718, 47, 1, 0,
    0, 0, 719, 720, 5, 38, 0, 0, 720, 721, 5, 38, 0, 0, 721, 49, 1, 0, 0, 0, 722, 723, 5, 124, 0, 0, 723,
    724, 5, 124, 0, 0, 724, 51, 1, 0, 0, 0, 725, 726, 5, 33, 0, 0, 726, 727, 3, 14, 5, 0, 727, 53, 1,
    0, 0, 0, 728, 729, 5, 33, 0, 0, 729, 55, 1, 0, 0, 0, 730, 731, 5, 58, 0, 0, 731, 57, 1, 0, 0, 0, 732,
    733, 5, 59, 0, 0, 733, 59, 1, 0, 0, 0, 734, 735, 5, 61, 0, 0, 735, 61, 1, 0, 0, 0, 736, 737, 5, 43,
    0, 0, 737, 738, 5, 61, 0, 0, 738, 63, 1, 0, 0, 0, 739, 740, 5, 45, 0, 0, 740, 741, 5, 61, 0, 0, 741,
    65, 1, 0, 0, 0, 742, 743, 5, 42, 0, 0, 743, 744, 5, 61, 0, 0, 744, 67, 1, 0, 0, 0, 745, 746, 5, 47,
    0, 0, 746, 747, 5, 61, 0, 0, 747, 69, 1, 0, 0, 0, 748, 749, 5, 37, 0, 0, 749, 750, 5, 61, 0, 0, 750,
    71, 1, 0, 0, 0, 751, 752, 5, 45, 0, 0, 752, 753, 5, 62, 0, 0, 753, 73, 1, 0, 0, 0, 754, 755, 5, 61,
    0, 0, 755, 756, 5, 62, 0, 0, 756, 75, 1, 0, 0, 0, 757, 758, 5, 46, 0, 0, 758, 759, 5, 46, 0, 0, 759,
    77, 1, 0, 0, 0, 760, 761, 5, 58, 0, 0, 761, 762, 5, 58, 0, 0, 762, 79, 1, 0, 0, 0, 763, 764, 5, 59,
    0, 0, 764, 765, 5, 59, 0, 0, 765, 81, 1, 0, 0, 0, 766, 767, 5, 35, 0, 0, 767, 83, 1, 0, 0, 0, 768,
    769, 5, 64, 0, 0, 769, 85, 1, 0, 0, 0, 770, 773, 3, 84, 40, 0, 771, 774, 3, 14, 5, 0, 772, 774, 3,
    12, 4, 0, 773, 771, 1, 0, 0, 0, 773, 772, 1, 0, 0, 0, 774, 87, 1, 0, 0, 0, 775, 776, 5, 63, 0, 0, 776,
    777, 3, 14, 5, 0, 777, 89, 1, 0, 0, 0, 778, 779, 5, 63, 0, 0, 779, 91, 1, 0, 0, 0, 780, 781, 5, 60,
    0, 0, 781, 93, 1, 0, 0, 0, 782, 783, 5, 62, 0, 0, 783, 95, 1, 0, 0, 0, 784, 785, 5, 60, 0, 0, 785,
    786, 5, 61, 0, 0, 786, 97, 1, 0, 0, 0, 787, 788, 5, 62, 0, 0, 788, 789, 5, 61, 0, 0, 789, 99, 1, 0,
    0, 0, 790, 791, 5, 33, 0, 0, 791, 792, 5, 61, 0, 0, 792, 101, 1, 0, 0, 0, 793, 794, 5, 33, 0, 0, 794,
    795, 5, 61, 0, 0, 795, 796, 5, 61, 0, 0, 796, 103, 1, 0, 0, 0, 797, 798, 5, 97, 0, 0, 798, 799, 5,
    115, 0, 0, 799, 800, 5, 63, 0, 0, 800, 105, 1, 0, 0, 0, 801, 802, 5, 61, 0, 0, 802, 803, 5, 61, 0,
    0, 803, 107, 1, 0, 0, 0, 804, 805, 5, 61, 0, 0, 805, 806, 5, 61, 0, 0, 806, 807, 5, 61, 0, 0, 807,
    109, 1, 0, 0, 0, 808, 809, 5, 39, 0, 0, 809, 111, 1, 0, 0, 0, 810, 811, 5, 114, 0, 0, 811, 812, 5,
    101, 0, 0, 812, 813, 5, 116, 0, 0, 813, 814, 5, 117, 0, 0, 814, 815, 5, 114, 0, 0, 815, 816, 5,
    110, 0, 0, 816, 817, 5, 64, 0, 0, 817, 818, 1, 0, 0, 0, 818, 819, 3, 314, 155, 0, 819, 113, 1, 0,
    0, 0, 820, 821, 5, 99, 0, 0, 821, 822, 5, 111, 0, 0, 822, 823, 5, 110, 0, 0, 823, 824, 5, 116, 0,
    0, 824, 825, 5, 105, 0, 0, 825, 826, 5, 110, 0, 0, 826, 827, 5, 117, 0, 0, 827, 828, 5, 101, 0,
    0, 828, 829, 5, 64, 0, 0, 829, 830, 1, 0, 0, 0, 830, 831, 3, 314, 155, 0, 831, 115, 1, 0, 0, 0, 832,
    833, 5, 98, 0, 0, 833, 834, 5, 114, 0, 0, 834, 835, 5, 101, 0, 0, 835, 836, 5, 97, 0, 0, 836, 837,
    5, 107, 0, 0, 837, 838, 5, 64, 0, 0, 838, 839, 1, 0, 0, 0, 839, 840, 3, 314, 155, 0, 840, 117, 1,
    0, 0, 0, 841, 842, 5, 116, 0, 0, 842, 843, 5, 104, 0, 0, 843, 844, 5, 105, 0, 0, 844, 845, 5, 115,
    0, 0, 845, 846, 5, 64, 0, 0, 846, 847, 1, 0, 0, 0, 847, 848, 3, 314, 155, 0, 848, 119, 1, 0, 0, 0,
    849, 850, 5, 115, 0, 0, 850, 851, 5, 117, 0, 0, 851, 852, 5, 112, 0, 0, 852, 853, 5, 101, 0, 0,
    853, 854, 5, 114, 0, 0, 854, 855, 5, 64, 0, 0, 855, 856, 1, 0, 0, 0, 856, 857, 3, 314, 155, 0, 857,
    121, 1, 0, 0, 0, 858, 859, 5, 112, 0, 0, 859, 860, 5, 97, 0, 0, 860, 861, 5, 99, 0, 0, 861, 862,
    5, 107, 0, 0, 862, 863, 5, 97, 0, 0, 863, 864, 5, 103, 0, 0, 864, 865, 5, 101, 0, 0, 865, 123, 1,
    0, 0, 0, 866, 867, 5, 105, 0, 0, 867, 868, 5, 109, 0, 0, 868, 869, 5, 112, 0, 0, 869, 870, 5, 111,
    0, 0, 870, 871, 5, 114, 0, 0, 871, 872, 5, 116, 0, 0, 872, 125, 1, 0, 0, 0, 873, 874, 5, 99, 0, 0,
    874, 875, 5, 108, 0, 0, 875, 876, 5, 97, 0, 0, 876, 877, 5, 115, 0, 0, 877, 878, 5, 115, 0, 0, 878,
    127, 1, 0, 0, 0, 879, 880, 5, 105, 0, 0, 880, 881, 5, 110, 0, 0, 881, 882, 5, 116, 0, 0, 882, 883,
    5, 101, 0, 0, 883, 884, 5, 114, 0, 0, 884, 885, 5, 102, 0, 0, 885, 886, 5, 97, 0, 0, 886, 887, 5,
    99, 0, 0, 887, 888, 5, 101, 0, 0, 888, 129, 1, 0, 0, 0, 889, 890, 5, 102, 0, 0, 890, 891, 5, 117,
    0, 0, 891, 892, 5, 110, 0, 0, 892, 131, 1, 0, 0, 0, 893, 894, 5, 111, 0, 0, 894, 895, 5, 98, 0, 0,
    895, 896, 5, 106, 0, 0, 896, 897, 5, 101, 0, 0, 897, 898, 5, 99, 0, 0, 898, 899, 5, 116, 0, 0, 899,
    133, 1, 0, 0, 0, 900, 901, 5, 118, 0, 0, 901, 902, 5, 97, 0, 0, 902, 903, 5, 108, 0, 0, 903, 135,
    1, 0, 0, 0, 904, 905, 5, 118, 0, 0, 905, 906, 5, 97, 0, 0, 906, 907, 5, 114, 0, 0, 907, 137, 1, 0,
    0, 0, 908, 909, 5, 116, 0, 0, 909, 910, 5, 121, 0, 0, 910, 911, 5, 112, 0, 0, 911, 912, 5, 101,
    0, 0, 912, 913, 5, 97, 0, 0, 913, 914, 5, 108, 0, 0, 914, 915, 5, 105, 0, 0, 915, 916, 5, 97, 0,
    0, 916, 917, 5, 115, 0, 0, 917, 139, 1, 0, 0, 0, 918, 919, 5, 99, 0, 0, 919, 920, 5, 111, 0, 0, 920,
    921, 5, 110, 0, 0, 921, 922, 5, 115, 0, 0, 922, 923, 5, 116, 0, 0, 923, 924, 5, 114, 0, 0, 924,
    925, 5, 117, 0, 0, 925, 926, 5, 99, 0, 0, 926, 927, 5, 116, 0, 0, 927, 928, 5, 111, 0, 0, 928, 929,
    5, 114, 0, 0, 929, 141, 1, 0, 0, 0, 930, 931, 5, 98, 0, 0, 931, 932, 5, 121, 0, 0, 932, 143, 1, 0,
    0, 0, 933, 934, 5, 99, 0, 0, 934, 935, 5, 111, 0, 0, 935, 936, 5, 109, 0, 0, 936, 937, 5, 112, 0,
    0, 937, 938, 5, 97, 0, 0, 938, 939, 5, 110, 0, 0, 939, 940, 5, 105, 0, 0, 940, 941, 5, 111, 0, 0,
    941, 942, 5, 110, 0, 0, 942, 145, 1, 0, 0, 0, 943, 944, 5, 105, 0, 0, 944, 945, 5, 110, 0, 0, 945,
    946, 5, 105, 0, 0, 946, 947, 5, 116, 0, 0, 947, 147, 1, 0, 0, 0, 948, 949, 5, 116, 0, 0, 949, 950,
    5, 104, 0, 0, 950, 951, 5, 105, 0, 0, 951, 952, 5, 115, 0, 0, 952, 149, 1, 0, 0, 0, 953, 954, 5,
    115, 0, 0, 954, 955, 5, 117, 0, 0, 955, 956, 5, 112, 0, 0, 956, 957, 5, 101, 0, 0, 957, 958, 5,
    114, 0, 0, 958, 151, 1, 0, 0, 0, 959, 960, 5, 116, 0, 0, 960, 961, 5, 121, 0, 0, 961, 962, 5, 112,
    0, 0, 962, 963, 5, 101, 0, 0, 963, 964, 5, 111, 0, 0, 964, 965, 5, 102, 0, 0, 965, 153, 1, 0, 0,
    0, 966, 967, 5, 119, 0, 0, 967, 968, 5, 104, 0, 0, 968, 969, 5, 101, 0, 0, 969, 970, 5, 114, 0,
    0, 970, 971, 5, 101, 0, 0, 971, 155, 1, 0, 0, 0, 972, 973, 5, 105, 0, 0, 973, 974, 5, 102, 0, 0,
    974, 157, 1, 0, 0, 0, 975, 976, 5, 101, 0, 0, 976, 977, 5, 108, 0, 0, 977, 978, 5, 115, 0, 0, 978,
    979, 5, 101, 0, 0, 979, 159, 1, 0, 0, 0, 980, 981, 5, 119, 0, 0, 981, 982, 5, 104, 0, 0, 982, 983,
    5, 101, 0, 0, 983, 984, 5, 110, 0, 0, 984, 161, 1, 0, 0, 0, 985, 986, 5, 116, 0, 0, 986, 987, 5,
    114, 0, 0, 987, 988, 5, 121, 0, 0, 988, 163, 1, 0, 0, 0, 989, 990, 5, 99, 0, 0, 990, 991, 5, 97,
    0, 0, 991, 992, 5, 116, 0, 0, 992, 993, 5, 99, 0, 0, 993, 994, 5, 104, 0, 0, 994, 165, 1, 0, 0, 0,
    995, 996, 5, 102, 0, 0, 996, 997, 5, 105, 0, 0, 997, 998, 5, 110, 0, 0, 998, 999, 5, 97, 0, 0, 999,
    1000, 5, 108, 0, 0, 1000, 1001, 5, 108, 0, 0, 1001, 1002, 5, 121, 0, 0, 1002, 167, 1, 0, 0, 0,
    1003, 1004, 5, 102, 0, 0, 1004, 1005, 5, 111, 0, 0, 1005, 1006, 5, 114, 0, 0, 1006, 169, 1, 0,
    0, 0, 1007, 1008, 5, 100, 0, 0, 1008, 1009, 5, 111, 0, 0, 1009, 171, 1, 0, 0, 0, 1010, 1011, 5,
    119, 0, 0, 1011, 1012, 5, 104, 0, 0, 1012, 1013, 5, 105, 0, 0, 1013, 1014, 5, 108, 0, 0, 1014,
    1015, 5, 101, 0, 0, 1015, 173, 1, 0, 0, 0, 1016, 1017, 5, 116, 0, 0, 1017, 1018, 5, 104, 0, 0,
    1018, 1019, 5, 114, 0, 0, 1019, 1020, 5, 111, 0, 0, 1020, 1021, 5, 119, 0, 0, 1021, 175, 1, 0,
    0, 0, 1022, 1023, 5, 114, 0, 0, 1023, 1024, 5, 101, 0, 0, 1024, 1025, 5, 116, 0, 0, 1025, 1026,
    5, 117, 0, 0, 1026, 1027, 5, 114, 0, 0, 1027, 1028, 5, 110, 0, 0, 1028, 177, 1, 0, 0, 0, 1029,
    1030, 5, 99, 0, 0, 1030, 1031, 5, 111, 0, 0, 1031, 1032, 5, 110, 0, 0, 1032, 1033, 5, 116, 0,
    0, 1033, 1034, 5, 105, 0, 0, 1034, 1035, 5, 110, 0, 0, 1035, 1036, 5, 117, 0, 0, 1036, 1037,
    5, 101, 0, 0, 1037, 179, 1, 0, 0, 0, 1038, 1039, 5, 98, 0, 0, 1039, 1040, 5, 114, 0, 0, 1040, 1041,
    5, 101, 0, 0, 1041, 1042, 5, 97, 0, 0, 1042, 1043, 5, 107, 0, 0, 1043, 181, 1, 0, 0, 0, 1044, 1045,
    5, 97, 0, 0, 1045, 1046, 5, 115, 0, 0, 1046, 183, 1, 0, 0, 0, 1047, 1048, 5, 105, 0, 0, 1048, 1049,
    5, 115, 0, 0, 1049, 185, 1, 0, 0, 0, 1050, 1051, 5, 105, 0, 0, 1051, 1052, 5, 110, 0, 0, 1052,
    187, 1, 0, 0, 0, 1053, 1054, 5, 33, 0, 0, 1054, 1055, 5, 105, 0, 0, 1055, 1056, 5, 115, 0, 0, 1056,
    1059, 1, 0, 0, 0, 1057, 1060, 3, 14, 5, 0, 1058, 1060, 3, 12, 4, 0, 1059, 1057, 1, 0, 0, 0, 1059,
    1058, 1, 0, 0, 0, 1060, 189, 1, 0, 0, 0, 1061, 1062, 5, 33, 0, 0, 1062, 1063, 5, 105, 0, 0, 1063,
    1064, 5, 110, 0, 0, 1064, 1067, 1, 0, 0, 0, 1065, 1068, 3, 14, 5, 0, 1066, 1068, 3, 12, 4, 0, 1067,
    1065, 1, 0, 0, 0, 1067, 1066, 1, 0, 0, 0, 1068, 191, 1, 0, 0, 0, 1069, 1070, 5, 111, 0, 0, 1070,
    1071, 5, 117, 0, 0, 1071, 1072, 5, 116, 0, 0, 1072, 193, 1, 0, 0, 0, 1073, 1074, 5, 103, 0, 0,
    1074, 1075, 5, 101, 0, 0, 1075, 1076, 5, 116, 0, 0, 1076, 195, 1, 0, 0, 0, 1077, 1078, 5, 115,
    0, 0, 1078, 1079, 5, 101, 0, 0, 1079, 1080, 5, 116, 0, 0, 1080, 197, 1, 0, 0, 0, 1081, 1082, 5,
    100, 0, 0, 1082, 1083, 5, 121, 0, 0, 1083, 1084, 5, 110, 0, 0, 1084, 1085, 5, 97, 0, 0, 1085,
    1086, 5, 109, 0, 0, 1086, 1087, 5, 105, 0, 0, 1087, 1088, 5, 99, 0, 0, 1088, 199, 1, 0, 0, 0, 1089,
    1090, 5, 64, 0, 0, 1090, 1091, 5, 102, 0, 0, 1091, 1092, 5, 105, 0, 0, 1092, 1093, 5, 108, 0,
    0, 1093, 1094, 5, 101, 0, 0, 1094, 201, 1, 0, 0, 0, 1095, 1096, 5, 64, 0, 0, 1096, 1097, 5, 102,
    0, 0, 1097, 1098, 5, 105, 0, 0, 1098, 1099, 5, 101, 0, 0, 1099, 1100, 5, 108, 0, 0, 1100, 1101,
    5, 100, 0, 0, 1101, 203, 1, 0, 0, 0, 1102, 1103, 5, 64, 0, 0, 1103, 1104, 5, 112, 0, 0, 1104, 1105,
    5, 114, 0, 0, 1105, 1106, 5, 111, 0, 0, 1106, 1107, 5, 112, 0, 0, 1107, 1108, 5, 101, 0, 0, 1108,
    1109, 5, 114, 0, 0, 1109, 1110, 5, 116, 0, 0, 1110, 1111, 5, 121, 0, 0, 1111, 205, 1, 0, 0, 0,
    1112, 1113, 5, 64, 0, 0, 1113, 1114, 5, 103, 0, 0, 1114, 1115, 5, 101, 0, 0, 1115, 1116, 5, 116,
    0, 0, 1116, 207, 1, 0, 0, 0, 1117, 1118, 5, 64, 0, 0, 1118, 1119, 5, 115, 0, 0, 1119, 1120, 5,
    101, 0, 0, 1120, 1121, 5, 116, 0, 0, 1121, 209, 1, 0, 0, 0, 1122, 1123, 5, 64, 0, 0, 1123, 1124,
    5, 114, 0, 0, 1124, 1125, 5, 101, 0, 0, 1125, 1126, 5, 99, 0, 0, 1126, 1127, 5, 101, 0, 0, 1127,
    1128, 5, 105, 0, 0, 1128, 1129, 5, 118, 0, 0, 1129, 1130, 5, 101, 0, 0, 1130, 1131, 5, 114, 0,
    0, 1131, 211, 1, 0, 0, 0, 1132, 1133, 5, 64, 0, 0, 1133, 1134, 5, 112, 0, 0, 1134, 1135, 5, 97,
    0, 0, 1135, 1136, 5, 114, 0, 0, 1136, 1137, 5, 97, 0, 0, 1137, 1138, 5, 109, 0, 0, 1138, 213,
    1, 0, 0, 0, 1139, 1140, 5, 64, 0, 0, 1140, 1141, 5, 115, 0, 0, 1141, 1142, 5, 101, 0, 0, 1142,
    1143, 5, 116, 0, 0, 1143, 1144, 5, 112, 0, 0, 1144, 1145, 5, 97, 0, 0, 1145, 1146, 5, 114, 0,
    0, 1146, 1147, 5, 97, 0, 0, 1147, 1148, 5, 109, 0, 0, 1148, 215, 1, 0, 0, 0, 1149, 1150, 5, 64,
    0, 0, 1150, 1151, 5, 100, 0, 0, 1151, 1152, 5, 101, 0, 0, 1152, 1153, 5, 108, 0, 0, 1153, 1154,
    5, 101, 0, 0, 1154, 1155, 5, 103, 0, 0, 1155, 1156, 5, 97, 0, 0, 1156, 1157, 5, 116, 0, 0, 1157,
    1158, 5, 101, 0, 0, 1158, 217, 1, 0, 0, 0, 1159, 1160, 5, 112, 0, 0, 1160, 1161, 5, 117, 0, 0,
    1161, 1162, 5, 98, 0, 0, 1162, 1163, 5, 108, 0, 0, 1163, 1164, 5, 105, 0, 0, 1164, 1165, 5, 99,
    0, 0, 1165, 219, 1, 0, 0, 0, 1166, 1167, 5, 112, 0, 0, 1167, 1168, 5, 114, 0, 0, 1168, 1169, 5,
    105, 0, 0, 1169, 1170, 5, 118, 0, 0, 1170, 1171, 5, 97, 0, 0, 1171, 1172, 5, 116, 0, 0, 1172,
    1173, 5, 101, 0, 0, 1173, 221, 1, 0, 0, 0, 1174, 1175, 5, 112, 0, 0, 1175, 1176, 5, 114, 0, 0,
    1176, 1177, 5, 111, 0, 0, 1177, 1178, 5, 116, 0, 0, 1178, 1179, 5, 101, 0, 0, 1179, 1180, 5,
    99, 0, 0, 1180, 1181, 5, 116, 0, 0, 1181, 1182, 5, 101, 0, 0, 1182, 1183, 5, 100, 0, 0, 1183,
    223, 1, 0, 0, 0, 1184, 1185, 5, 105, 0, 0, 1185, 1186, 5, 110, 0, 0, 1186, 1187, 5, 116, 0, 0,
    1187, 1188, 5, 101, 0, 0, 1188, 1189, 5, 114, 0, 0, 1189, 1190, 5, 110, 0, 0, 1190, 1191, 5,
    97, 0, 0, 1191, 1192, 5, 108, 0, 0, 1192, 225, 1, 0, 0, 0, 1193, 1194, 5, 101, 0, 0, 1194, 1195,
    5, 110, 0, 0, 1195, 1196, 5, 117, 0, 0, 1196, 1197, 5, 109, 0, 0, 1197, 227, 1, 0, 0, 0, 1198,
    1199, 5, 115, 0, 0, 1199, 1200, 5, 101, 0, 0, 1200, 1201, 5, 97, 0, 0, 1201, 1202, 5, 108, 0,
    0, 1202, 1203, 5, 101, 0, 0, 1203, 1204, 5, 100, 0, 0, 1204, 229, 1, 0, 0, 0, 1205, 1206, 5, 97,
    0, 0, 1206, 1207, 5, 110, 0, 0, 1207, 1208, 5, 110, 0, 0, 1208, 1209, 5, 111, 0, 0, 1209, 1210,
    5, 116, 0, 0, 1210, 1211, 5, 97, 0, 0, 1211, 1212, 5, 116, 0, 0, 1212, 1213, 5, 105, 0, 0, 1213,
    1214, 5, 111, 0, 0, 1214, 1215, 5, 110, 0, 0, 1215, 231, 1, 0, 0, 0, 1216, 1217, 5, 100, 0, 0,
    1217, 1218, 5, 97, 0, 0, 1218, 1219, 5, 116, 0, 0, 1219, 1220, 5, 97, 0, 0, 1220, 233, 1, 0, 0,
    0, 1221, 1222, 5, 105, 0, 0, 1222, 1223, 5, 110, 0, 0, 1223, 1224, 5, 110, 0, 0, 1224, 1225,
    5, 101, 0, 0, 1225, 1226, 5, 114, 0, 0, 1226, 235, 1, 0, 0, 0, 1227, 1228, 5, 116, 0, 0, 1228,
    1229, 5, 97, 0, 0, 1229, 1230, 5, 105, 0, 0, 1230, 1231, 5, 108, 0, 0, 1231, 1232, 5, 114, 0,
    0, 1232, 1233, 5, 101, 0, 0, 1233, 1234, 5, 99, 0, 0, 1234, 237, 1, 0, 0, 0, 1235, 1236, 5, 111,
    0, 0, 1236, 1237, 5, 112, 0, 0, 1237, 1238, 5, 101, 0, 0, 1238, 1239, 5, 114, 0, 0, 1239, 1240,
    5, 97, 0, 0, 1240, 1241, 5, 116, 0, 0, 1241, 1242, 5, 111, 0, 0, 1242, 1243, 5, 114, 0, 0, 1243,
    239, 1, 0, 0, 0, 1244, 1245, 5, 105, 0, 0, 1245, 1246, 5, 110, 0, 0, 1246, 1247, 5, 108, 0, 0,
    1247, 1248, 5, 105, 0, 0, 1248, 1249, 5, 110, 0, 0, 1249, 1250, 5, 101, 0, 0, 1250, 241, 1, 0,
    0, 0, 1251, 1252, 5, 105, 0, 0, 1252, 1253, 5, 110, 0, 0, 1253, 1254, 5, 102, 0, 0, 1254, 1255,
    5, 105, 0, 0, 1255, 1256, 5, 120, 0, 0, 1256, 243, 1, 0, 0, 0, 1257, 1258, 5, 101, 0, 0, 1258,
    1259, 5, 120, 0, 0, 1259, 1260, 5, 116, 0, 0, 1260, 1261, 5, 101, 0, 0, 1261, 1262, 5, 114, 0,
    0, 1262, 1263, 5, 110, 0, 0, 1263, 1264, 5, 97, 0, 0, 1264, 1265, 5, 108, 0, 0, 1265, 245, 1,
    0, 0, 0, 1266, 1267, 5, 115, 0, 0, 1267, 1268, 5, 117, 0, 0, 1268, 1269, 5, 115, 0, 0, 1269, 1270,
    5, 112, 0, 0, 1270, 1271, 5, 101, 0, 0, 1271, 1272, 5, 110, 0, 0, 1272, 1273, 5, 100, 0, 0, 1273,
    247, 1, 0, 0, 0, 1274, 1275, 5, 111, 0, 0, 1275, 1276, 5, 118, 0, 0, 1276, 1277, 5, 101, 0, 0,
    1277, 1278, 5, 114, 0, 0, 1278, 1279, 5, 114, 0, 0, 1279, 1280, 5, 105, 0, 0, 1280, 1281, 5,
    100, 0, 0, 1281, 1282, 5, 101, 0, 0, 1282, 249, 1, 0, 0, 0, 1283, 1284, 5, 97, 0, 0, 1284, 1285,
    5, 98, 0, 0, 1285, 1286, 5, 115, 0, 0, 1286, 1287, 5, 116, 0, 0, 1287, 1288, 5, 114, 0, 0, 1288,
    1289, 5, 97, 0, 0, 1289, 1290, 5, 99, 0, 0, 1290, 1291, 5, 116, 0, 0, 1291, 251, 1, 0, 0, 0, 1292,
    1293, 5, 102, 0, 0, 1293, 1294, 5, 105, 0, 0, 1294, 1295, 5, 110, 0, 0, 1295, 1296, 5, 97, 0,
    0, 1296, 1297, 5, 108, 0, 0, 1297, 253, 1, 0, 0, 0, 1298, 1299, 5, 111, 0, 0, 1299, 1300, 5, 112,
    0, 0, 1300, 1301, 5, 101, 0, 0, 1301, 1302, 5, 110, 0, 0, 1302, 255, 1, 0, 0, 0, 1303, 1304, 5,
    99, 0, 0, 1304, 1305, 5, 111, 0, 0, 1305, 1306, 5, 110, 0, 0, 1306, 1307, 5, 115, 0, 0, 1307,
    1308, 5, 116, 0, 0, 1308, 257, 1, 0, 0, 0, 1309, 1310, 5, 108, 0, 0, 1310, 1311, 5, 97, 0, 0, 1311,
    1312, 5, 116, 0, 0, 1312, 1313, 5, 101, 0, 0, 1313, 1314, 5, 105, 0, 0, 1314, 1315, 5, 110, 0,
    0, 1315, 1316, 5, 105, 0, 0, 1316, 1317, 5, 116, 0, 0, 1317, 259, 1, 0, 0, 0, 1318, 1319, 5, 118,
    0, 0, 1319, 1320, 5, 97, 0, 0, 1320, 1321, 5, 114, 0, 0, 1321, 1322, 5, 97, 0, 0, 1322, 1323,
    5, 114, 0, 0, 1323, 1324, 5, 103, 0, 0, 1324, 261, 1, 0, 0, 0, 1325, 1326, 5, 110, 0, 0, 1326,
    1327, 5, 111, 0, 0, 1327, 1328, 5, 105, 0, 0, 1328, 1329, 5, 110, 0, 0, 1329, 1330, 5, 108, 0,
    0, 1330, 1331, 5, 105, 0, 0, 1331, 1332, 5, 110, 0, 0, 1332, 1333, 5, 101, 0, 0, 1333, 263, 1,
    0, 0, 0, 1334, 1335, 5, 99, 0, 0, 1335, 1336, 5, 114, 0, 0, 1336, 1337, 5, 111, 0, 0, 1337, 1338,
    5, 115, 0, 0, 1338, 1339, 5, 115, 0, 0, 1339, 1340, 5, 105, 0, 0, 1340, 1341, 5, 110, 0, 0, 1341,
    1342, 5, 108, 0, 0, 1342, 1343, 5, 105, 0, 0, 1343, 1344, 5, 110, 0, 0, 1344, 1345, 5, 101, 0,
    0, 1345, 265, 1, 0, 0, 0, 1346, 1347, 5, 114, 0, 0, 1347, 1348, 5, 101, 0, 0, 1348, 1349, 5, 105,
    0, 0, 1349, 1350, 5, 102, 0, 0, 1350, 1351, 5, 105, 0, 0, 1351, 1352, 5, 101, 0, 0, 1352, 1353,
    5, 100, 0, 0, 1353, 267, 1, 0, 0, 0, 1354, 1355, 5, 101, 0, 0, 1355, 1356, 5, 120, 0, 0, 1356,
    1357, 5, 112, 0, 0, 1357, 1358, 5, 101, 0, 0, 1358, 1359, 5, 99, 0, 0, 1359, 1360, 5, 116, 0,
    0, 1360, 269, 1, 0, 0, 0, 1361, 1362, 5, 97, 0, 0, 1362, 1363, 5, 99, 0, 0, 1363, 1364, 5, 116,
    0, 0, 1364, 1365, 5, 117, 0, 0, 1365, 1366, 5, 97, 0, 0, 1366, 1367, 5, 108, 0, 0, 1367, 271,
    1, 0, 0, 0, 1368, 1369, 5, 34, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 1371, 6, 134, 4, 0, 1371, 273,
    1, 0, 0, 0, 1372, 1373, 5, 34, 0, 0, 1373, 1374, 5, 34, 0, 0, 1374, 1375, 5, 34, 0, 0, 1375, 1376,
    1, 0, 0, 0, 1376, 1377, 6, 135, 5, 0, 1377, 275, 1, 0, 0, 0, 1378, 1381, 3, 278, 137, 0, 1379,
    1381, 3, 286, 141, 0, 1380, 1378, 1, 0, 0, 0, 1380, 1379, 1, 0, 0, 0, 1381, 277, 1, 0, 0, 0, 1382,
    1383, 3, 286, 141, 0, 1383, 1384, 7, 2, 0, 0, 1384, 1389, 1, 0, 0, 0, 1385, 1386, 3, 282, 139,
    0, 1386, 1387, 7, 2, 0, 0, 1387, 1389, 1, 0, 0, 0, 1388, 1382, 1, 0, 0, 0, 1388, 1385, 1, 0, 0,
    0, 1389, 279, 1, 0, 0, 0, 1390, 1393, 3, 294, 145, 0, 1391, 1393, 5, 95, 0, 0, 1392, 1390, 1,
    0, 0, 0, 1392, 1391, 1, 0, 0, 0, 1393, 281, 1, 0, 0, 0, 1394, 1398, 3, 294, 145, 0, 1395, 1397,
    3, 280, 138, 0, 1396, 1395, 1, 0, 0, 0, 1397, 1400, 1, 0, 0, 0, 1398, 1396, 1, 0, 0, 0, 1398, 1399,
    1, 0, 0, 0, 1399, 1401, 1, 0, 0, 0, 1400, 1398, 1, 0, 0, 0, 1401, 1402, 3, 294, 145, 0, 1402, 1405,
    1, 0, 0, 0, 1403, 1405, 3, 294, 145, 0, 1404, 1394, 1, 0, 0, 0, 1404, 1403, 1, 0, 0, 0, 1405, 283,
    1, 0, 0, 0, 1406, 1408, 7, 3, 0, 0, 1407, 1409, 7, 4, 0, 0, 1408, 1407, 1, 0, 0, 0, 1408, 1409,
    1, 0, 0, 0, 1409, 1410, 1, 0, 0, 0, 1410, 1411, 3, 282, 139, 0, 1411, 285, 1, 0, 0, 0, 1412, 1414,
    3, 282, 139, 0, 1413, 1412, 1, 0, 0, 0, 1413, 1414, 1, 0, 0, 0, 1414, 1415, 1, 0, 0, 0, 1415, 1416,
    5, 46, 0, 0, 1416, 1418, 3, 282, 139, 0, 1417, 1419, 3, 284, 140, 0, 1418, 1417, 1, 0, 0, 0, 1418,
    1419, 1, 0, 0, 0, 1419, 1424, 1, 0, 0, 0, 1420, 1421, 3, 282, 139, 0, 1421, 1422, 3, 284, 140,
    0, 1422, 1424, 1, 0, 0, 0, 1423, 1413, 1, 0, 0, 0, 1423, 1420, 1, 0, 0, 0, 1424, 287, 1, 0, 0, 0,
    1425, 1429, 3, 290, 143, 0, 1426, 1429, 3, 300, 148, 0, 1427, 1429, 3, 306, 151, 0, 1428, 1425,
    1, 0, 0, 0, 1428, 1426, 1, 0, 0, 0, 1428, 1427, 1, 0, 0, 0, 1429, 1430, 1, 0, 0, 0, 1430, 1431,
    5, 76, 0, 0, 1431, 289, 1, 0, 0, 0, 1432, 1436, 3, 296, 146, 0, 1433, 1435, 3, 280, 138, 0, 1434,
    1433, 1, 0, 0, 0, 1435, 1438, 1, 0, 0, 0, 1436, 1434, 1, 0, 0, 0, 1436, 1437, 1, 0, 0, 0, 1437,
    1439, 1, 0, 0, 0, 1438, 1436, 1, 0, 0, 0, 1439, 1440, 3, 294, 145, 0, 1440, 1443, 1, 0, 0, 0, 1441,
    1443, 3, 294, 145, 0, 1442, 1432, 1, 0, 0, 0, 1442, 1441, 1, 0, 0, 0, 1443, 291, 1, 0, 0, 0, 1444,
    1445, 3, 344, 170, 0, 1445, 293, 1, 0, 0, 0, 1446, 1447, 2, 48, 57, 0, 1447, 295, 1, 0, 0, 0, 1448,
    1449, 2, 49, 57, 0, 1449, 297, 1, 0, 0, 0, 1450, 1453, 3, 302, 149, 0, 1451, 1453, 5, 95, 0, 0,
    1452, 1450, 1, 0, 0, 0, 1452, 1451, 1, 0, 0, 0, 1453, 299, 1, 0, 0, 0, 1454, 1455, 5, 48, 0, 0,
    1455, 1456, 7, 5, 0, 0, 1456, 1460, 3, 302, 149, 0, 1457, 1459, 3, 298, 147, 0, 1458, 1457,
    1, 0, 0, 0, 1459, 1462, 1, 0, 0, 0, 1460, 1458, 1, 0, 0, 0, 1460, 1461, 1, 0, 0, 0, 1461, 1463,
    1, 0, 0, 0, 1462, 1460, 1, 0, 0, 0, 1463, 1464, 3, 302, 149, 0, 1464, 1469, 1, 0, 0, 0, 1465, 1466,
    5, 48, 0, 0, 1466, 1467, 7, 5, 0, 0, 1467, 1469, 3, 302, 149, 0, 1468, 1454, 1, 0, 0, 0, 1468,
    1465, 1, 0, 0, 0, 1469, 301, 1, 0, 0, 0, 1470, 1471, 7, 6, 0, 0, 1471, 303, 1, 0, 0, 0, 1472, 1475,
    3, 308, 152, 0, 1473, 1475, 5, 95, 0, 0, 1474, 1472, 1, 0, 0, 0, 1474, 1473, 1, 0, 0, 0, 1475,
    305, 1, 0, 0, 0, 1476, 1477, 5, 48, 0, 0, 1477, 1478, 7, 7, 0, 0, 1478, 1482, 3, 308, 152, 0, 1479,
    1481, 3, 304, 150, 0, 1480, 1479, 1, 0, 0, 0, 1481, 1484, 1, 0, 0, 0, 1482, 1480, 1, 0, 0, 0, 1482,
    1483, 1, 0, 0, 0, 1483, 1485, 1, 0, 0, 0, 1484, 1482, 1, 0, 0, 0, 1485, 1486, 3, 308, 152, 0, 1486,
    1491, 1, 0, 0, 0, 1487, 1488, 5, 48, 0, 0, 1488, 1489, 7, 7, 0, 0, 1489, 1491, 3, 308, 152, 0,
    1490, 1476, 1, 0, 0, 0, 1490, 1487, 1, 0, 0, 0, 1491, 307, 1, 0, 0, 0, 1492, 1493, 7, 8, 0, 0, 1493,
    309, 1, 0, 0, 0, 1494, 1495, 5, 116, 0, 0, 1495, 1496, 5, 114, 0, 0, 1496, 1497, 5, 117, 0, 0,
    1497, 1504, 5, 101, 0, 0, 1498, 1499, 5, 102, 0, 0, 1499, 1500, 5, 97, 0, 0, 1500, 1501, 5, 108,
    0, 0, 1501, 1502, 5, 115, 0, 0, 1502, 1504, 5, 101, 0, 0, 1503, 1494, 1, 0, 0, 0, 1503, 1498,
    1, 0, 0, 0, 1504, 311, 1, 0, 0, 0, 1505, 1506, 5, 110, 0, 0, 1506, 1507, 5, 117, 0, 0, 1507, 1508,
    5, 108, 0, 0, 1508, 1509, 5, 108, 0, 0, 1509, 313, 1, 0, 0, 0, 1510, 1513, 3, 330, 163, 0, 1511,
    1513, 5, 95, 0, 0, 1512, 1510, 1, 0, 0, 0, 1512, 1511, 1, 0, 0, 0, 1513, 1519, 1, 0, 0, 0, 1514,
    1518, 3, 330, 163, 0, 1515, 1518, 5, 95, 0, 0, 1516, 1518, 3, 292, 144, 0, 1517, 1514, 1, 0,
    0, 0, 1517, 1515, 1, 0, 0, 0, 1517, 1516, 1, 0, 0, 0, 1518, 1521, 1, 0, 0, 0, 1519, 1517, 1, 0,
    0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 1530, 1, 0, 0, 0, 1521, 1519, 1, 0, 0, 0, 1522, 1524, 5, 96,
    0, 0, 1523, 1525, 8, 9, 0, 0, 1524, 1523, 1, 0, 0, 0, 1525, 1526, 1, 0, 0, 0, 1526, 1524, 1, 0,
    0, 0, 1526, 1527, 1, 0, 0, 0, 1527, 1528, 1, 0, 0, 0, 1528, 1530, 5, 96, 0, 0, 1529, 1512, 1, 0,
    0, 0, 1529, 1522, 1, 0, 0, 0, 1530, 315, 1, 0, 0, 0, 1531, 1572, 3, 314, 155, 0, 1532, 1572, 3,
    250, 123, 0, 1533, 1572, 3, 230, 113, 0, 1534, 1572, 3, 142, 69, 0, 1535, 1572, 3, 164, 80,
    0, 1536, 1572, 3, 144, 70, 0, 1537, 1572, 3, 140, 68, 0, 1538, 1572, 3, 264, 130, 0, 1539, 1572,
    3, 232, 114, 0, 1540, 1572, 3, 198, 97, 0, 1541, 1572, 3, 226, 111, 0, 1542, 1572, 3, 244, 120,
    0, 1543, 1572, 3, 252, 124, 0, 1544, 1572, 3, 166, 81, 0, 1545, 1572, 3, 194, 95, 0, 1546, 1572,
    3, 124, 60, 0, 1547, 1572, 3, 242, 119, 0, 1548, 1572, 3, 146, 71, 0, 1549, 1572, 3, 240, 118,
    0, 1550, 1572, 3, 234, 115, 0, 1551, 1572, 3, 224, 110, 0, 1552, 1572, 3, 258, 127, 0, 1553,
    1572, 3, 262, 129, 0, 1554, 1572, 3, 254, 125, 0, 1555, 1572, 3, 238, 117, 0, 1556, 1572, 3,
    192, 94, 0, 1557, 1572, 3, 248, 122, 0, 1558, 1572, 3, 220, 108, 0, 1559, 1572, 3, 222, 109,
    0, 1560, 1572, 3, 218, 107, 0, 1561, 1572, 3, 266, 131, 0, 1562, 1572, 3, 228, 112, 0, 1563,
    1572, 3, 236, 116, 0, 1564, 1572, 3, 196, 96, 0, 1565, 1572, 3, 260, 128, 0, 1566, 1572, 3,
    154, 75, 0, 1567, 1572, 3, 268, 132, 0, 1568, 1572, 3, 270, 133, 0, 1569, 1572, 3, 256, 126,
    0, 1570, 1572, 3, 246, 121, 0, 1571, 1531, 1, 0, 0, 0, 1571, 1532, 1, 0, 0, 0, 1571, 1533, 1,
    0, 0, 0, 1571, 1534, 1, 0, 0, 0, 1571, 1535, 1, 0, 0, 0, 1571, 1536, 1, 0, 0, 0, 1571, 1537, 1,
    0, 0, 0, 1571, 1538, 1, 0, 0, 0, 1571, 1539, 1, 0, 0, 0, 1571, 1540, 1, 0, 0, 0, 1571, 1541, 1,
    0, 0, 0, 1571, 1542, 1, 0, 0, 0, 1571, 1543, 1, 0, 0, 0, 1571, 1544, 1, 0, 0, 0, 1571, 1545, 1,
    0, 0, 0, 1571, 1546, 1, 0, 0, 0, 1571, 1547, 1, 0, 0, 0, 1571, 1548, 1, 0, 0, 0, 1571, 1549, 1,
    0, 0, 0, 1571, 1550, 1, 0, 0, 0, 1571, 1551, 1, 0, 0, 0, 1571, 1552, 1, 0, 0, 0, 1571, 1553, 1,
    0, 0, 0, 1571, 1554, 1, 0, 0, 0, 1571, 1555, 1, 0, 0, 0, 1571, 1556, 1, 0, 0, 0, 1571, 1557, 1,
    0, 0, 0, 1571, 1558, 1, 0, 0, 0, 1571, 1559, 1, 0, 0, 0, 1571, 1560, 1, 0, 0, 0, 1571, 1561, 1,
    0, 0, 0, 1571, 1562, 1, 0, 0, 0, 1571, 1563, 1, 0, 0, 0, 1571, 1564, 1, 0, 0, 0, 1571, 1565, 1,
    0, 0, 0, 1571, 1566, 1, 0, 0, 0, 1571, 1567, 1, 0, 0, 0, 1571, 1568, 1, 0, 0, 0, 1571, 1569, 1,
    0, 0, 0, 1571, 1570, 1, 0, 0, 0, 1572, 317, 1, 0, 0, 0, 1573, 1574, 3, 316, 156, 0, 1574, 1575,
    5, 64, 0, 0, 1575, 319, 1, 0, 0, 0, 1576, 1577, 5, 36, 0, 0, 1577, 1578, 3, 316, 156, 0, 1578,
    321, 1, 0, 0, 0, 1579, 1582, 5, 39, 0, 0, 1580, 1583, 3, 324, 160, 0, 1581, 1583, 8, 10, 0, 0,
    1582, 1580, 1, 0, 0, 0, 1582, 1581, 1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 1585, 5, 39, 0, 0,
    1585, 323, 1, 0, 0, 0, 1586, 1589, 3, 326, 161, 0, 1587, 1589, 3, 328, 162, 0, 1588, 1586, 1,
    0, 0, 0, 1588, 1587, 1, 0, 0, 0, 1589, 325, 1, 0, 0, 0, 1590, 1591, 5, 92, 0, 0, 1591, 1592, 5,
    117, 0, 0, 1592, 1593, 3, 302, 149, 0, 1593, 1594, 3, 302, 149, 0, 1594, 1595, 3, 302, 149,
    0, 1595, 1596, 3, 302, 149, 0, 1596, 327, 1, 0, 0, 0, 1597, 1598, 5, 92, 0, 0, 1598, 1599, 7,
    11, 0, 0, 1599, 329, 1, 0, 0, 0, 1600, 1607, 3, 334, 165, 0, 1601, 1607, 3, 336, 166, 0, 1602,
    1607, 3, 338, 167, 0, 1603, 1607, 3, 340, 168, 0, 1604, 1607, 3, 342, 169, 0, 1605, 1607, 3,
    346, 171, 0, 1606, 1600, 1, 0, 0, 0, 1606, 1601, 1, 0, 0, 0, 1606, 1602, 1, 0, 0, 0, 1606, 1603,
    1, 0, 0, 0, 1606, 1604, 1, 0, 0, 0, 1606, 1605, 1, 0, 0, 0, 1607, 331, 1, 0, 0, 0, 1608, 1609, 9,
    0, 0, 0, 1609, 333, 1, 0, 0, 0, 1610, 1611, 7, 12, 0, 0, 1611, 335, 1, 0, 0, 0, 1612, 1613, 7, 13,
    0, 0, 1613, 337, 1, 0, 0, 0, 1614, 1615, 7, 14, 0, 0, 1615, 339, 1, 0, 0, 0, 1616, 1617, 7, 15,
    0, 0, 1617, 341, 1, 0, 0, 0, 1618, 1619, 7, 16, 0, 0, 1619, 343, 1, 0, 0, 0, 1620, 1621, 7, 17,
    0, 0, 1621, 345, 1, 0, 0, 0, 1622, 1623, 7, 18, 0, 0, 1623, 347, 1, 0, 0, 0, 1624, 1625, 3, 24,
    10, 0, 1625, 1626, 1, 0, 0, 0, 1626, 1627, 6, 172, 2, 0, 1627, 1628, 6, 172, 6, 0, 1628, 349,
    1, 0, 0, 0, 1629, 1630, 3, 28, 12, 0, 1630, 1631, 1, 0, 0, 0, 1631, 1632, 6, 173, 2, 0, 1632, 1633,
    6, 173, 7, 0, 1633, 351, 1, 0, 0, 0, 1634, 1635, 3, 22, 9, 0, 1635, 1636, 1, 0, 0, 0, 1636, 1637,
    6, 174, 1, 0, 1637, 1638, 6, 174, 8, 0, 1638, 353, 1, 0, 0, 0, 1639, 1640, 3, 26, 11, 0, 1640,
    1641, 1, 0, 0, 0, 1641, 1642, 6, 175, 1, 0, 1642, 1643, 6, 175, 9, 0, 1643, 355, 1, 0, 0, 0, 1644,
    1645, 3, 30, 13, 0, 1645, 1646, 1, 0, 0, 0, 1646, 1647, 6, 176, 3, 0, 1647, 1648, 6, 176, 10,
    0, 1648, 357, 1, 0, 0, 0, 1649, 1650, 3, 32, 14, 0, 1650, 1651, 1, 0, 0, 0, 1651, 1652, 6, 177,
    2, 0, 1652, 1653, 6, 177, 11, 0, 1653, 359, 1, 0, 0, 0, 1654, 1655, 3, 18, 7, 0, 1655, 1656, 1,
    0, 0, 0, 1656, 1657, 6, 178, 12, 0, 1657, 361, 1, 0, 0, 0, 1658, 1659, 3, 20, 8, 0, 1659, 1660,
    1, 0, 0, 0, 1660, 1661, 6, 179, 13, 0, 1661, 363, 1, 0, 0, 0, 1662, 1663, 3, 34, 15, 0, 1663, 1664,
    1, 0, 0, 0, 1664, 1665, 6, 180, 14, 0, 1665, 365, 1, 0, 0, 0, 1666, 1667, 3, 36, 16, 0, 1667, 1668,
    1, 0, 0, 0, 1668, 1669, 6, 181, 15, 0, 1669, 367, 1, 0, 0, 0, 1670, 1671, 3, 38, 17, 0, 1671, 1672,
    1, 0, 0, 0, 1672, 1673, 6, 182, 16, 0, 1673, 369, 1, 0, 0, 0, 1674, 1675, 3, 40, 18, 0, 1675, 1676,
    1, 0, 0, 0, 1676, 1677, 6, 183, 17, 0, 1677, 371, 1, 0, 0, 0, 1678, 1679, 3, 42, 19, 0, 1679, 1680,
    1, 0, 0, 0, 1680, 1681, 6, 184, 18, 0, 1681, 373, 1, 0, 0, 0, 1682, 1683, 3, 44, 20, 0, 1683, 1684,
    1, 0, 0, 0, 1684, 1685, 6, 185, 19, 0, 1685, 375, 1, 0, 0, 0, 1686, 1687, 3, 46, 21, 0, 1687, 1688,
    1, 0, 0, 0, 1688, 1689, 6, 186, 20, 0, 1689, 377, 1, 0, 0, 0, 1690, 1691, 3, 48, 22, 0, 1691, 1692,
    1, 0, 0, 0, 1692, 1693, 6, 187, 21, 0, 1693, 379, 1, 0, 0, 0, 1694, 1695, 3, 50, 23, 0, 1695, 1696,
    1, 0, 0, 0, 1696, 1697, 6, 188, 22, 0, 1697, 381, 1, 0, 0, 0, 1698, 1701, 5, 33, 0, 0, 1699, 1702,
    3, 14, 5, 0, 1700, 1702, 3, 12, 4, 0, 1701, 1699, 1, 0, 0, 0, 1701, 1700, 1, 0, 0, 0, 1702, 1703,
    1, 0, 0, 0, 1703, 1704, 6, 189, 23, 0, 1704, 383, 1, 0, 0, 0, 1705, 1706, 3, 54, 25, 0, 1706, 1707,
    1, 0, 0, 0, 1707, 1708, 6, 190, 24, 0, 1708, 385, 1, 0, 0, 0, 1709, 1710, 3, 56, 26, 0, 1710, 1711,
    1, 0, 0, 0, 1711, 1712, 6, 191, 25, 0, 1712, 387, 1, 0, 0, 0, 1713, 1714, 3, 58, 27, 0, 1714, 1715,
    1, 0, 0, 0, 1715, 1716, 6, 192, 26, 0, 1716, 389, 1, 0, 0, 0, 1717, 1718, 3, 60, 28, 0, 1718, 1719,
    1, 0, 0, 0, 1719, 1720, 6, 193, 27, 0, 1720, 391, 1, 0, 0, 0, 1721, 1722, 3, 62, 29, 0, 1722, 1723,
    1, 0, 0, 0, 1723, 1724, 6, 194, 28, 0, 1724, 393, 1, 0, 0, 0, 1725, 1726, 3, 64, 30, 0, 1726, 1727,
    1, 0, 0, 0, 1727, 1728, 6, 195, 29, 0, 1728, 395, 1, 0, 0, 0, 1729, 1730, 3, 66, 31, 0, 1730, 1731,
    1, 0, 0, 0, 1731, 1732, 6, 196, 30, 0, 1732, 397, 1, 0, 0, 0, 1733, 1734, 3, 68, 32, 0, 1734, 1735,
    1, 0, 0, 0, 1735, 1736, 6, 197, 31, 0, 1736, 399, 1, 0, 0, 0, 1737, 1738, 3, 70, 33, 0, 1738, 1739,
    1, 0, 0, 0, 1739, 1740, 6, 198, 32, 0, 1740, 401, 1, 0, 0, 0, 1741, 1742, 3, 72, 34, 0, 1742, 1743,
    1, 0, 0, 0, 1743, 1744, 6, 199, 33, 0, 1744, 403, 1, 0, 0, 0, 1745, 1746, 3, 74, 35, 0, 1746, 1747,
    1, 0, 0, 0, 1747, 1748, 6, 200, 34, 0, 1748, 405, 1, 0, 0, 0, 1749, 1750, 3, 76, 36, 0, 1750, 1751,
    1, 0, 0, 0, 1751, 1752, 6, 201, 35, 0, 1752, 407, 1, 0, 0, 0, 1753, 1754, 3, 16, 6, 0, 1754, 1755,
    1, 0, 0, 0, 1755, 1756, 6, 202, 36, 0, 1756, 409, 1, 0, 0, 0, 1757, 1758, 3, 78, 37, 0, 1758, 1759,
    1, 0, 0, 0, 1759, 1760, 6, 203, 37, 0, 1760, 411, 1, 0, 0, 0, 1761, 1762, 3, 80, 38, 0, 1762, 1763,
    1, 0, 0, 0, 1763, 1764, 6, 204, 38, 0, 1764, 413, 1, 0, 0, 0, 1765, 1766, 3, 82, 39, 0, 1766, 1767,
    1, 0, 0, 0, 1767, 1768, 6, 205, 39, 0, 1768, 415, 1, 0, 0, 0, 1769, 1770, 3, 84, 40, 0, 1770, 1771,
    1, 0, 0, 0, 1771, 1772, 6, 206, 40, 0, 1772, 417, 1, 0, 0, 0, 1773, 1776, 5, 63, 0, 0, 1774, 1777,
    3, 14, 5, 0, 1775, 1777, 3, 12, 4, 0, 1776, 1774, 1, 0, 0, 0, 1776, 1775, 1, 0, 0, 0, 1777, 1778,
    1, 0, 0, 0, 1778, 1779, 6, 207, 41, 0, 1779, 419, 1, 0, 0, 0, 1780, 1781, 3, 90, 43, 0, 1781, 1782,
    1, 0, 0, 0, 1782, 1783, 6, 208, 42, 0, 1783, 421, 1, 0, 0, 0, 1784, 1785, 3, 92, 44, 0, 1785, 1786,
    1, 0, 0, 0, 1786, 1787, 6, 209, 43, 0, 1787, 423, 1, 0, 0, 0, 1788, 1789, 3, 94, 45, 0, 1789, 1790,
    1, 0, 0, 0, 1790, 1791, 6, 210, 44, 0, 1791, 425, 1, 0, 0, 0, 1792, 1793, 3, 96, 46, 0, 1793, 1794,
    1, 0, 0, 0, 1794, 1795, 6, 211, 45, 0, 1795, 427, 1, 0, 0, 0, 1796, 1797, 3, 98, 47, 0, 1797, 1798,
    1, 0, 0, 0, 1798, 1799, 6, 212, 46, 0, 1799, 429, 1, 0, 0, 0, 1800, 1801, 3, 100, 48, 0, 1801,
    1802, 1, 0, 0, 0, 1802, 1803, 6, 213, 47, 0, 1803, 431, 1, 0, 0, 0, 1804, 1805, 3, 102, 49, 0,
    1805, 1806, 1, 0, 0, 0, 1806, 1807, 6, 214, 48, 0, 1807, 433, 1, 0, 0, 0, 1808, 1809, 3, 184,
    90, 0, 1809, 1810, 1, 0, 0, 0, 1810, 1811, 6, 215, 49, 0, 1811, 435, 1, 0, 0, 0, 1812, 1813, 3,
    188, 92, 0, 1813, 1814, 1, 0, 0, 0, 1814, 1815, 6, 216, 50, 0, 1815, 437, 1, 0, 0, 0, 1816, 1817,
    3, 190, 93, 0, 1817, 1818, 1, 0, 0, 0, 1818, 1819, 6, 217, 51, 0, 1819, 439, 1, 0, 0, 0, 1820,
    1821, 3, 182, 89, 0, 1821, 1822, 1, 0, 0, 0, 1822, 1823, 6, 218, 52, 0, 1823, 441, 1, 0, 0, 0,
    1824, 1825, 3, 104, 50, 0, 1825, 1826, 1, 0, 0, 0, 1826, 1827, 6, 219, 53, 0, 1827, 443, 1, 0,
    0, 0, 1828, 1829, 3, 106, 51, 0, 1829, 1830, 1, 0, 0, 0, 1830, 1831, 6, 220, 54, 0, 1831, 445,
    1, 0, 0, 0, 1832, 1833, 3, 108, 52, 0, 1833, 1834, 1, 0, 0, 0, 1834, 1835, 6, 221, 55, 0, 1835,
    447, 1, 0, 0, 0, 1836, 1837, 3, 110, 53, 0, 1837, 1838, 1, 0, 0, 0, 1838, 1839, 6, 222, 56, 0,
    1839, 449, 1, 0, 0, 0, 1840, 1841, 3, 272, 134, 0, 1841, 1842, 1, 0, 0, 0, 1842, 1843, 6, 223,
    4, 0, 1843, 1844, 6, 223, 57, 0, 1844, 451, 1, 0, 0, 0, 1845, 1846, 3, 274, 135, 0, 1846, 1847,
    1, 0, 0, 0, 1847, 1848, 6, 224, 5, 0, 1848, 1849, 6, 224, 58, 0, 1849, 453, 1, 0, 0, 0, 1850, 1851,
    3, 134, 65, 0, 1851, 1852, 1, 0, 0, 0, 1852, 1853, 6, 225, 59, 0, 1853, 455, 1, 0, 0, 0, 1854,
    1855, 3, 136, 66, 0, 1855, 1856, 1, 0, 0, 0, 1856, 1857, 6, 226, 60, 0, 1857, 457, 1, 0, 0, 0,
    1858, 1859, 3, 130, 63, 0, 1859, 1860, 1, 0, 0, 0, 1860, 1861, 6, 227, 61, 0, 1861, 459, 1, 0,
    0, 0, 1862, 1863, 3, 132, 64, 0, 1863, 1864, 1, 0, 0, 0, 1864, 1865, 6, 228, 62, 0, 1865, 461,
    1, 0, 0, 0, 1866, 1867, 3, 150, 73, 0, 1867, 1868, 1, 0, 0, 0, 1868, 1869, 6, 229, 63, 0, 1869,
    463, 1, 0, 0, 0, 1870, 1871, 3, 186, 91, 0, 1871, 1872, 1, 0, 0, 0, 1872, 1873, 6, 230, 64, 0,
    1873, 465, 1, 0, 0, 0, 1874, 1875, 3, 192, 94, 0, 1875, 1876, 1, 0, 0, 0, 1876, 1877, 6, 231,
    65, 0, 1877, 467, 1, 0, 0, 0, 1878, 1879, 3, 202, 99, 0, 1879, 1880, 1, 0, 0, 0, 1880, 1881, 6,
    232, 66, 0, 1881, 469, 1, 0, 0, 0, 1882, 1883, 3, 200, 98, 0, 1883, 1884, 1, 0, 0, 0, 1884, 1885,
    6, 233, 67, 0, 1885, 471, 1, 0, 0, 0, 1886, 1887, 3, 204, 100, 0, 1887, 1888, 1, 0, 0, 0, 1888,
    1889, 6, 234, 68, 0, 1889, 473, 1, 0, 0, 0, 1890, 1891, 3, 206, 101, 0, 1891, 1892, 1, 0, 0, 0,
    1892, 1893, 6, 235, 69, 0, 1893, 475, 1, 0, 0, 0, 1894, 1895, 3, 208, 102, 0, 1895, 1896, 1,
    0, 0, 0, 1896, 1897, 6, 236, 70, 0, 1897, 477, 1, 0, 0, 0, 1898, 1899, 3, 210, 103, 0, 1899, 1900,
    1, 0, 0, 0, 1900, 1901, 6, 237, 71, 0, 1901, 479, 1, 0, 0, 0, 1902, 1903, 3, 212, 104, 0, 1903,
    1904, 1, 0, 0, 0, 1904, 1905, 6, 238, 72, 0, 1905, 481, 1, 0, 0, 0, 1906, 1907, 3, 214, 105, 0,
    1907, 1908, 1, 0, 0, 0, 1908, 1909, 6, 239, 73, 0, 1909, 483, 1, 0, 0, 0, 1910, 1911, 3, 216,
    106, 0, 1911, 1912, 1, 0, 0, 0, 1912, 1913, 6, 240, 74, 0, 1913, 485, 1, 0, 0, 0, 1914, 1915,
    3, 174, 85, 0, 1915, 1916, 1, 0, 0, 0, 1916, 1917, 6, 241, 75, 0, 1917, 487, 1, 0, 0, 0, 1918,
    1919, 3, 176, 86, 0, 1919, 1920, 1, 0, 0, 0, 1920, 1921, 6, 242, 76, 0, 1921, 489, 1, 0, 0, 0,
    1922, 1923, 3, 178, 87, 0, 1923, 1924, 1, 0, 0, 0, 1924, 1925, 6, 243, 77, 0, 1925, 491, 1, 0,
    0, 0, 1926, 1927, 3, 180, 88, 0, 1927, 1928, 1, 0, 0, 0, 1928, 1929, 6, 244, 78, 0, 1929, 493,
    1, 0, 0, 0, 1930, 1931, 3, 112, 54, 0, 1931, 1932, 1, 0, 0, 0, 1932, 1933, 6, 245, 79, 0, 1933,
    495, 1, 0, 0, 0, 1934, 1935, 3, 114, 55, 0, 1935, 1936, 1, 0, 0, 0, 1936, 1937, 6, 246, 80, 0,
    1937, 497, 1, 0, 0, 0, 1938, 1939, 3, 116, 56, 0, 1939, 1940, 1, 0, 0, 0, 1940, 1941, 6, 247,
    81, 0, 1941, 499, 1, 0, 0, 0, 1942, 1943, 3, 156, 76, 0, 1943, 1944, 1, 0, 0, 0, 1944, 1945, 6,
    248, 82, 0, 1945, 501, 1, 0, 0, 0, 1946, 1947, 3, 158, 77, 0, 1947, 1948, 1, 0, 0, 0, 1948, 1949,
    6, 249, 83, 0, 1949, 503, 1, 0, 0, 0, 1950, 1951, 3, 160, 78, 0, 1951, 1952, 1, 0, 0, 0, 1952,
    1953, 6, 250, 84, 0, 1953, 505, 1, 0, 0, 0, 1954, 1955, 3, 162, 79, 0, 1955, 1956, 1, 0, 0, 0,
    1956, 1957, 6, 251, 85, 0, 1957, 507, 1, 0, 0, 0, 1958, 1959, 3, 164, 80, 0, 1959, 1960, 1, 0,
    0, 0, 1960, 1961, 6, 252, 86, 0, 1961, 509, 1, 0, 0, 0, 1962, 1963, 3, 166, 81, 0, 1963, 1964,
    1, 0, 0, 0, 1964, 1965, 6, 253, 87, 0, 1965, 511, 1, 0, 0, 0, 1966, 1967, 3, 168, 82, 0, 1967,
    1968, 1, 0, 0, 0, 1968, 1969, 6, 254, 88, 0, 1969, 513, 1, 0, 0, 0, 1970, 1971, 3, 170, 83, 0,
    1971, 1972, 1, 0, 0, 0, 1972, 1973, 6, 255, 89, 0, 1973, 515, 1, 0, 0, 0, 1974, 1975, 3, 172,
    84, 0, 1975, 1976, 1, 0, 0, 0, 1976, 1977, 6, 256, 90, 0, 1977, 517, 1, 0, 0, 0, 1978, 1979, 3,
    218, 107, 0, 1979, 1980, 1, 0, 0, 0, 1980, 1981, 6, 257, 91, 0, 1981, 519, 1, 0, 0, 0, 1982, 1983,
    3, 220, 108, 0, 1983, 1984, 1, 0, 0, 0, 1984, 1985, 6, 258, 92, 0, 1985, 521, 1, 0, 0, 0, 1986,
    1987, 3, 222, 109, 0, 1987, 1988, 1, 0, 0, 0, 1988, 1989, 6, 259, 93, 0, 1989, 523, 1, 0, 0, 0,
    1990, 1991, 3, 224, 110, 0, 1991, 1992, 1, 0, 0, 0, 1992, 1993, 6, 260, 94, 0, 1993, 525, 1,
    0, 0, 0, 1994, 1995, 3, 226, 111, 0, 1995, 1996, 1, 0, 0, 0, 1996, 1997, 6, 261, 95, 0, 1997,
    527, 1, 0, 0, 0, 1998, 1999, 3, 228, 112, 0, 1999, 2000, 1, 0, 0, 0, 2000, 2001, 6, 262, 96, 0,
    2001, 529, 1, 0, 0, 0, 2002, 2003, 3, 230, 113, 0, 2003, 2004, 1, 0, 0, 0, 2004, 2005, 6, 263,
    97, 0, 2005, 531, 1, 0, 0, 0, 2006, 2007, 3, 232, 114, 0, 2007, 2008, 1, 0, 0, 0, 2008, 2009,
    6, 264, 98, 0, 2009, 533, 1, 0, 0, 0, 2010, 2011, 3, 234, 115, 0, 2011, 2012, 1, 0, 0, 0, 2012,
    2013, 6, 265, 99, 0, 2013, 535, 1, 0, 0, 0, 2014, 2015, 3, 236, 116, 0, 2015, 2016, 1, 0, 0, 0,
    2016, 2017, 6, 266, 100, 0, 2017, 537, 1, 0, 0, 0, 2018, 2019, 3, 238, 117, 0, 2019, 2020, 1,
    0, 0, 0, 2020, 2021, 6, 267, 101, 0, 2021, 539, 1, 0, 0, 0, 2022, 2023, 3, 240, 118, 0, 2023,
    2024, 1, 0, 0, 0, 2024, 2025, 6, 268, 102, 0, 2025, 541, 1, 0, 0, 0, 2026, 2027, 3, 242, 119,
    0, 2027, 2028, 1, 0, 0, 0, 2028, 2029, 6, 269, 103, 0, 2029, 543, 1, 0, 0, 0, 2030, 2031, 3, 244,
    120, 0, 2031, 2032, 1, 0, 0, 0, 2032, 2033, 6, 270, 104, 0, 2033, 545, 1, 0, 0, 0, 2034, 2035,
    3, 246, 121, 0, 2035, 2036, 1, 0, 0, 0, 2036, 2037, 6, 271, 105, 0, 2037, 547, 1, 0, 0, 0, 2038,
    2039, 3, 248, 122, 0, 2039, 2040, 1, 0, 0, 0, 2040, 2041, 6, 272, 106, 0, 2041, 549, 1, 0, 0,
    0, 2042, 2043, 3, 250, 123, 0, 2043, 2044, 1, 0, 0, 0, 2044, 2045, 6, 273, 107, 0, 2045, 551,
    1, 0, 0, 0, 2046, 2047, 3, 252, 124, 0, 2047, 2048, 1, 0, 0, 0, 2048, 2049, 6, 274, 108, 0, 2049,
    553, 1, 0, 0, 0, 2050, 2051, 3, 254, 125, 0, 2051, 2052, 1, 0, 0, 0, 2052, 2053, 6, 275, 109,
    0, 2053, 555, 1, 0, 0, 0, 2054, 2055, 3, 256, 126, 0, 2055, 2056, 1, 0, 0, 0, 2056, 2057, 6, 276,
    110, 0, 2057, 557, 1, 0, 0, 0, 2058, 2059, 3, 258, 127, 0, 2059, 2060, 1, 0, 0, 0, 2060, 2061,
    6, 277, 111, 0, 2061, 559, 1, 0, 0, 0, 2062, 2063, 3, 260, 128, 0, 2063, 2064, 1, 0, 0, 0, 2064,
    2065, 6, 278, 112, 0, 2065, 561, 1, 0, 0, 0, 2066, 2067, 3, 262, 129, 0, 2067, 2068, 1, 0, 0,
    0, 2068, 2069, 6, 279, 113, 0, 2069, 563, 1, 0, 0, 0, 2070, 2071, 3, 264, 130, 0, 2071, 2072,
    1, 0, 0, 0, 2072, 2073, 6, 280, 114, 0, 2073, 565, 1, 0, 0, 0, 2074, 2075, 3, 266, 131, 0, 2075,
    2076, 1, 0, 0, 0, 2076, 2077, 6, 281, 115, 0, 2077, 567, 1, 0, 0, 0, 2078, 2079, 3, 268, 132,
    0, 2079, 2080, 1, 0, 0, 0, 2080, 2081, 6, 282, 116, 0, 2081, 569, 1, 0, 0, 0, 2082, 2083, 3, 270,
    133, 0, 2083, 2084, 1, 0, 0, 0, 2084, 2085, 6, 283, 117, 0, 2085, 571, 1, 0, 0, 0, 2086, 2087,
    3, 310, 153, 0, 2087, 2088, 1, 0, 0, 0, 2088, 2089, 6, 284, 118, 0, 2089, 573, 1, 0, 0, 0, 2090,
    2091, 3, 290, 143, 0, 2091, 2092, 1, 0, 0, 0, 2092, 2093, 6, 285, 119, 0, 2093, 575, 1, 0, 0,
    0, 2094, 2095, 3, 300, 148, 0, 2095, 2096, 1, 0, 0, 0, 2096, 2097, 6, 286, 120, 0, 2097, 577,
    1, 0, 0, 0, 2098, 2099, 3, 306, 151, 0, 2099, 2100, 1, 0, 0, 0, 2100, 2101, 6, 287, 121, 0, 2101,
    579, 1, 0, 0, 0, 2102, 2103, 3, 322, 159, 0, 2103, 2104, 1, 0, 0, 0, 2104, 2105, 6, 288, 122,
    0, 2105, 581, 1, 0, 0, 0, 2106, 2107, 3, 276, 136, 0, 2107, 2108, 1, 0, 0, 0, 2108, 2109, 6, 289,
    123, 0, 2109, 583, 1, 0, 0, 0, 2110, 2111, 3, 312, 154, 0, 2111, 2112, 1, 0, 0, 0, 2112, 2113,
    6, 290, 124, 0, 2113, 585, 1, 0, 0, 0, 2114, 2115, 3, 288, 142, 0, 2115, 2116, 1, 0, 0, 0, 2116,
    2117, 6, 291, 125, 0, 2117, 587, 1, 0, 0, 0, 2118, 2119, 3, 314, 155, 0, 2119, 2120, 1, 0, 0,
    0, 2120, 2121, 6, 292, 126, 0, 2121, 589, 1, 0, 0, 0, 2122, 2123, 3, 318, 157, 0, 2123, 2124,
    1, 0, 0, 0, 2124, 2125, 6, 293, 127, 0, 2125, 591, 1, 0, 0, 0, 2126, 2129, 3, 8, 2, 0, 2127, 2129,
    3, 6, 1, 0, 2128, 2126, 1, 0, 0, 0, 2128, 2127, 1, 0, 0, 0, 2129, 2130, 1, 0, 0, 0, 2130, 2131,
    6, 294, 0, 0, 2131, 593, 1, 0, 0, 0, 2132, 2133, 3, 10, 3, 0, 2133, 2134, 1, 0, 0, 0, 2134, 2135,
    6, 295, 0, 0, 2135, 595, 1, 0, 0, 0, 2136, 2137, 3, 12, 4, 0, 2137, 2138, 1, 0, 0, 0, 2138, 2139,
    6, 296, 0, 0, 2139, 597, 1, 0, 0, 0, 2140, 2141, 5, 34, 0, 0, 2141, 2142, 1, 0, 0, 0, 2142, 2143,
    6, 297, 2, 0, 2143, 599, 1, 0, 0, 0, 2144, 2145, 3, 320, 158, 0, 2145, 601, 1, 0, 0, 0, 2146, 2148,
    8, 19, 0, 0, 2147, 2146, 1, 0, 0, 0, 2148, 2149, 1, 0, 0, 0, 2149, 2147, 1, 0, 0, 0, 2149, 2150,
    1, 0, 0, 0, 2150, 2153, 1, 0, 0, 0, 2151, 2153, 5, 36, 0, 0, 2152, 2147, 1, 0, 0, 0, 2152, 2151,
    1, 0, 0, 0, 2153, 603, 1, 0, 0, 0, 2154, 2157, 3, 328, 162, 0, 2155, 2157, 3, 326, 161, 0, 2156,
    2154, 1, 0, 0, 0, 2156, 2155, 1, 0, 0, 0, 2157, 605, 1, 0, 0, 0, 2158, 2159, 5, 36, 0, 0, 2159,
    2160, 5, 123, 0, 0, 2160, 2161, 1, 0, 0, 0, 2161, 2162, 6, 301, 3, 0, 2162, 607, 1, 0, 0, 0, 2163,
    2165, 3, 610, 303, 0, 2164, 2163, 1, 0, 0, 0, 2164, 2165, 1, 0, 0, 0, 2165, 2166, 1, 0, 0, 0, 2166,
    2167, 5, 34, 0, 0, 2167, 2168, 5, 34, 0, 0, 2168, 2169, 5, 34, 0, 0, 2169, 2170, 1, 0, 0, 0, 2170,
    2171, 6, 302, 2, 0, 2171, 609, 1, 0, 0, 0, 2172, 2174, 5, 34, 0, 0, 2173, 2172, 1, 0, 0, 0, 2174,
    2175, 1, 0, 0, 0, 2175, 2173, 1, 0, 0, 0, 2175, 2176, 1, 0, 0, 0, 2176, 611, 1, 0, 0, 0, 2177, 2178,
    3, 320, 158, 0, 2178, 613, 1, 0, 0, 0, 2179, 2181, 8, 20, 0, 0, 2180, 2179, 1, 0, 0, 0, 2181, 2182,
    1, 0, 0, 0, 2182, 2180, 1, 0, 0, 0, 2182, 2183, 1, 0, 0, 0, 2183, 2186, 1, 0, 0, 0, 2184, 2186,
    5, 36, 0, 0, 2185, 2180, 1, 0, 0, 0, 2185, 2184, 1, 0, 0, 0, 2186, 615, 1, 0, 0, 0, 2187, 2188,
    5, 36, 0, 0, 2188, 2189, 5, 123, 0, 0, 2189, 2190, 1, 0, 0, 0, 2190, 2191, 6, 306, 3, 0, 2191,
    617, 1, 0, 0, 0, 2192, 2193, 3, 12, 4, 0, 2193, 2194, 1, 0, 0, 0, 2194, 2195, 6, 307, 128, 0, 2195,
    619, 1, 0, 0, 0, 52, 0, 1, 2, 3, 626, 634, 636, 650, 662, 664, 669, 773, 1059, 1067, 1380, 1388,
    1392, 1398, 1404, 1408, 1413, 1418, 1423, 1428, 1436, 1442, 1452, 1460, 1468, 1474, 1482,
    1490, 1503, 1512, 1517, 1519, 1526, 1529, 1571, 1582, 1588, 1606, 1701, 1776, 2128, 2149,
    2152, 2156, 2164, 2175, 2182, 2185, 129, 0, 1, 0, 5, 1, 0, 4, 0, 0, 5, 0, 0, 5, 2, 0, 5, 3, 0, 7,
    10, 0, 7, 12, 0, 7, 9, 0, 7, 11, 0, 7, 13, 0, 7, 14, 0, 7, 7, 0, 7, 8, 0, 7, 15, 0, 7, 16, 0, 7, 17, 0,
    7, 18, 0, 7, 19, 0, 7, 20, 0, 7, 21, 0, 7, 22, 0, 7, 23, 0, 7, 24, 0, 7, 25, 0, 7, 26, 0, 7, 27, 0, 7,
    28, 0, 7, 29, 0, 7, 30, 0, 7, 31, 0, 7, 32, 0, 7, 33, 0, 7, 34, 0, 7, 35, 0, 7, 36, 0, 7, 6, 0, 7, 37,
    0, 7, 38, 0, 7, 39, 0, 7, 40, 0, 7, 42, 0, 7, 43, 0, 7, 44, 0, 7, 45, 0, 7, 46, 0, 7, 47, 0, 7, 48, 0,
    7, 49, 0, 7, 90, 0, 7, 92, 0, 7, 93, 0, 7, 89, 0, 7, 50, 0, 7, 51, 0, 7, 52, 0, 7, 53, 0, 7, 134, 0, 7,
    135, 0, 7, 65, 0, 7, 66, 0, 7, 63, 0, 7, 64, 0, 7, 73, 0, 7, 91, 0, 7, 94, 0, 7, 99, 0, 7, 98, 0, 7, 100,
    0, 7, 101, 0, 7, 102, 0, 7, 103, 0, 7, 104, 0, 7, 105, 0, 7, 106, 0, 7, 85, 0, 7, 86, 0, 7, 87, 0, 7,
    88, 0, 7, 54, 0, 7, 55, 0, 7, 56, 0, 7, 76, 0, 7, 77, 0, 7, 78, 0, 7, 79, 0, 7, 80, 0, 7, 81, 0, 7, 82,
    0, 7, 83, 0, 7, 84, 0, 7, 107, 0, 7, 108, 0, 7, 109, 0, 7, 110, 0, 7, 111, 0, 7, 112, 0, 7, 113, 0,
    7, 114, 0, 7, 115, 0, 7, 116, 0, 7, 117, 0, 7, 118, 0, 7, 119, 0, 7, 120, 0, 7, 121, 0, 7, 122, 0,
    7, 123, 0, 7, 124, 0, 7, 125, 0, 7, 126, 0, 7, 127, 0, 7, 128, 0, 7, 129, 0, 7, 130, 0, 7, 131, 0,
    7, 132, 0, 7, 133, 0, 7, 143, 0, 7, 140, 0, 7, 141, 0, 7, 142, 0, 7, 148, 0, 7, 136, 0, 7, 144, 0,
    7, 139, 0, 7, 145, 0, 7, 146, 0, 7, 5, 0];
const atn = new antlr4_1.default.atn.ATNDeserializer().deserialize(serializedATN);
const decisionsToDFA = atn.decisionToState.map((ds, index) => new antlr4_1.default.dfa.DFA(ds, index));
class KotlinLexer extends antlr4_1.default.Lexer {
    static grammarFileName = "KotlinLexer.g4";
    static channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
    static modeNames = ["DEFAULT_MODE", "Inside", "LineString", "MultiLineString"];
    static literalNames = [null, null, null, null, null, null, "'...'", "'.'",
        "','", "'('", "')'", "'['", "']'", "'{'", "'}'",
        "'*'", "'%'", "'/'", "'+'", "'-'", "'++'", "'--'",
        "'&&'", "'||'", null, "'!'", "':'", "';'", "'='",
        "'+='", "'-='", "'*='", "'/='", "'%='", "'->'",
        "'=>'", "'..'", "'::'", "';;'", "'#'", "'@'", null,
        null, "'?'", "'<'", "'>'", "'<='", "'>='", "'!='",
        "'!=='", "'as?'", "'=='", "'==='", "'''", null,
        null, null, null, null, "'package'", "'import'",
        "'class'", "'interface'", "'fun'", "'object'",
        "'val'", "'var'", "'typealias'", "'constructor'",
        "'by'", "'companion'", "'init'", "'this'", "'super'",
        "'typeof'", "'where'", "'if'", "'else'", "'when'",
        "'try'", "'catch'", "'finally'", "'for'", "'do'",
        "'while'", "'throw'", "'return'", "'continue'",
        "'break'", "'as'", "'is'", "'in'", null, null,
        "'out'", "'get'", "'set'", "'dynamic'", "'@file'",
        "'@field'", "'@property'", "'@get'", "'@set'",
        "'@receiver'", "'@param'", "'@setparam'", "'@delegate'",
        "'public'", "'private'", "'protected'", "'internal'",
        "'enum'", "'sealed'", "'annotation'", "'data'",
        "'inner'", "'tailrec'", "'operator'", "'inline'",
        "'infix'", "'external'", "'suspend'", "'override'",
        "'abstract'", "'final'", "'open'", "'const'", "'lateinit'",
        "'vararg'", "'noinline'", "'crossinline'", "'reified'",
        "'expect'", "'actual'", null, "'\"\"\"'", null,
        null, null, null, null, null, null, null, "'null'"];
    static symbolicNames = [null, "ShebangLine", "DelimitedComment", "LineComment",
        "WS", "NL", "RESERVED", "DOT", "COMMA", "LPAREN",
        "RPAREN", "LSQUARE", "RSQUARE", "LCURL", "RCURL",
        "MULT", "MOD", "DIV", "ADD", "SUB", "INCR", "DECR",
        "CONJ", "DISJ", "EXCL_WS", "EXCL_NO_WS", "COLON",
        "SEMICOLON", "ASSIGNMENT", "ADD_ASSIGNMENT", "SUB_ASSIGNMENT",
        "MULT_ASSIGNMENT", "DIV_ASSIGNMENT", "MOD_ASSIGNMENT",
        "ARROW", "DOUBLE_ARROW", "RANGE", "COLONCOLON",
        "DOUBLE_SEMICOLON", "HASH", "AT", "AT_WS", "QUEST_WS",
        "QUEST_NO_WS", "LANGLE", "RANGLE", "LE", "GE",
        "EXCL_EQ", "EXCL_EQEQ", "AS_SAFE", "EQEQ", "EQEQEQ",
        "SINGLE_QUOTE", "RETURN_AT", "CONTINUE_AT", "BREAK_AT",
        "THIS_AT", "SUPER_AT", "PACKAGE", "IMPORT", "CLASS",
        "INTERFACE", "FUN", "OBJECT", "VAL", "VAR", "TYPE_ALIAS",
        "CONSTRUCTOR", "BY", "COMPANION", "INIT", "THIS",
        "SUPER", "TYPEOF", "WHERE", "IF", "ELSE", "WHEN",
        "TRY", "CATCH", "FINALLY", "FOR", "DO", "WHILE",
        "THROW", "RETURN", "CONTINUE", "BREAK", "AS",
        "IS", "IN", "NOT_IS", "NOT_IN", "OUT", "GETTER",
        "SETTER", "DYNAMIC", "AT_FILE", "AT_FIELD", "AT_PROPERTY",
        "AT_GET", "AT_SET", "AT_RECEIVER", "AT_PARAM",
        "AT_SETPARAM", "AT_DELEGATE", "PUBLIC", "PRIVATE",
        "PROTECTED", "INTERNAL", "ENUM", "SEALED", "ANNOTATION",
        "DATA", "INNER", "TAILREC", "OPERATOR", "INLINE",
        "INFIX", "EXTERNAL", "SUSPEND", "OVERRIDE", "ABSTRACT",
        "FINAL", "OPEN", "CONST", "LATEINIT", "VARARG",
        "NOINLINE", "CROSSINLINE", "REIFIED", "EXPECT",
        "ACTUAL", "QUOTE_OPEN", "TRIPLE_QUOTE_OPEN", "RealLiteral",
        "FloatLiteral", "DoubleLiteral", "LongLiteral",
        "IntegerLiteral", "HexLiteral", "BinLiteral",
        "BooleanLiteral", "NullLiteral", "Identifier",
        "IdentifierAt", "FieldIdentifier", "CharacterLiteral",
        "ErrorCharacter", "UNICODE_CLASS_LL", "UNICODE_CLASS_LM",
        "UNICODE_CLASS_LO", "UNICODE_CLASS_LT", "UNICODE_CLASS_LU",
        "UNICODE_CLASS_ND", "UNICODE_CLASS_NL", "Inside_Comment",
        "Inside_WS", "Inside_NL", "QUOTE_CLOSE", "LineStrRef",
        "LineStrText", "LineStrEscapedChar", "LineStrExprStart",
        "TRIPLE_QUOTE_CLOSE", "MultiLineStringQuote",
        "MultiLineStrRef", "MultiLineStrText", "MultiLineStrExprStart"];
    static ruleNames = ["ShebangLine", "DelimitedComment", "LineComment",
        "WS", "NL", "Hidden", "RESERVED", "DOT", "COMMA",
        "LPAREN", "RPAREN", "LSQUARE", "RSQUARE", "LCURL",
        "RCURL", "MULT", "MOD", "DIV", "ADD", "SUB", "INCR",
        "DECR", "CONJ", "DISJ", "EXCL_WS", "EXCL_NO_WS", "COLON",
        "SEMICOLON", "ASSIGNMENT", "ADD_ASSIGNMENT", "SUB_ASSIGNMENT",
        "MULT_ASSIGNMENT", "DIV_ASSIGNMENT", "MOD_ASSIGNMENT",
        "ARROW", "DOUBLE_ARROW", "RANGE", "COLONCOLON", "DOUBLE_SEMICOLON",
        "HASH", "AT", "AT_WS", "QUEST_WS", "QUEST_NO_WS",
        "LANGLE", "RANGLE", "LE", "GE", "EXCL_EQ", "EXCL_EQEQ",
        "AS_SAFE", "EQEQ", "EQEQEQ", "SINGLE_QUOTE", "RETURN_AT",
        "CONTINUE_AT", "BREAK_AT", "THIS_AT", "SUPER_AT",
        "PACKAGE", "IMPORT", "CLASS", "INTERFACE", "FUN",
        "OBJECT", "VAL", "VAR", "TYPE_ALIAS", "CONSTRUCTOR",
        "BY", "COMPANION", "INIT", "THIS", "SUPER", "TYPEOF",
        "WHERE", "IF", "ELSE", "WHEN", "TRY", "CATCH", "FINALLY",
        "FOR", "DO", "WHILE", "THROW", "RETURN", "CONTINUE",
        "BREAK", "AS", "IS", "IN", "NOT_IS", "NOT_IN", "OUT",
        "GETTER", "SETTER", "DYNAMIC", "AT_FILE", "AT_FIELD",
        "AT_PROPERTY", "AT_GET", "AT_SET", "AT_RECEIVER",
        "AT_PARAM", "AT_SETPARAM", "AT_DELEGATE", "PUBLIC",
        "PRIVATE", "PROTECTED", "INTERNAL", "ENUM", "SEALED",
        "ANNOTATION", "DATA", "INNER", "TAILREC", "OPERATOR",
        "INLINE", "INFIX", "EXTERNAL", "SUSPEND", "OVERRIDE",
        "ABSTRACT", "FINAL", "OPEN", "CONST", "LATEINIT",
        "VARARG", "NOINLINE", "CROSSINLINE", "REIFIED", "EXPECT",
        "ACTUAL", "QUOTE_OPEN", "TRIPLE_QUOTE_OPEN", "RealLiteral",
        "FloatLiteral", "DecDigitOrSeparator", "DecDigits",
        "DoubleExponent", "DoubleLiteral", "LongLiteral",
        "IntegerLiteral", "UnicodeDigit", "DecDigit", "DecDigitNoZero",
        "HexDigitOrSeparator", "HexLiteral", "HexDigit", "BinDigitOrSeparator",
        "BinLiteral", "BinDigit", "BooleanLiteral", "NullLiteral",
        "Identifier", "IdentifierOrSoftKey", "IdentifierAt",
        "FieldIdentifier", "CharacterLiteral", "EscapeSeq",
        "UniCharacterLiteral", "EscapedIdentifier", "Letter",
        "ErrorCharacter", "UNICODE_CLASS_LL", "UNICODE_CLASS_LM",
        "UNICODE_CLASS_LO", "UNICODE_CLASS_LT", "UNICODE_CLASS_LU",
        "UNICODE_CLASS_ND", "UNICODE_CLASS_NL", "Inside_RPAREN",
        "Inside_RSQUARE", "Inside_LPAREN", "Inside_LSQUARE",
        "Inside_LCURL", "Inside_RCURL", "Inside_DOT", "Inside_COMMA",
        "Inside_MULT", "Inside_MOD", "Inside_DIV", "Inside_ADD",
        "Inside_SUB", "Inside_INCR", "Inside_DECR", "Inside_CONJ",
        "Inside_DISJ", "Inside_EXCL_WS", "Inside_EXCL_NO_WS",
        "Inside_COLON", "Inside_SEMICOLON", "Inside_ASSIGNMENT",
        "Inside_ADD_ASSIGNMENT", "Inside_SUB_ASSIGNMENT",
        "Inside_MULT_ASSIGNMENT", "Inside_DIV_ASSIGNMENT",
        "Inside_MOD_ASSIGNMENT", "Inside_ARROW", "Inside_DOUBLE_ARROW",
        "Inside_RANGE", "Inside_RESERVED", "Inside_COLONCOLON",
        "Inside_DOUBLE_SEMICOLON", "Inside_HASH", "Inside_AT",
        "Inside_QUEST_WS", "Inside_QUEST_NO_WS", "Inside_LANGLE",
        "Inside_RANGLE", "Inside_LE", "Inside_GE", "Inside_EXCL_EQ",
        "Inside_EXCL_EQEQ", "Inside_IS", "Inside_NOT_IS",
        "Inside_NOT_IN", "Inside_AS", "Inside_AS_SAFE", "Inside_EQEQ",
        "Inside_EQEQEQ", "Inside_SINGLE_QUOTE", "Inside_QUOTE_OPEN",
        "Inside_TRIPLE_QUOTE_OPEN", "Inside_VAL", "Inside_VAR",
        "Inside_FUN", "Inside_OBJECT", "Inside_SUPER", "Inside_IN",
        "Inside_OUT", "Inside_AT_FIELD", "Inside_AT_FILE",
        "Inside_AT_PROPERTY", "Inside_AT_GET", "Inside_AT_SET",
        "Inside_AT_RECEIVER", "Inside_AT_PARAM", "Inside_AT_SETPARAM",
        "Inside_AT_DELEGATE", "Inside_THROW", "Inside_RETURN",
        "Inside_CONTINUE", "Inside_BREAK", "Inside_RETURN_AT",
        "Inside_CONTINUE_AT", "Inside_BREAK_AT", "Inside_IF",
        "Inside_ELSE", "Inside_WHEN", "Inside_TRY", "Inside_CATCH",
        "Inside_FINALLY", "Inside_FOR", "Inside_DO", "Inside_WHILE",
        "Inside_PUBLIC", "Inside_PRIVATE", "Inside_PROTECTED",
        "Inside_INTERNAL", "Inside_ENUM", "Inside_SEALED",
        "Inside_ANNOTATION", "Inside_DATA", "Inside_INNER",
        "Inside_TAILREC", "Inside_OPERATOR", "Inside_INLINE",
        "Inside_INFIX", "Inside_EXTERNAL", "Inside_SUSPEND",
        "Inside_OVERRIDE", "Inside_ABSTRACT", "Inside_FINAL",
        "Inside_OPEN", "Inside_CONST", "Inside_LATEINIT",
        "Inside_VARARG", "Inside_NOINLINE", "Inside_CROSSINLINE",
        "Inside_REIFIED", "Inside_EXPECT", "Inside_ACTUAL",
        "Inside_BooleanLiteral", "Inside_IntegerLiteral",
        "Inside_HexLiteral", "Inside_BinLiteral", "Inside_CharacterLiteral",
        "Inside_RealLiteral", "Inside_NullLiteral", "Inside_LongLiteral",
        "Inside_Identifier", "Inside_IdentifierAt", "Inside_Comment",
        "Inside_WS", "Inside_NL", "QUOTE_CLOSE", "LineStrRef",
        "LineStrText", "LineStrEscapedChar", "LineStrExprStart",
        "TRIPLE_QUOTE_CLOSE", "MultiLineStringQuote", "MultiLineStrRef",
        "MultiLineStrText", "MultiLineStrExprStart", "MultiLineNL"];
    constructor(input) {
        super(input);
        this._interp = new antlr4_1.default.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4_1.default.PredictionContextCache());
    }
    get atn() {
        return atn;
    }
}
exports["default"] = KotlinLexer;
KotlinLexer.EOF = antlr4_1.default.Token.EOF;
KotlinLexer.ShebangLine = 1;
KotlinLexer.DelimitedComment = 2;
KotlinLexer.LineComment = 3;
KotlinLexer.WS = 4;
KotlinLexer.NL = 5;
KotlinLexer.RESERVED = 6;
KotlinLexer.DOT = 7;
KotlinLexer.COMMA = 8;
KotlinLexer.LPAREN = 9;
KotlinLexer.RPAREN = 10;
KotlinLexer.LSQUARE = 11;
KotlinLexer.RSQUARE = 12;
KotlinLexer.LCURL = 13;
KotlinLexer.RCURL = 14;
KotlinLexer.MULT = 15;
KotlinLexer.MOD = 16;
KotlinLexer.DIV = 17;
KotlinLexer.ADD = 18;
KotlinLexer.SUB = 19;
KotlinLexer.INCR = 20;
KotlinLexer.DECR = 21;
KotlinLexer.CONJ = 22;
KotlinLexer.DISJ = 23;
KotlinLexer.EXCL_WS = 24;
KotlinLexer.EXCL_NO_WS = 25;
KotlinLexer.COLON = 26;
KotlinLexer.SEMICOLON = 27;
KotlinLexer.ASSIGNMENT = 28;
KotlinLexer.ADD_ASSIGNMENT = 29;
KotlinLexer.SUB_ASSIGNMENT = 30;
KotlinLexer.MULT_ASSIGNMENT = 31;
KotlinLexer.DIV_ASSIGNMENT = 32;
KotlinLexer.MOD_ASSIGNMENT = 33;
KotlinLexer.ARROW = 34;
KotlinLexer.DOUBLE_ARROW = 35;
KotlinLexer.RANGE = 36;
KotlinLexer.COLONCOLON = 37;
KotlinLexer.DOUBLE_SEMICOLON = 38;
KotlinLexer.HASH = 39;
KotlinLexer.AT = 40;
KotlinLexer.AT_WS = 41;
KotlinLexer.QUEST_WS = 42;
KotlinLexer.QUEST_NO_WS = 43;
KotlinLexer.LANGLE = 44;
KotlinLexer.RANGLE = 45;
KotlinLexer.LE = 46;
KotlinLexer.GE = 47;
KotlinLexer.EXCL_EQ = 48;
KotlinLexer.EXCL_EQEQ = 49;
KotlinLexer.AS_SAFE = 50;
KotlinLexer.EQEQ = 51;
KotlinLexer.EQEQEQ = 52;
KotlinLexer.SINGLE_QUOTE = 53;
KotlinLexer.RETURN_AT = 54;
KotlinLexer.CONTINUE_AT = 55;
KotlinLexer.BREAK_AT = 56;
KotlinLexer.THIS_AT = 57;
KotlinLexer.SUPER_AT = 58;
KotlinLexer.PACKAGE = 59;
KotlinLexer.IMPORT = 60;
KotlinLexer.CLASS = 61;
KotlinLexer.INTERFACE = 62;
KotlinLexer.FUN = 63;
KotlinLexer.OBJECT = 64;
KotlinLexer.VAL = 65;
KotlinLexer.VAR = 66;
KotlinLexer.TYPE_ALIAS = 67;
KotlinLexer.CONSTRUCTOR = 68;
KotlinLexer.BY = 69;
KotlinLexer.COMPANION = 70;
KotlinLexer.INIT = 71;
KotlinLexer.THIS = 72;
KotlinLexer.SUPER = 73;
KotlinLexer.TYPEOF = 74;
KotlinLexer.WHERE = 75;
KotlinLexer.IF = 76;
KotlinLexer.ELSE = 77;
KotlinLexer.WHEN = 78;
KotlinLexer.TRY = 79;
KotlinLexer.CATCH = 80;
KotlinLexer.FINALLY = 81;
KotlinLexer.FOR = 82;
KotlinLexer.DO = 83;
KotlinLexer.WHILE = 84;
KotlinLexer.THROW = 85;
KotlinLexer.RETURN = 86;
KotlinLexer.CONTINUE = 87;
KotlinLexer.BREAK = 88;
KotlinLexer.AS = 89;
KotlinLexer.IS = 90;
KotlinLexer.IN = 91;
KotlinLexer.NOT_IS = 92;
KotlinLexer.NOT_IN = 93;
KotlinLexer.OUT = 94;
KotlinLexer.GETTER = 95;
KotlinLexer.SETTER = 96;
KotlinLexer.DYNAMIC = 97;
KotlinLexer.AT_FILE = 98;
KotlinLexer.AT_FIELD = 99;
KotlinLexer.AT_PROPERTY = 100;
KotlinLexer.AT_GET = 101;
KotlinLexer.AT_SET = 102;
KotlinLexer.AT_RECEIVER = 103;
KotlinLexer.AT_PARAM = 104;
KotlinLexer.AT_SETPARAM = 105;
KotlinLexer.AT_DELEGATE = 106;
KotlinLexer.PUBLIC = 107;
KotlinLexer.PRIVATE = 108;
KotlinLexer.PROTECTED = 109;
KotlinLexer.INTERNAL = 110;
KotlinLexer.ENUM = 111;
KotlinLexer.SEALED = 112;
KotlinLexer.ANNOTATION = 113;
KotlinLexer.DATA = 114;
KotlinLexer.INNER = 115;
KotlinLexer.TAILREC = 116;
KotlinLexer.OPERATOR = 117;
KotlinLexer.INLINE = 118;
KotlinLexer.INFIX = 119;
KotlinLexer.EXTERNAL = 120;
KotlinLexer.SUSPEND = 121;
KotlinLexer.OVERRIDE = 122;
KotlinLexer.ABSTRACT = 123;
KotlinLexer.FINAL = 124;
KotlinLexer.OPEN = 125;
KotlinLexer.CONST = 126;
KotlinLexer.LATEINIT = 127;
KotlinLexer.VARARG = 128;
KotlinLexer.NOINLINE = 129;
KotlinLexer.CROSSINLINE = 130;
KotlinLexer.REIFIED = 131;
KotlinLexer.EXPECT = 132;
KotlinLexer.ACTUAL = 133;
KotlinLexer.QUOTE_OPEN = 134;
KotlinLexer.TRIPLE_QUOTE_OPEN = 135;
KotlinLexer.RealLiteral = 136;
KotlinLexer.FloatLiteral = 137;
KotlinLexer.DoubleLiteral = 138;
KotlinLexer.LongLiteral = 139;
KotlinLexer.IntegerLiteral = 140;
KotlinLexer.HexLiteral = 141;
KotlinLexer.BinLiteral = 142;
KotlinLexer.BooleanLiteral = 143;
KotlinLexer.NullLiteral = 144;
KotlinLexer.Identifier = 145;
KotlinLexer.IdentifierAt = 146;
KotlinLexer.FieldIdentifier = 147;
KotlinLexer.CharacterLiteral = 148;
KotlinLexer.ErrorCharacter = 149;
KotlinLexer.UNICODE_CLASS_LL = 150;
KotlinLexer.UNICODE_CLASS_LM = 151;
KotlinLexer.UNICODE_CLASS_LO = 152;
KotlinLexer.UNICODE_CLASS_LT = 153;
KotlinLexer.UNICODE_CLASS_LU = 154;
KotlinLexer.UNICODE_CLASS_ND = 155;
KotlinLexer.UNICODE_CLASS_NL = 156;
KotlinLexer.Inside_Comment = 157;
KotlinLexer.Inside_WS = 158;
KotlinLexer.Inside_NL = 159;
KotlinLexer.QUOTE_CLOSE = 160;
KotlinLexer.LineStrRef = 161;
KotlinLexer.LineStrText = 162;
KotlinLexer.LineStrEscapedChar = 163;
KotlinLexer.LineStrExprStart = 164;
KotlinLexer.TRIPLE_QUOTE_CLOSE = 165;
KotlinLexer.MultiLineStringQuote = 166;
KotlinLexer.MultiLineStrRef = 167;
KotlinLexer.MultiLineStrText = 168;
KotlinLexer.MultiLineStrExprStart = 169;
KotlinLexer.Inside = 1;
KotlinLexer.LineString = 2;
KotlinLexer.MultiLineString = 3;
//# sourceMappingURL=KotlinLexer.js.map

/***/ }),

/***/ 9915:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Generated from KotlinParser.g4 by ANTLR 4.10.1
// jshint ignore: start
const antlr4_1 = __importDefault(__webpack_require__(7228));
// This class defines a complete listener for a parse tree produced by KotlinParser.
class KotlinParserListener extends antlr4_1.default.tree.ParseTreeListener {
    // Enter a parse tree produced by KotlinParser#kotlinFile.
    enterKotlinFile(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#kotlinFile.
    exitKotlinFile(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#script.
    enterScript(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#script.
    exitScript(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#fileAnnotation.
    enterFileAnnotation(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#fileAnnotation.
    exitFileAnnotation(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#packageHeader.
    enterPackageHeader(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#packageHeader.
    exitPackageHeader(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#importList.
    enterImportList(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#importList.
    exitImportList(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#importHeader.
    enterImportHeader(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#importHeader.
    exitImportHeader(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#importAlias.
    enterImportAlias(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#importAlias.
    exitImportAlias(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#topLevelObject.
    enterTopLevelObject(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#topLevelObject.
    exitTopLevelObject(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#classDeclaration.
    enterClassDeclaration(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#classDeclaration.
    exitClassDeclaration(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#primaryConstructor.
    enterPrimaryConstructor(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#primaryConstructor.
    exitPrimaryConstructor(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#classParameters.
    enterClassParameters(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#classParameters.
    exitClassParameters(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#classParameter.
    enterClassParameter(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#classParameter.
    exitClassParameter(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#delegationSpecifiers.
    enterDelegationSpecifiers(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#delegationSpecifiers.
    exitDelegationSpecifiers(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#annotatedDelegationSpecifier.
    enterAnnotatedDelegationSpecifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#annotatedDelegationSpecifier.
    exitAnnotatedDelegationSpecifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#delegationSpecifier.
    enterDelegationSpecifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#delegationSpecifier.
    exitDelegationSpecifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#constructorInvocation.
    enterConstructorInvocation(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#constructorInvocation.
    exitConstructorInvocation(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#explicitDelegation.
    enterExplicitDelegation(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#explicitDelegation.
    exitExplicitDelegation(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#classBody.
    enterClassBody(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#classBody.
    exitClassBody(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#classMemberDeclarations.
    enterClassMemberDeclarations(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#classMemberDeclarations.
    exitClassMemberDeclarations(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#classMemberDeclaration.
    enterClassMemberDeclaration(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#classMemberDeclaration.
    exitClassMemberDeclaration(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#anonymousInitializer.
    enterAnonymousInitializer(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#anonymousInitializer.
    exitAnonymousInitializer(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#secondaryConstructor.
    enterSecondaryConstructor(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#secondaryConstructor.
    exitSecondaryConstructor(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#constructorDelegationCall.
    enterConstructorDelegationCall(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#constructorDelegationCall.
    exitConstructorDelegationCall(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#enumClassBody.
    enterEnumClassBody(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#enumClassBody.
    exitEnumClassBody(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#enumEntries.
    enterEnumEntries(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#enumEntries.
    exitEnumEntries(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#enumEntry.
    enterEnumEntry(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#enumEntry.
    exitEnumEntry(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#functionDeclaration.
    enterFunctionDeclaration(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#functionDeclaration.
    exitFunctionDeclaration(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#functionValueParameters.
    enterFunctionValueParameters(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#functionValueParameters.
    exitFunctionValueParameters(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#functionValueParameter.
    enterFunctionValueParameter(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#functionValueParameter.
    exitFunctionValueParameter(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#parameter.
    enterParameter(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#parameter.
    exitParameter(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#setterParameter.
    enterSetterParameter(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#setterParameter.
    exitSetterParameter(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#functionBody.
    enterFunctionBody(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#functionBody.
    exitFunctionBody(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#objectDeclaration.
    enterObjectDeclaration(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#objectDeclaration.
    exitObjectDeclaration(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#companionObject.
    enterCompanionObject(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#companionObject.
    exitCompanionObject(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#propertyDeclaration.
    enterPropertyDeclaration(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#propertyDeclaration.
    exitPropertyDeclaration(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#multiVariableDeclaration.
    enterMultiVariableDeclaration(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#multiVariableDeclaration.
    exitMultiVariableDeclaration(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#variableDeclaration.
    enterVariableDeclaration(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#variableDeclaration.
    exitVariableDeclaration(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#propertyDelegate.
    enterPropertyDelegate(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#propertyDelegate.
    exitPropertyDelegate(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#getter.
    enterGetter(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#getter.
    exitGetter(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#setter.
    enterSetter(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#setter.
    exitSetter(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeAlias.
    enterTypeAlias(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeAlias.
    exitTypeAlias(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeParameters.
    enterTypeParameters(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeParameters.
    exitTypeParameters(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeParameter.
    enterTypeParameter(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeParameter.
    exitTypeParameter(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeParameterModifiers.
    enterTypeParameterModifiers(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeParameterModifiers.
    exitTypeParameterModifiers(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeParameterModifier.
    enterTypeParameterModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeParameterModifier.
    exitTypeParameterModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#type_.
    enterType_(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#type_.
    exitType_(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeModifiers.
    enterTypeModifiers(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeModifiers.
    exitTypeModifiers(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeModifier.
    enterTypeModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeModifier.
    exitTypeModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#parenthesizedType.
    enterParenthesizedType(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#parenthesizedType.
    exitParenthesizedType(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#nullableType.
    enterNullableType(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#nullableType.
    exitNullableType(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeReference.
    enterTypeReference(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeReference.
    exitTypeReference(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#functionType.
    enterFunctionType(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#functionType.
    exitFunctionType(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#receiverType.
    enterReceiverType(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#receiverType.
    exitReceiverType(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#userType.
    enterUserType(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#userType.
    exitUserType(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#parenthesizedUserType.
    enterParenthesizedUserType(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#parenthesizedUserType.
    exitParenthesizedUserType(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#simpleUserType.
    enterSimpleUserType(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#simpleUserType.
    exitSimpleUserType(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#functionTypeParameters.
    enterFunctionTypeParameters(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#functionTypeParameters.
    exitFunctionTypeParameters(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeConstraints.
    enterTypeConstraints(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeConstraints.
    exitTypeConstraints(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeConstraint.
    enterTypeConstraint(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeConstraint.
    exitTypeConstraint(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#block.
    enterBlock(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#block.
    exitBlock(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#statements.
    enterStatements(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#statements.
    exitStatements(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#statement.
    enterStatement(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#statement.
    exitStatement(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#declaration.
    enterDeclaration(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#declaration.
    exitDeclaration(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#assignment.
    enterAssignment(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#assignment.
    exitAssignment(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#expression.
    enterExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#expression.
    exitExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#disjunction.
    enterDisjunction(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#disjunction.
    exitDisjunction(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#conjunction.
    enterConjunction(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#conjunction.
    exitConjunction(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#equality.
    enterEquality(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#equality.
    exitEquality(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#comparison.
    enterComparison(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#comparison.
    exitComparison(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#infixOperation.
    enterInfixOperation(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#infixOperation.
    exitInfixOperation(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#elvisExpression.
    enterElvisExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#elvisExpression.
    exitElvisExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#infixFunctionCall.
    enterInfixFunctionCall(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#infixFunctionCall.
    exitInfixFunctionCall(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#rangeExpression.
    enterRangeExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#rangeExpression.
    exitRangeExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#additiveExpression.
    enterAdditiveExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#additiveExpression.
    exitAdditiveExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#multiplicativeExpression.
    enterMultiplicativeExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#multiplicativeExpression.
    exitMultiplicativeExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#asExpression.
    enterAsExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#asExpression.
    exitAsExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#prefixUnaryExpression.
    enterPrefixUnaryExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#prefixUnaryExpression.
    exitPrefixUnaryExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#unaryPrefix.
    enterUnaryPrefix(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#unaryPrefix.
    exitUnaryPrefix(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#postfixUnaryExpression.
    enterPostfixUnaryExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#postfixUnaryExpression.
    exitPostfixUnaryExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#postfixUnarySuffix.
    enterPostfixUnarySuffix(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#postfixUnarySuffix.
    exitPostfixUnarySuffix(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#directlyAssignableExpression.
    enterDirectlyAssignableExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#directlyAssignableExpression.
    exitDirectlyAssignableExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#assignableExpression.
    enterAssignableExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#assignableExpression.
    exitAssignableExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#assignableSuffix.
    enterAssignableSuffix(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#assignableSuffix.
    exitAssignableSuffix(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#indexingSuffix.
    enterIndexingSuffix(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#indexingSuffix.
    exitIndexingSuffix(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#navigationSuffix.
    enterNavigationSuffix(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#navigationSuffix.
    exitNavigationSuffix(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#callSuffix.
    enterCallSuffix(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#callSuffix.
    exitCallSuffix(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#annotatedLambda.
    enterAnnotatedLambda(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#annotatedLambda.
    exitAnnotatedLambda(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#valueArguments.
    enterValueArguments(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#valueArguments.
    exitValueArguments(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeArguments.
    enterTypeArguments(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeArguments.
    exitTypeArguments(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeProjection.
    enterTypeProjection(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeProjection.
    exitTypeProjection(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeProjectionModifiers.
    enterTypeProjectionModifiers(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeProjectionModifiers.
    exitTypeProjectionModifiers(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeProjectionModifier.
    enterTypeProjectionModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeProjectionModifier.
    exitTypeProjectionModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#valueArgument.
    enterValueArgument(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#valueArgument.
    exitValueArgument(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#primaryExpression.
    enterPrimaryExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#primaryExpression.
    exitPrimaryExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#parenthesizedExpression.
    enterParenthesizedExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#parenthesizedExpression.
    exitParenthesizedExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#collectionLiteral.
    enterCollectionLiteral(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#collectionLiteral.
    exitCollectionLiteral(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#literalConstant.
    enterLiteralConstant(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#literalConstant.
    exitLiteralConstant(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#stringLiteral.
    enterStringLiteral(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#stringLiteral.
    exitStringLiteral(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#lineStringLiteral.
    enterLineStringLiteral(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#lineStringLiteral.
    exitLineStringLiteral(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#multiLineStringLiteral.
    enterMultiLineStringLiteral(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#multiLineStringLiteral.
    exitMultiLineStringLiteral(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#lineStringContent.
    enterLineStringContent(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#lineStringContent.
    exitLineStringContent(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#lineStringExpression.
    enterLineStringExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#lineStringExpression.
    exitLineStringExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#multiLineStringContent.
    enterMultiLineStringContent(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#multiLineStringContent.
    exitMultiLineStringContent(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#multiLineStringExpression.
    enterMultiLineStringExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#multiLineStringExpression.
    exitMultiLineStringExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#lambdaLiteral.
    enterLambdaLiteral(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#lambdaLiteral.
    exitLambdaLiteral(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#lambdaParameters.
    enterLambdaParameters(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#lambdaParameters.
    exitLambdaParameters(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#lambdaParameter.
    enterLambdaParameter(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#lambdaParameter.
    exitLambdaParameter(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#anonymousFunction.
    enterAnonymousFunction(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#anonymousFunction.
    exitAnonymousFunction(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#functionLiteral.
    enterFunctionLiteral(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#functionLiteral.
    exitFunctionLiteral(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#objectLiteral.
    enterObjectLiteral(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#objectLiteral.
    exitObjectLiteral(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#thisExpression.
    enterThisExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#thisExpression.
    exitThisExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#superExpression.
    enterSuperExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#superExpression.
    exitSuperExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#controlStructureBody.
    enterControlStructureBody(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#controlStructureBody.
    exitControlStructureBody(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#ifExpression.
    enterIfExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#ifExpression.
    exitIfExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#whenExpression.
    enterWhenExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#whenExpression.
    exitWhenExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#whenEntry.
    enterWhenEntry(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#whenEntry.
    exitWhenEntry(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#whenCondition.
    enterWhenCondition(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#whenCondition.
    exitWhenCondition(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#rangeTest.
    enterRangeTest(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#rangeTest.
    exitRangeTest(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#typeTest.
    enterTypeTest(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#typeTest.
    exitTypeTest(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#tryExpression.
    enterTryExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#tryExpression.
    exitTryExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#catchBlock.
    enterCatchBlock(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#catchBlock.
    exitCatchBlock(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#finallyBlock.
    enterFinallyBlock(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#finallyBlock.
    exitFinallyBlock(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#loopStatement.
    enterLoopStatement(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#loopStatement.
    exitLoopStatement(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#forStatement.
    enterForStatement(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#forStatement.
    exitForStatement(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#whileStatement.
    enterWhileStatement(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#whileStatement.
    exitWhileStatement(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#doWhileStatement.
    enterDoWhileStatement(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#doWhileStatement.
    exitDoWhileStatement(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#jumpExpression.
    enterJumpExpression(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#jumpExpression.
    exitJumpExpression(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#callableReference.
    enterCallableReference(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#callableReference.
    exitCallableReference(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#assignmentAndOperator.
    enterAssignmentAndOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#assignmentAndOperator.
    exitAssignmentAndOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#equalityOperator.
    enterEqualityOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#equalityOperator.
    exitEqualityOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#comparisonOperator.
    enterComparisonOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#comparisonOperator.
    exitComparisonOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#inOperator.
    enterInOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#inOperator.
    exitInOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#isOperator.
    enterIsOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#isOperator.
    exitIsOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#additiveOperator.
    enterAdditiveOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#additiveOperator.
    exitAdditiveOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#multiplicativeOperator.
    enterMultiplicativeOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#multiplicativeOperator.
    exitMultiplicativeOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#asOperator.
    enterAsOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#asOperator.
    exitAsOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#prefixUnaryOperator.
    enterPrefixUnaryOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#prefixUnaryOperator.
    exitPrefixUnaryOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#postfixUnaryOperator.
    enterPostfixUnaryOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#postfixUnaryOperator.
    exitPostfixUnaryOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#memberAccessOperator.
    enterMemberAccessOperator(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#memberAccessOperator.
    exitMemberAccessOperator(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#modifiers.
    enterModifiers(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#modifiers.
    exitModifiers(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#modifier.
    enterModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#modifier.
    exitModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#classModifier.
    enterClassModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#classModifier.
    exitClassModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#memberModifier.
    enterMemberModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#memberModifier.
    exitMemberModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#visibilityModifier.
    enterVisibilityModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#visibilityModifier.
    exitVisibilityModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#varianceModifier.
    enterVarianceModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#varianceModifier.
    exitVarianceModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#functionModifier.
    enterFunctionModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#functionModifier.
    exitFunctionModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#propertyModifier.
    enterPropertyModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#propertyModifier.
    exitPropertyModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#inheritanceModifier.
    enterInheritanceModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#inheritanceModifier.
    exitInheritanceModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#parameterModifier.
    enterParameterModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#parameterModifier.
    exitParameterModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#reificationModifier.
    enterReificationModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#reificationModifier.
    exitReificationModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#platformModifier.
    enterPlatformModifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#platformModifier.
    exitPlatformModifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#label.
    enterLabel(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#label.
    exitLabel(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#annotation.
    enterAnnotation(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#annotation.
    exitAnnotation(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#singleAnnotation.
    enterSingleAnnotation(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#singleAnnotation.
    exitSingleAnnotation(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#multiAnnotation.
    enterMultiAnnotation(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#multiAnnotation.
    exitMultiAnnotation(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#annotationUseSiteTarget.
    enterAnnotationUseSiteTarget(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#annotationUseSiteTarget.
    exitAnnotationUseSiteTarget(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#unescapedAnnotation.
    enterUnescapedAnnotation(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#unescapedAnnotation.
    exitUnescapedAnnotation(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#simpleIdentifier.
    enterSimpleIdentifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#simpleIdentifier.
    exitSimpleIdentifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#identifier.
    enterIdentifier(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#identifier.
    exitIdentifier(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#shebangLine.
    enterShebangLine(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#shebangLine.
    exitShebangLine(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#quest.
    enterQuest(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#quest.
    exitQuest(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#elvis.
    enterElvis(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#elvis.
    exitElvis(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#safeNav.
    enterSafeNav(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#safeNav.
    exitSafeNav(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#excl.
    enterExcl(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#excl.
    exitExcl(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#semi.
    enterSemi(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#semi.
    exitSemi(ctx) {
    }
    // Enter a parse tree produced by KotlinParser#semis.
    enterSemis(ctx) {
    }
    // Exit a parse tree produced by KotlinParser#semis.
    exitSemis(ctx) {
    }
}
exports["default"] = KotlinParserListener;
//# sourceMappingURL=KotlinParserListener.js.map

/***/ }),

/***/ 3130:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Generated from KotlinParser.g4 by ANTLR 4.10.1
// jshint ignore: start
const antlr4_1 = __importDefault(__webpack_require__(7228));
// This class defines a complete generic visitor for a parse tree produced by KotlinParser.
class KotlinParserVisitor extends antlr4_1.default.tree.ParseTreeVisitor {
    // Visit a parse tree produced by KotlinParser#kotlinFile.
    visitKotlinFile(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#script.
    visitScript(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#fileAnnotation.
    visitFileAnnotation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#packageHeader.
    visitPackageHeader(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#importList.
    visitImportList(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#importHeader.
    visitImportHeader(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#importAlias.
    visitImportAlias(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#topLevelObject.
    visitTopLevelObject(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#classDeclaration.
    visitClassDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#primaryConstructor.
    visitPrimaryConstructor(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#classParameters.
    visitClassParameters(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#classParameter.
    visitClassParameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#delegationSpecifiers.
    visitDelegationSpecifiers(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#annotatedDelegationSpecifier.
    visitAnnotatedDelegationSpecifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#delegationSpecifier.
    visitDelegationSpecifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#constructorInvocation.
    visitConstructorInvocation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#explicitDelegation.
    visitExplicitDelegation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#classBody.
    visitClassBody(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#classMemberDeclarations.
    visitClassMemberDeclarations(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#classMemberDeclaration.
    visitClassMemberDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#anonymousInitializer.
    visitAnonymousInitializer(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#secondaryConstructor.
    visitSecondaryConstructor(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#constructorDelegationCall.
    visitConstructorDelegationCall(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#enumClassBody.
    visitEnumClassBody(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#enumEntries.
    visitEnumEntries(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#enumEntry.
    visitEnumEntry(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#functionDeclaration.
    visitFunctionDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#functionValueParameters.
    visitFunctionValueParameters(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#functionValueParameter.
    visitFunctionValueParameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#parameter.
    visitParameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#setterParameter.
    visitSetterParameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#functionBody.
    visitFunctionBody(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#objectDeclaration.
    visitObjectDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#companionObject.
    visitCompanionObject(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#propertyDeclaration.
    visitPropertyDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#multiVariableDeclaration.
    visitMultiVariableDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#variableDeclaration.
    visitVariableDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#propertyDelegate.
    visitPropertyDelegate(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#getter.
    visitGetter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#setter.
    visitSetter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeAlias.
    visitTypeAlias(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeParameters.
    visitTypeParameters(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeParameter.
    visitTypeParameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeParameterModifiers.
    visitTypeParameterModifiers(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeParameterModifier.
    visitTypeParameterModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#type_.
    visitType_(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeModifiers.
    visitTypeModifiers(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeModifier.
    visitTypeModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#parenthesizedType.
    visitParenthesizedType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#nullableType.
    visitNullableType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeReference.
    visitTypeReference(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#functionType.
    visitFunctionType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#receiverType.
    visitReceiverType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#userType.
    visitUserType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#parenthesizedUserType.
    visitParenthesizedUserType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#simpleUserType.
    visitSimpleUserType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#functionTypeParameters.
    visitFunctionTypeParameters(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeConstraints.
    visitTypeConstraints(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeConstraint.
    visitTypeConstraint(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#block.
    visitBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#statements.
    visitStatements(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#statement.
    visitStatement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#declaration.
    visitDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#assignment.
    visitAssignment(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#expression.
    visitExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#disjunction.
    visitDisjunction(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#conjunction.
    visitConjunction(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#equality.
    visitEquality(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#comparison.
    visitComparison(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#infixOperation.
    visitInfixOperation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#elvisExpression.
    visitElvisExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#infixFunctionCall.
    visitInfixFunctionCall(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#rangeExpression.
    visitRangeExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#additiveExpression.
    visitAdditiveExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#multiplicativeExpression.
    visitMultiplicativeExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#asExpression.
    visitAsExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#prefixUnaryExpression.
    visitPrefixUnaryExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#unaryPrefix.
    visitUnaryPrefix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#postfixUnaryExpression.
    visitPostfixUnaryExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#postfixUnarySuffix.
    visitPostfixUnarySuffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#directlyAssignableExpression.
    visitDirectlyAssignableExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#assignableExpression.
    visitAssignableExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#assignableSuffix.
    visitAssignableSuffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#indexingSuffix.
    visitIndexingSuffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#navigationSuffix.
    visitNavigationSuffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#callSuffix.
    visitCallSuffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#annotatedLambda.
    visitAnnotatedLambda(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#valueArguments.
    visitValueArguments(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeArguments.
    visitTypeArguments(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeProjection.
    visitTypeProjection(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeProjectionModifiers.
    visitTypeProjectionModifiers(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeProjectionModifier.
    visitTypeProjectionModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#valueArgument.
    visitValueArgument(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#primaryExpression.
    visitPrimaryExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#parenthesizedExpression.
    visitParenthesizedExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#collectionLiteral.
    visitCollectionLiteral(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#literalConstant.
    visitLiteralConstant(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#stringLiteral.
    visitStringLiteral(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#lineStringLiteral.
    visitLineStringLiteral(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#multiLineStringLiteral.
    visitMultiLineStringLiteral(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#lineStringContent.
    visitLineStringContent(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#lineStringExpression.
    visitLineStringExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#multiLineStringContent.
    visitMultiLineStringContent(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#multiLineStringExpression.
    visitMultiLineStringExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#lambdaLiteral.
    visitLambdaLiteral(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#lambdaParameters.
    visitLambdaParameters(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#lambdaParameter.
    visitLambdaParameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#anonymousFunction.
    visitAnonymousFunction(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#functionLiteral.
    visitFunctionLiteral(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#objectLiteral.
    visitObjectLiteral(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#thisExpression.
    visitThisExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#superExpression.
    visitSuperExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#controlStructureBody.
    visitControlStructureBody(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#ifExpression.
    visitIfExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#whenExpression.
    visitWhenExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#whenEntry.
    visitWhenEntry(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#whenCondition.
    visitWhenCondition(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#rangeTest.
    visitRangeTest(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#typeTest.
    visitTypeTest(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#tryExpression.
    visitTryExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#catchBlock.
    visitCatchBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#finallyBlock.
    visitFinallyBlock(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#loopStatement.
    visitLoopStatement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#forStatement.
    visitForStatement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#whileStatement.
    visitWhileStatement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#doWhileStatement.
    visitDoWhileStatement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#jumpExpression.
    visitJumpExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#callableReference.
    visitCallableReference(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#assignmentAndOperator.
    visitAssignmentAndOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#equalityOperator.
    visitEqualityOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#comparisonOperator.
    visitComparisonOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#inOperator.
    visitInOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#isOperator.
    visitIsOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#additiveOperator.
    visitAdditiveOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#multiplicativeOperator.
    visitMultiplicativeOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#asOperator.
    visitAsOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#prefixUnaryOperator.
    visitPrefixUnaryOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#postfixUnaryOperator.
    visitPostfixUnaryOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#memberAccessOperator.
    visitMemberAccessOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#modifiers.
    visitModifiers(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#modifier.
    visitModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#classModifier.
    visitClassModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#memberModifier.
    visitMemberModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#visibilityModifier.
    visitVisibilityModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#varianceModifier.
    visitVarianceModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#functionModifier.
    visitFunctionModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#propertyModifier.
    visitPropertyModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#inheritanceModifier.
    visitInheritanceModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#parameterModifier.
    visitParameterModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#reificationModifier.
    visitReificationModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#platformModifier.
    visitPlatformModifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#label.
    visitLabel(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#annotation.
    visitAnnotation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#singleAnnotation.
    visitSingleAnnotation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#multiAnnotation.
    visitMultiAnnotation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#annotationUseSiteTarget.
    visitAnnotationUseSiteTarget(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#unescapedAnnotation.
    visitUnescapedAnnotation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#simpleIdentifier.
    visitSimpleIdentifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#identifier.
    visitIdentifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#shebangLine.
    visitShebangLine(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#quest.
    visitQuest(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#elvis.
    visitElvis(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#safeNav.
    visitSafeNav(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#excl.
    visitExcl(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#semi.
    visitSemi(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by KotlinParser#semis.
    visitSemis(ctx) {
        return this.visitChildren(ctx);
    }
}
exports["default"] = KotlinParserVisitor;
//# sourceMappingURL=KotlinParserVisitor.js.map

/***/ }),

/***/ 5401:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Generated from ./assets/swift/Swift5Lexer.g4 by ANTLR 4.10.1
// jshint ignore: start
const antlr4_1 = __importDefault(__webpack_require__(7228));
const Stack_1 = __webpack_require__(6209);
const serializedATN = [4, 0, 193, 1946, 6, -1, 6, -1, 6, -1, 6, -1, 6, -1, 2, 0, 7, 0, 2, 1,
    7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
    7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7,
    17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24,
    2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2,
    32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39,
    7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7,
    46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53,
    2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2,
    61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
    7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7,
    75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82,
    2, 83, 7, 83, 2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2,
    90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97,
    7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103,
    2, 104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108, 2, 109, 7, 109,
    2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115,
    2, 116, 7, 116, 2, 117, 7, 117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121,
    2, 122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 126, 2, 127, 7, 127,
    2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133,
    2, 134, 7, 134, 2, 135, 7, 135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139,
    2, 140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7, 144, 2, 145, 7, 145,
    2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2, 149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151,
    2, 152, 7, 152, 2, 153, 7, 153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157,
    2, 158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7, 162, 2, 163, 7, 163,
    2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2, 167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169,
    2, 170, 7, 170, 2, 171, 7, 171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175,
    2, 176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7, 180, 2, 181, 7, 181,
    2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2, 185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187,
    2, 188, 7, 188, 2, 189, 7, 189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193,
    2, 194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7, 198, 2, 199, 7, 199,
    2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2, 203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205,
    2, 206, 7, 206, 2, 207, 7, 207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211,
    2, 212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7, 216, 2, 217, 7, 217,
    2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2, 221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223,
    2, 224, 7, 224, 2, 225, 7, 225, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2,
    1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5,
    1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
    1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
    11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14,
    1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1,
    15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18,
    1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
    20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23,
    1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1,
    25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28,
    1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 1,
    31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32,
    1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1,
    35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37,
    1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1,
    39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
    1, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 43, 1,
    43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44,
    1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1,
    45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47,
    1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
    50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51,
    1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
    52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54,
    1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1,
    55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
    1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1,
    58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
    1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1,
    62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64,
    1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1,
    65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66,
    1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1,
    68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70,
    1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1,
    71, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 74,
    1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1,
    76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77,
    1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
    78, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82,
    1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1,
    85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87,
    1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1,
    89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 92,
    1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1,
    93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96,
    1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1,
    99, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101,
    1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1, 103,
    1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105,
    1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 107,
    1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108,
    1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109,
    1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109,
    1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110,
    1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110,
    1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110,
    1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111,
    1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111,
    1, 111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112,
    1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113,
    1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115,
    1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117,
    1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118,
    1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120,
    1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 122, 1, 122,
    1, 122, 1, 122, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123,
    1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 125, 1, 125,
    1, 125, 1, 125, 1, 125, 1, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126,
    1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 128, 1, 128,
    1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129,
    1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
    1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131,
    1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132,
    1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133,
    1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134,
    1, 134, 1, 134, 1, 134, 1, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 136,
    1, 136, 3, 136, 1522, 8, 136, 1, 136, 1, 136, 3, 136, 1526, 8, 136, 1, 137, 3, 137, 1529, 8, 137,
    1, 138, 1, 138, 3, 138, 1533, 8, 138, 1, 139, 4, 139, 1536, 8, 139, 11, 139, 12, 139, 1537, 1,
    140, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 1, 142, 1, 142, 1, 143, 1, 143, 1, 144, 1, 144, 1,
    144, 1, 145, 1, 145, 1, 146, 1, 146, 1, 147, 1, 147, 1, 147, 1, 148, 1, 148, 1, 149, 1, 149, 1,
    150, 1, 150, 1, 151, 1, 151, 1, 152, 1, 152, 1, 153, 1, 153, 1, 154, 1, 154, 1, 155, 1, 155, 1,
    156, 1, 156, 1, 157, 1, 157, 1, 158, 1, 158, 1, 159, 1, 159, 1, 160, 1, 160, 1, 161, 1, 161, 1,
    162, 1, 162, 1, 163, 1, 163, 1, 164, 1, 164, 1, 165, 1, 165, 1, 166, 1, 166, 1, 167, 1, 167, 1,
    168, 1, 168, 1, 169, 1, 169, 1, 170, 1, 170, 1, 171, 1, 171, 1, 172, 3, 172, 1609, 8, 172, 1, 173,
    3, 173, 1612, 8, 173, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 1619, 8, 174, 1, 175, 1,
    175, 1, 176, 1, 176, 3, 176, 1625, 8, 176, 1, 177, 4, 177, 1628, 8, 177, 11, 177, 12, 177, 1629,
    1, 178, 1, 178, 1, 178, 1, 178, 1, 178, 3, 178, 1637, 8, 178, 1, 179, 1, 179, 1, 180, 1, 180, 3,
    180, 1643, 8, 180, 1, 181, 4, 181, 1646, 8, 181, 11, 181, 12, 181, 1647, 1, 182, 4, 182, 1651,
    8, 182, 11, 182, 12, 182, 1652, 1, 183, 1, 183, 3, 183, 1657, 8, 183, 1, 184, 1, 184, 1, 185,
    1, 185, 3, 185, 1663, 8, 185, 1, 186, 4, 186, 1666, 8, 186, 11, 186, 12, 186, 1667, 1, 187, 1,
    187, 1, 187, 1, 187, 1, 187, 3, 187, 1675, 8, 187, 1, 188, 1, 188, 1, 189, 1, 189, 3, 189, 1681,
    8, 189, 1, 190, 4, 190, 1684, 8, 190, 11, 190, 12, 190, 1685, 1, 191, 1, 191, 3, 191, 1690, 8,
    191, 1, 191, 3, 191, 1693, 8, 191, 1, 191, 1, 191, 3, 191, 1697, 8, 191, 1, 191, 1, 191, 3, 191,
    1701, 8, 191, 1, 192, 1, 192, 1, 192, 1, 193, 1, 193, 3, 193, 1708, 8, 193, 1, 193, 1, 193, 1,
    194, 1, 194, 1, 194, 3, 194, 1715, 8, 194, 1, 195, 1, 195, 3, 195, 1719, 8, 195, 1, 195, 1, 195,
    1, 196, 1, 196, 1, 197, 1, 197, 1, 198, 1, 198, 1, 199, 4, 199, 1730, 8, 199, 11, 199, 12, 199,
    1731, 1, 199, 1, 199, 1, 200, 1, 200, 1, 200, 1, 200, 5, 200, 1740, 8, 200, 10, 200, 12, 200,
    1743, 9, 200, 1, 200, 4, 200, 1746, 8, 200, 11, 200, 12, 200, 1747, 1, 200, 1, 200, 1, 201, 1,
    201, 1, 201, 1, 201, 1, 201, 5, 201, 1757, 8, 201, 10, 201, 12, 201, 1760, 9, 201, 1, 201, 1,
    201, 1, 201, 1, 201, 1, 201, 1, 202, 1, 202, 1, 202, 1, 202, 5, 202, 1771, 8, 202, 10, 202, 12,
    202, 1774, 9, 202, 1, 202, 3, 202, 1777, 8, 202, 1, 202, 1, 202, 1, 203, 4, 203, 1782, 8, 203,
    11, 203, 12, 203, 1783, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 203, 1, 204, 4, 204, 1793,
    8, 204, 11, 204, 12, 204, 1794, 1, 204, 1, 204, 1, 204, 1, 204, 1, 205, 1, 205, 1, 205, 1, 205,
    1, 205, 1, 205, 1, 206, 1, 206, 1, 206, 1, 206, 1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 1, 207,
    1, 207, 1, 208, 1, 208, 1, 208, 1, 208, 1, 209, 1, 209, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
    1, 210, 1, 210, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 212, 1, 212, 1, 213, 1, 213,
    4, 213, 1841, 8, 213, 11, 213, 12, 213, 1842, 1, 213, 1, 213, 1, 214, 4, 214, 1848, 8, 214, 11,
    214, 12, 214, 1849, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 4, 215, 1857, 8, 215, 11, 215, 12,
    215, 1858, 1, 215, 1, 215, 1, 216, 4, 216, 1864, 8, 216, 11, 216, 12, 216, 1865, 1, 216, 1, 216,
    3, 216, 1870, 8, 216, 3, 216, 1872, 8, 216, 1, 217, 4, 217, 1875, 8, 217, 11, 217, 12, 217, 1876,
    1, 218, 1, 218, 3, 218, 1881, 8, 218, 1, 219, 1, 219, 4, 219, 1885, 8, 219, 11, 219, 12, 219,
    1886, 1, 219, 1, 219, 3, 219, 1891, 8, 219, 1, 219, 3, 219, 1894, 8, 219, 1, 220, 1, 220, 5, 220,
    1898, 8, 220, 10, 220, 12, 220, 1901, 9, 220, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221,
    1, 221, 3, 221, 1910, 8, 221, 1, 222, 1, 222, 3, 222, 1914, 8, 222, 1, 222, 3, 222, 1917, 8, 222,
    1, 222, 3, 222, 1920, 8, 222, 1, 222, 3, 222, 1923, 8, 222, 1, 222, 3, 222, 1926, 8, 222, 1, 222,
    3, 222, 1929, 8, 222, 1, 222, 3, 222, 1932, 8, 222, 1, 223, 1, 223, 3, 223, 1936, 8, 223, 1, 223,
    1, 223, 1, 224, 1, 224, 1, 225, 1, 225, 1, 225, 3, 225, 1945, 8, 225, 3, 1741, 1758, 1772, 0,
    226, 5, 1, 7, 2, 9, 3, 11, 4, 13, 5, 15, 6, 17, 7, 19, 8, 21, 9, 23, 10, 25, 11, 27, 12, 29, 13, 31,
    14, 33, 15, 35, 16, 37, 17, 39, 18, 41, 19, 43, 20, 45, 21, 47, 22, 49, 23, 51, 24, 53, 25, 55,
    26, 57, 27, 59, 28, 61, 29, 63, 30, 65, 31, 67, 32, 69, 33, 71, 34, 73, 35, 75, 36, 77, 37, 79,
    38, 81, 39, 83, 40, 85, 41, 87, 42, 89, 43, 91, 44, 93, 45, 95, 46, 97, 47, 99, 48, 101, 49, 103,
    50, 105, 51, 107, 52, 109, 53, 111, 54, 113, 55, 115, 56, 117, 57, 119, 58, 121, 59, 123, 60,
    125, 61, 127, 62, 129, 63, 131, 64, 133, 65, 135, 66, 137, 67, 139, 68, 141, 69, 143, 70, 145,
    71, 147, 72, 149, 73, 151, 74, 153, 75, 155, 76, 157, 77, 159, 78, 161, 79, 163, 80, 165, 81,
    167, 82, 169, 83, 171, 84, 173, 85, 175, 86, 177, 87, 179, 88, 181, 89, 183, 90, 185, 91, 187,
    92, 189, 93, 191, 94, 193, 95, 195, 96, 197, 97, 199, 98, 201, 99, 203, 100, 205, 101, 207,
    102, 209, 103, 211, 104, 213, 105, 215, 106, 217, 107, 219, 108, 221, 109, 223, 110, 225,
    111, 227, 112, 229, 113, 231, 114, 233, 115, 235, 116, 237, 117, 239, 118, 241, 119, 243,
    120, 245, 121, 247, 122, 249, 123, 251, 124, 253, 125, 255, 126, 257, 127, 259, 128, 261,
    129, 263, 130, 265, 131, 267, 132, 269, 133, 271, 134, 273, 135, 275, 136, 277, 137, 279,
    0, 281, 0, 283, 0, 285, 0, 287, 0, 289, 138, 291, 139, 293, 140, 295, 141, 297, 142, 299, 143,
    301, 144, 303, 145, 305, 146, 307, 147, 309, 148, 311, 149, 313, 150, 315, 151, 317, 152,
    319, 153, 321, 154, 323, 155, 325, 156, 327, 157, 329, 158, 331, 159, 333, 160, 335, 161,
    337, 162, 339, 163, 341, 164, 343, 165, 345, 166, 347, 167, 349, 168, 351, 169, 353, 170,
    355, 0, 357, 0, 359, 0, 361, 171, 363, 0, 365, 0, 367, 0, 369, 172, 371, 173, 373, 0, 375, 0,
    377, 0, 379, 174, 381, 0, 383, 0, 385, 0, 387, 175, 389, 0, 391, 0, 393, 0, 395, 0, 397, 0, 399,
    0, 401, 0, 403, 176, 405, 177, 407, 178, 409, 179, 411, 180, 413, 181, 415, 182, 417, 183,
    419, 184, 421, 185, 423, 186, 425, 187, 427, 188, 429, 189, 431, 190, 433, 191, 435, 192,
    437, 193, 439, 0, 441, 0, 443, 0, 445, 0, 447, 0, 449, 0, 451, 0, 453, 0, 455, 0, 5, 0, 1, 2, 3,
    4, 20, 49, 0, 65, 90, 95, 95, 97, 122, 168, 168, 170, 170, 173, 173, 175, 175, 178, 181, 183,
    186, 188, 190, 192, 214, 216, 246, 248, 767, 880, 5759, 5761, 6157, 6159, 7615, 7680, 8191,
    8203, 8205, 8234, 8238, 8255, 8256, 8276, 8276, 8288, 8399, 8448, 8591, 9312, 9471, 10102,
    10131, 11264, 11775, 11904, 12287, 12292, 12295, 12321, 12335, 12337, 55295, 63744,
    64829, 64832, 64975, 65008, 65055, 65072, 65092, 65095, 65533, 65536, 131069, 131072,
    196605, 196608, 262141, 262144, 327677, 327680, 393213, 393216, 458749, 458752, 524285,
    524288, 589821, 589824, 655357, 655360, 720893, 720896, 786429, 786432, 851965, 851968,
    917501, 917504, 983037, 5, 0, 48, 57, 768, 879, 7616, 7679, 8400, 8447, 65056, 65071, 22,
    0, 161, 167, 169, 169, 171, 172, 174, 174, 176, 177, 182, 182, 187, 187, 191, 191, 215, 215,
    247, 247, 8214, 8215, 8224, 8231, 8240, 8254, 8257, 8275, 8277, 8286, 8592, 9215, 9472,
    10101, 10132, 11263, 11776, 11903, 12289, 12291, 12296, 12320, 12336, 12336, 6, 0, 768,
    879, 7616, 7679, 8400, 8447, 65024, 65039, 65056, 65071, 917760, 917999, 1, 0, 48, 49,
    1, 0, 48, 55, 1, 0, 48, 57, 3, 0, 48, 57, 65, 70, 97, 102, 2, 0, 69, 69, 101, 101, 2, 0, 80, 80, 112,
    112, 2, 0, 43, 43, 45, 45, 3, 0, 0, 0, 9, 13, 32, 32, 2, 0, 10, 10, 13, 13, 1, 1, 10, 10, 3, 0, 10,
    10, 13, 13, 34, 34, 1, 0, 34, 34, 4, 0, 10, 10, 13, 13, 34, 34, 92, 92, 2, 0, 34, 34, 92, 92, 8, 0,
    34, 34, 39, 39, 48, 48, 92, 92, 110, 110, 114, 114, 116, 116, 8220, 8220, 2, 0, 9, 9, 32, 32,
    1965, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 13, 1, 0, 0, 0, 0, 15,
    1, 0, 0, 0, 0, 17, 1, 0, 0, 0, 0, 19, 1, 0, 0, 0, 0, 21, 1, 0, 0, 0, 0, 23, 1, 0, 0, 0, 0, 25, 1, 0, 0, 0,
    0, 27, 1, 0, 0, 0, 0, 29, 1, 0, 0, 0, 0, 31, 1, 0, 0, 0, 0, 33, 1, 0, 0, 0, 0, 35, 1, 0, 0, 0, 0, 37, 1,
    0, 0, 0, 0, 39, 1, 0, 0, 0, 0, 41, 1, 0, 0, 0, 0, 43, 1, 0, 0, 0, 0, 45, 1, 0, 0, 0, 0, 47, 1, 0, 0, 0, 0,
    49, 1, 0, 0, 0, 0, 51, 1, 0, 0, 0, 0, 53, 1, 0, 0, 0, 0, 55, 1, 0, 0, 0, 0, 57, 1, 0, 0, 0, 0, 59, 1, 0,
    0, 0, 0, 61, 1, 0, 0, 0, 0, 63, 1, 0, 0, 0, 0, 65, 1, 0, 0, 0, 0, 67, 1, 0, 0, 0, 0, 69, 1, 0, 0, 0, 0, 71,
    1, 0, 0, 0, 0, 73, 1, 0, 0, 0, 0, 75, 1, 0, 0, 0, 0, 77, 1, 0, 0, 0, 0, 79, 1, 0, 0, 0, 0, 81, 1, 0, 0, 0,
    0, 83, 1, 0, 0, 0, 0, 85, 1, 0, 0, 0, 0, 87, 1, 0, 0, 0, 0, 89, 1, 0, 0, 0, 0, 91, 1, 0, 0, 0, 0, 93, 1,
    0, 0, 0, 0, 95, 1, 0, 0, 0, 0, 97, 1, 0, 0, 0, 0, 99, 1, 0, 0, 0, 0, 101, 1, 0, 0, 0, 0, 103, 1, 0, 0, 0,
    0, 105, 1, 0, 0, 0, 0, 107, 1, 0, 0, 0, 0, 109, 1, 0, 0, 0, 0, 111, 1, 0, 0, 0, 0, 113, 1, 0, 0, 0, 0,
    115, 1, 0, 0, 0, 0, 117, 1, 0, 0, 0, 0, 119, 1, 0, 0, 0, 0, 121, 1, 0, 0, 0, 0, 123, 1, 0, 0, 0, 0, 125,
    1, 0, 0, 0, 0, 127, 1, 0, 0, 0, 0, 129, 1, 0, 0, 0, 0, 131, 1, 0, 0, 0, 0, 133, 1, 0, 0, 0, 0, 135, 1,
    0, 0, 0, 0, 137, 1, 0, 0, 0, 0, 139, 1, 0, 0, 0, 0, 141, 1, 0, 0, 0, 0, 143, 1, 0, 0, 0, 0, 145, 1, 0,
    0, 0, 0, 147, 1, 0, 0, 0, 0, 149, 1, 0, 0, 0, 0, 151, 1, 0, 0, 0, 0, 153, 1, 0, 0, 0, 0, 155, 1, 0, 0,
    0, 0, 157, 1, 0, 0, 0, 0, 159, 1, 0, 0, 0, 0, 161, 1, 0, 0, 0, 0, 163, 1, 0, 0, 0, 0, 165, 1, 0, 0, 0,
    0, 167, 1, 0, 0, 0, 0, 169, 1, 0, 0, 0, 0, 171, 1, 0, 0, 0, 0, 173, 1, 0, 0, 0, 0, 175, 1, 0, 0, 0, 0,
    177, 1, 0, 0, 0, 0, 179, 1, 0, 0, 0, 0, 181, 1, 0, 0, 0, 0, 183, 1, 0, 0, 0, 0, 185, 1, 0, 0, 0, 0, 187,
    1, 0, 0, 0, 0, 189, 1, 0, 0, 0, 0, 191, 1, 0, 0, 0, 0, 193, 1, 0, 0, 0, 0, 195, 1, 0, 0, 0, 0, 197, 1,
    0, 0, 0, 0, 199, 1, 0, 0, 0, 0, 201, 1, 0, 0, 0, 0, 203, 1, 0, 0, 0, 0, 205, 1, 0, 0, 0, 0, 207, 1, 0,
    0, 0, 0, 209, 1, 0, 0, 0, 0, 211, 1, 0, 0, 0, 0, 213, 1, 0, 0, 0, 0, 215, 1, 0, 0, 0, 0, 217, 1, 0, 0,
    0, 0, 219, 1, 0, 0, 0, 0, 221, 1, 0, 0, 0, 0, 223, 1, 0, 0, 0, 0, 225, 1, 0, 0, 0, 0, 227, 1, 0, 0, 0,
    0, 229, 1, 0, 0, 0, 0, 231, 1, 0, 0, 0, 0, 233, 1, 0, 0, 0, 0, 235, 1, 0, 0, 0, 0, 237, 1, 0, 0, 0, 0,
    239, 1, 0, 0, 0, 0, 241, 1, 0, 0, 0, 0, 243, 1, 0, 0, 0, 0, 245, 1, 0, 0, 0, 0, 247, 1, 0, 0, 0, 0, 249,
    1, 0, 0, 0, 0, 251, 1, 0, 0, 0, 0, 253, 1, 0, 0, 0, 0, 255, 1, 0, 0, 0, 0, 257, 1, 0, 0, 0, 0, 259, 1,
    0, 0, 0, 0, 261, 1, 0, 0, 0, 0, 263, 1, 0, 0, 0, 0, 265, 1, 0, 0, 0, 0, 267, 1, 0, 0, 0, 0, 269, 1, 0,
    0, 0, 0, 271, 1, 0, 0, 0, 0, 273, 1, 0, 0, 0, 0, 275, 1, 0, 0, 0, 0, 277, 1, 0, 0, 0, 0, 289, 1, 0, 0,
    0, 0, 291, 1, 0, 0, 0, 0, 293, 1, 0, 0, 0, 0, 295, 1, 0, 0, 0, 0, 297, 1, 0, 0, 0, 0, 299, 1, 0, 0, 0,
    0, 301, 1, 0, 0, 0, 0, 303, 1, 0, 0, 0, 0, 305, 1, 0, 0, 0, 0, 307, 1, 0, 0, 0, 0, 309, 1, 0, 0, 0, 0,
    311, 1, 0, 0, 0, 0, 313, 1, 0, 0, 0, 0, 315, 1, 0, 0, 0, 0, 317, 1, 0, 0, 0, 0, 319, 1, 0, 0, 0, 0, 321,
    1, 0, 0, 0, 0, 323, 1, 0, 0, 0, 0, 325, 1, 0, 0, 0, 0, 327, 1, 0, 0, 0, 0, 329, 1, 0, 0, 0, 0, 331, 1,
    0, 0, 0, 0, 333, 1, 0, 0, 0, 0, 335, 1, 0, 0, 0, 0, 337, 1, 0, 0, 0, 0, 339, 1, 0, 0, 0, 0, 341, 1, 0,
    0, 0, 0, 343, 1, 0, 0, 0, 0, 345, 1, 0, 0, 0, 0, 347, 1, 0, 0, 0, 0, 349, 1, 0, 0, 0, 0, 351, 1, 0, 0,
    0, 0, 353, 1, 0, 0, 0, 0, 361, 1, 0, 0, 0, 0, 369, 1, 0, 0, 0, 0, 371, 1, 0, 0, 0, 0, 379, 1, 0, 0, 0,
    0, 387, 1, 0, 0, 0, 0, 403, 1, 0, 0, 0, 0, 405, 1, 0, 0, 0, 0, 407, 1, 0, 0, 0, 0, 409, 1, 0, 0, 0, 0,
    411, 1, 0, 0, 0, 0, 413, 1, 0, 0, 0, 0, 415, 1, 0, 0, 0, 0, 417, 1, 0, 0, 0, 1, 419, 1, 0, 0, 0, 1, 421,
    1, 0, 0, 0, 1, 423, 1, 0, 0, 0, 2, 425, 1, 0, 0, 0, 2, 427, 1, 0, 0, 0, 2, 429, 1, 0, 0, 0, 3, 431, 1,
    0, 0, 0, 3, 433, 1, 0, 0, 0, 4, 435, 1, 0, 0, 0, 4, 437, 1, 0, 0, 0, 5, 457, 1, 0, 0, 0, 7, 460, 1, 0,
    0, 0, 9, 466, 1, 0, 0, 0, 11, 472, 1, 0, 0, 0, 13, 477, 1, 0, 0, 0, 15, 483, 1, 0, 0, 0, 17, 489, 1,
    0, 0, 0, 19, 498, 1, 0, 0, 0, 21, 506, 1, 0, 0, 0, 23, 512, 1, 0, 0, 0, 25, 515, 1, 0, 0, 0, 27, 521,
    1, 0, 0, 0, 29, 526, 1, 0, 0, 0, 31, 531, 1, 0, 0, 0, 33, 535, 1, 0, 0, 0, 35, 547, 1, 0, 0, 0, 37, 552,
    1, 0, 0, 0, 39, 555, 1, 0, 0, 0, 41, 558, 1, 0, 0, 0, 43, 565, 1, 0, 0, 0, 45, 574, 1, 0, 0, 0, 47, 580,
    1, 0, 0, 0, 49, 585, 1, 0, 0, 0, 51, 593, 1, 0, 0, 0, 53, 600, 1, 0, 0, 0, 55, 606, 1, 0, 0, 0, 57, 612,
    1, 0, 0, 0, 59, 616, 1, 0, 0, 0, 61, 620, 1, 0, 0, 0, 63, 629, 1, 0, 0, 0, 65, 633, 1, 0, 0, 0, 67, 637,
    1, 0, 0, 0, 69, 645, 1, 0, 0, 0, 71, 652, 1, 0, 0, 0, 73, 659, 1, 0, 0, 0, 75, 666, 1, 0, 0, 0, 77, 673,
    1, 0, 0, 0, 79, 680, 1, 0, 0, 0, 81, 686, 1, 0, 0, 0, 83, 693, 1, 0, 0, 0, 85, 702, 1, 0, 0, 0, 87, 711,
    1, 0, 0, 0, 89, 716, 1, 0, 0, 0, 91, 723, 1, 0, 0, 0, 93, 738, 1, 0, 0, 0, 95, 748, 1, 0, 0, 0, 97, 758,
    1, 0, 0, 0, 99, 765, 1, 0, 0, 0, 101, 771, 1, 0, 0, 0, 103, 776, 1, 0, 0, 0, 105, 782, 1, 0, 0, 0, 107,
    787, 1, 0, 0, 0, 109, 803, 1, 0, 0, 0, 111, 814, 1, 0, 0, 0, 113, 824, 1, 0, 0, 0, 115, 835, 1, 0,
    0, 0, 117, 849, 1, 0, 0, 0, 119, 857, 1, 0, 0, 0, 121, 866, 1, 0, 0, 0, 123, 876, 1, 0, 0, 0, 125,
    879, 1, 0, 0, 0, 127, 884, 1, 0, 0, 0, 129, 890, 1, 0, 0, 0, 131, 899, 1, 0, 0, 0, 133, 909, 1, 0,
    0, 0, 135, 927, 1, 0, 0, 0, 137, 939, 1, 0, 0, 0, 139, 947, 1, 0, 0, 0, 141, 952, 1, 0, 0, 0, 143,
    961, 1, 0, 0, 0, 145, 970, 1, 0, 0, 0, 147, 979, 1, 0, 0, 0, 149, 986, 1, 0, 0, 0, 151, 991, 1, 0,
    0, 0, 153, 999, 1, 0, 0, 0, 155, 1004, 1, 0, 0, 0, 157, 1011, 1, 0, 0, 0, 159, 1020, 1, 0, 0, 0, 161,
    1032, 1, 0, 0, 0, 163, 1044, 1, 0, 0, 0, 165, 1047, 1, 0, 0, 0, 167, 1051, 1, 0, 0, 0, 169, 1057,
    1, 0, 0, 0, 171, 1061, 1, 0, 0, 0, 173, 1067, 1, 0, 0, 0, 175, 1071, 1, 0, 0, 0, 177, 1076, 1, 0,
    0, 0, 179, 1082, 1, 0, 0, 0, 181, 1095, 1, 0, 0, 0, 183, 1100, 1, 0, 0, 0, 185, 1104, 1, 0, 0, 0,
    187, 1110, 1, 0, 0, 0, 189, 1115, 1, 0, 0, 0, 191, 1120, 1, 0, 0, 0, 193, 1131, 1, 0, 0, 0, 195,
    1136, 1, 0, 0, 0, 197, 1141, 1, 0, 0, 0, 199, 1147, 1, 0, 0, 0, 201, 1151, 1, 0, 0, 0, 203, 1155,
    1, 0, 0, 0, 205, 1163, 1, 0, 0, 0, 207, 1168, 1, 0, 0, 0, 209, 1174, 1, 0, 0, 0, 211, 1182, 1, 0,
    0, 0, 213, 1187, 1, 0, 0, 0, 215, 1194, 1, 0, 0, 0, 217, 1198, 1, 0, 0, 0, 219, 1204, 1, 0, 0, 0,
    221, 1214, 1, 0, 0, 0, 223, 1226, 1, 0, 0, 0, 225, 1250, 1, 0, 0, 0, 227, 1282, 1, 0, 0, 0, 229,
    1308, 1, 0, 0, 0, 231, 1324, 1, 0, 0, 0, 233, 1329, 1, 0, 0, 0, 235, 1334, 1, 0, 0, 0, 237, 1341,
    1, 0, 0, 0, 239, 1350, 1, 0, 0, 0, 241, 1361, 1, 0, 0, 0, 243, 1365, 1, 0, 0, 0, 245, 1373, 1, 0,
    0, 0, 247, 1379, 1, 0, 0, 0, 249, 1386, 1, 0, 0, 0, 251, 1392, 1, 0, 0, 0, 253, 1400, 1, 0, 0, 0,
    255, 1410, 1, 0, 0, 0, 257, 1416, 1, 0, 0, 0, 259, 1424, 1, 0, 0, 0, 261, 1434, 1, 0, 0, 0, 263,
    1445, 1, 0, 0, 0, 265, 1455, 1, 0, 0, 0, 267, 1464, 1, 0, 0, 0, 269, 1478, 1, 0, 0, 0, 271, 1491,
    1, 0, 0, 0, 273, 1505, 1, 0, 0, 0, 275, 1512, 1, 0, 0, 0, 277, 1525, 1, 0, 0, 0, 279, 1528, 1, 0,
    0, 0, 281, 1532, 1, 0, 0, 0, 283, 1535, 1, 0, 0, 0, 285, 1539, 1, 0, 0, 0, 287, 1542, 1, 0, 0, 0,
    289, 1545, 1, 0, 0, 0, 291, 1547, 1, 0, 0, 0, 293, 1549, 1, 0, 0, 0, 295, 1552, 1, 0, 0, 0, 297,
    1554, 1, 0, 0, 0, 299, 1556, 1, 0, 0, 0, 301, 1559, 1, 0, 0, 0, 303, 1561, 1, 0, 0, 0, 305, 1563,
    1, 0, 0, 0, 307, 1565, 1, 0, 0, 0, 309, 1567, 1, 0, 0, 0, 311, 1569, 1, 0, 0, 0, 313, 1571, 1, 0,
    0, 0, 315, 1573, 1, 0, 0, 0, 317, 1575, 1, 0, 0, 0, 319, 1577, 1, 0, 0, 0, 321, 1579, 1, 0, 0, 0,
    323, 1581, 1, 0, 0, 0, 325, 1583, 1, 0, 0, 0, 327, 1585, 1, 0, 0, 0, 329, 1587, 1, 0, 0, 0, 331,
    1589, 1, 0, 0, 0, 333, 1591, 1, 0, 0, 0, 335, 1593, 1, 0, 0, 0, 337, 1595, 1, 0, 0, 0, 339, 1597,
    1, 0, 0, 0, 341, 1599, 1, 0, 0, 0, 343, 1601, 1, 0, 0, 0, 345, 1603, 1, 0, 0, 0, 347, 1605, 1, 0,
    0, 0, 349, 1608, 1, 0, 0, 0, 351, 1611, 1, 0, 0, 0, 353, 1613, 1, 0, 0, 0, 355, 1620, 1, 0, 0, 0,
    357, 1624, 1, 0, 0, 0, 359, 1627, 1, 0, 0, 0, 361, 1631, 1, 0, 0, 0, 363, 1638, 1, 0, 0, 0, 365,
    1642, 1, 0, 0, 0, 367, 1645, 1, 0, 0, 0, 369, 1650, 1, 0, 0, 0, 371, 1654, 1, 0, 0, 0, 373, 1658,
    1, 0, 0, 0, 375, 1662, 1, 0, 0, 0, 377, 1665, 1, 0, 0, 0, 379, 1669, 1, 0, 0, 0, 381, 1676, 1, 0,
    0, 0, 383, 1680, 1, 0, 0, 0, 385, 1683, 1, 0, 0, 0, 387, 1700, 1, 0, 0, 0, 389, 1702, 1, 0, 0, 0,
    391, 1705, 1, 0, 0, 0, 393, 1711, 1, 0, 0, 0, 395, 1716, 1, 0, 0, 0, 397, 1722, 1, 0, 0, 0, 399,
    1724, 1, 0, 0, 0, 401, 1726, 1, 0, 0, 0, 403, 1729, 1, 0, 0, 0, 405, 1735, 1, 0, 0, 0, 407, 1751,
    1, 0, 0, 0, 409, 1766, 1, 0, 0, 0, 411, 1781, 1, 0, 0, 0, 413, 1792, 1, 0, 0, 0, 415, 1800, 1, 0,
    0, 0, 417, 1806, 1, 0, 0, 0, 419, 1810, 1, 0, 0, 0, 421, 1817, 1, 0, 0, 0, 423, 1821, 1, 0, 0, 0,
    425, 1823, 1, 0, 0, 0, 427, 1830, 1, 0, 0, 0, 429, 1836, 1, 0, 0, 0, 431, 1838, 1, 0, 0, 0, 433,
    1847, 1, 0, 0, 0, 435, 1851, 1, 0, 0, 0, 437, 1871, 1, 0, 0, 0, 439, 1874, 1, 0, 0, 0, 441, 1880,
    1, 0, 0, 0, 443, 1893, 1, 0, 0, 0, 445, 1895, 1, 0, 0, 0, 447, 1902, 1, 0, 0, 0, 449, 1911, 1, 0,
    0, 0, 451, 1933, 1, 0, 0, 0, 453, 1939, 1, 0, 0, 0, 455, 1944, 1, 0, 0, 0, 457, 458, 5, 97, 0, 0,
    458, 459, 5, 115, 0, 0, 459, 6, 1, 0, 0, 0, 460, 461, 5, 97, 0, 0, 461, 462, 5, 108, 0, 0, 462, 463,
    5, 112, 0, 0, 463, 464, 5, 104, 0, 0, 464, 465, 5, 97, 0, 0, 465, 8, 1, 0, 0, 0, 466, 467, 5, 98,
    0, 0, 467, 468, 5, 114, 0, 0, 468, 469, 5, 101, 0, 0, 469, 470, 5, 97, 0, 0, 470, 471, 5, 107, 0,
    0, 471, 10, 1, 0, 0, 0, 472, 473, 5, 99, 0, 0, 473, 474, 5, 97, 0, 0, 474, 475, 5, 115, 0, 0, 475,
    476, 5, 101, 0, 0, 476, 12, 1, 0, 0, 0, 477, 478, 5, 99, 0, 0, 478, 479, 5, 97, 0, 0, 479, 480, 5,
    116, 0, 0, 480, 481, 5, 99, 0, 0, 481, 482, 5, 104, 0, 0, 482, 14, 1, 0, 0, 0, 483, 484, 5, 99, 0,
    0, 484, 485, 5, 108, 0, 0, 485, 486, 5, 97, 0, 0, 486, 487, 5, 115, 0, 0, 487, 488, 5, 115, 0, 0,
    488, 16, 1, 0, 0, 0, 489, 490, 5, 99, 0, 0, 490, 491, 5, 111, 0, 0, 491, 492, 5, 110, 0, 0, 492,
    493, 5, 116, 0, 0, 493, 494, 5, 105, 0, 0, 494, 495, 5, 110, 0, 0, 495, 496, 5, 117, 0, 0, 496,
    497, 5, 101, 0, 0, 497, 18, 1, 0, 0, 0, 498, 499, 5, 100, 0, 0, 499, 500, 5, 101, 0, 0, 500, 501,
    5, 102, 0, 0, 501, 502, 5, 97, 0, 0, 502, 503, 5, 117, 0, 0, 503, 504, 5, 108, 0, 0, 504, 505, 5,
    116, 0, 0, 505, 20, 1, 0, 0, 0, 506, 507, 5, 100, 0, 0, 507, 508, 5, 101, 0, 0, 508, 509, 5, 102,
    0, 0, 509, 510, 5, 101, 0, 0, 510, 511, 5, 114, 0, 0, 511, 22, 1, 0, 0, 0, 512, 513, 5, 100, 0, 0,
    513, 514, 5, 111, 0, 0, 514, 24, 1, 0, 0, 0, 515, 516, 5, 103, 0, 0, 516, 517, 5, 117, 0, 0, 517,
    518, 5, 97, 0, 0, 518, 519, 5, 114, 0, 0, 519, 520, 5, 100, 0, 0, 520, 26, 1, 0, 0, 0, 521, 522,
    5, 101, 0, 0, 522, 523, 5, 108, 0, 0, 523, 524, 5, 115, 0, 0, 524, 525, 5, 101, 0, 0, 525, 28, 1,
    0, 0, 0, 526, 527, 5, 101, 0, 0, 527, 528, 5, 110, 0, 0, 528, 529, 5, 117, 0, 0, 529, 530, 5, 109,
    0, 0, 530, 30, 1, 0, 0, 0, 531, 532, 5, 102, 0, 0, 532, 533, 5, 111, 0, 0, 533, 534, 5, 114, 0, 0,
    534, 32, 1, 0, 0, 0, 535, 536, 5, 102, 0, 0, 536, 537, 5, 97, 0, 0, 537, 538, 5, 108, 0, 0, 538,
    539, 5, 108, 0, 0, 539, 540, 5, 116, 0, 0, 540, 541, 5, 104, 0, 0, 541, 542, 5, 114, 0, 0, 542,
    543, 5, 111, 0, 0, 543, 544, 5, 117, 0, 0, 544, 545, 5, 103, 0, 0, 545, 546, 5, 104, 0, 0, 546,
    34, 1, 0, 0, 0, 547, 548, 5, 102, 0, 0, 548, 549, 5, 117, 0, 0, 549, 550, 5, 110, 0, 0, 550, 551,
    5, 99, 0, 0, 551, 36, 1, 0, 0, 0, 552, 553, 5, 105, 0, 0, 553, 554, 5, 110, 0, 0, 554, 38, 1, 0, 0,
    0, 555, 556, 5, 105, 0, 0, 556, 557, 5, 102, 0, 0, 557, 40, 1, 0, 0, 0, 558, 559, 5, 105, 0, 0, 559,
    560, 5, 109, 0, 0, 560, 561, 5, 112, 0, 0, 561, 562, 5, 111, 0, 0, 562, 563, 5, 114, 0, 0, 563,
    564, 5, 116, 0, 0, 564, 42, 1, 0, 0, 0, 565, 566, 5, 105, 0, 0, 566, 567, 5, 110, 0, 0, 567, 568,
    5, 116, 0, 0, 568, 569, 5, 101, 0, 0, 569, 570, 5, 114, 0, 0, 570, 571, 5, 110, 0, 0, 571, 572,
    5, 97, 0, 0, 572, 573, 5, 108, 0, 0, 573, 44, 1, 0, 0, 0, 574, 575, 5, 102, 0, 0, 575, 576, 5, 105,
    0, 0, 576, 577, 5, 110, 0, 0, 577, 578, 5, 97, 0, 0, 578, 579, 5, 108, 0, 0, 579, 46, 1, 0, 0, 0,
    580, 581, 5, 111, 0, 0, 581, 582, 5, 112, 0, 0, 582, 583, 5, 101, 0, 0, 583, 584, 5, 110, 0, 0,
    584, 48, 1, 0, 0, 0, 585, 586, 5, 112, 0, 0, 586, 587, 5, 114, 0, 0, 587, 588, 5, 105, 0, 0, 588,
    589, 5, 118, 0, 0, 589, 590, 5, 97, 0, 0, 590, 591, 5, 116, 0, 0, 591, 592, 5, 101, 0, 0, 592, 50,
    1, 0, 0, 0, 593, 594, 5, 112, 0, 0, 594, 595, 5, 117, 0, 0, 595, 596, 5, 98, 0, 0, 596, 597, 5, 108,
    0, 0, 597, 598, 5, 105, 0, 0, 598, 599, 5, 99, 0, 0, 599, 52, 1, 0, 0, 0, 600, 601, 5, 119, 0, 0,
    601, 602, 5, 104, 0, 0, 602, 603, 5, 101, 0, 0, 603, 604, 5, 114, 0, 0, 604, 605, 5, 101, 0, 0,
    605, 54, 1, 0, 0, 0, 606, 607, 5, 119, 0, 0, 607, 608, 5, 104, 0, 0, 608, 609, 5, 105, 0, 0, 609,
    610, 5, 108, 0, 0, 610, 611, 5, 101, 0, 0, 611, 56, 1, 0, 0, 0, 612, 613, 5, 108, 0, 0, 613, 614,
    5, 101, 0, 0, 614, 615, 5, 116, 0, 0, 615, 58, 1, 0, 0, 0, 616, 617, 5, 118, 0, 0, 617, 618, 5, 97,
    0, 0, 618, 619, 5, 114, 0, 0, 619, 60, 1, 0, 0, 0, 620, 621, 5, 112, 0, 0, 621, 622, 5, 114, 0, 0,
    622, 623, 5, 111, 0, 0, 623, 624, 5, 116, 0, 0, 624, 625, 5, 111, 0, 0, 625, 626, 5, 99, 0, 0, 626,
    627, 5, 111, 0, 0, 627, 628, 5, 108, 0, 0, 628, 62, 1, 0, 0, 0, 629, 630, 5, 103, 0, 0, 630, 631,
    5, 101, 0, 0, 631, 632, 5, 116, 0, 0, 632, 64, 1, 0, 0, 0, 633, 634, 5, 115, 0, 0, 634, 635, 5, 101,
    0, 0, 635, 636, 5, 116, 0, 0, 636, 66, 1, 0, 0, 0, 637, 638, 5, 119, 0, 0, 638, 639, 5, 105, 0, 0,
    639, 640, 5, 108, 0, 0, 640, 641, 5, 108, 0, 0, 641, 642, 5, 83, 0, 0, 642, 643, 5, 101, 0, 0, 643,
    644, 5, 116, 0, 0, 644, 68, 1, 0, 0, 0, 645, 646, 5, 100, 0, 0, 646, 647, 5, 105, 0, 0, 647, 648,
    5, 100, 0, 0, 648, 649, 5, 83, 0, 0, 649, 650, 5, 101, 0, 0, 650, 651, 5, 116, 0, 0, 651, 70, 1,
    0, 0, 0, 652, 653, 5, 114, 0, 0, 653, 654, 5, 101, 0, 0, 654, 655, 5, 112, 0, 0, 655, 656, 5, 101,
    0, 0, 656, 657, 5, 97, 0, 0, 657, 658, 5, 116, 0, 0, 658, 72, 1, 0, 0, 0, 659, 660, 5, 115, 0, 0,
    660, 661, 5, 119, 0, 0, 661, 662, 5, 105, 0, 0, 662, 663, 5, 116, 0, 0, 663, 664, 5, 99, 0, 0, 664,
    665, 5, 104, 0, 0, 665, 74, 1, 0, 0, 0, 666, 667, 5, 115, 0, 0, 667, 668, 5, 116, 0, 0, 668, 669,
    5, 114, 0, 0, 669, 670, 5, 117, 0, 0, 670, 671, 5, 99, 0, 0, 671, 672, 5, 116, 0, 0, 672, 76, 1,
    0, 0, 0, 673, 674, 5, 114, 0, 0, 674, 675, 5, 101, 0, 0, 675, 676, 5, 116, 0, 0, 676, 677, 5, 117,
    0, 0, 677, 678, 5, 114, 0, 0, 678, 679, 5, 110, 0, 0, 679, 78, 1, 0, 0, 0, 680, 681, 5, 116, 0, 0,
    681, 682, 5, 104, 0, 0, 682, 683, 5, 114, 0, 0, 683, 684, 5, 111, 0, 0, 684, 685, 5, 119, 0, 0,
    685, 80, 1, 0, 0, 0, 686, 687, 5, 116, 0, 0, 687, 688, 5, 104, 0, 0, 688, 689, 5, 114, 0, 0, 689,
    690, 5, 111, 0, 0, 690, 691, 5, 119, 0, 0, 691, 692, 5, 115, 0, 0, 692, 82, 1, 0, 0, 0, 693, 694,
    5, 114, 0, 0, 694, 695, 5, 101, 0, 0, 695, 696, 5, 116, 0, 0, 696, 697, 5, 104, 0, 0, 697, 698,
    5, 114, 0, 0, 698, 699, 5, 111, 0, 0, 699, 700, 5, 119, 0, 0, 700, 701, 5, 115, 0, 0, 701, 84, 1,
    0, 0, 0, 702, 703, 5, 105, 0, 0, 703, 704, 5, 110, 0, 0, 704, 705, 5, 100, 0, 0, 705, 706, 5, 105,
    0, 0, 706, 707, 5, 114, 0, 0, 707, 708, 5, 101, 0, 0, 708, 709, 5, 99, 0, 0, 709, 710, 5, 116, 0,
    0, 710, 86, 1, 0, 0, 0, 711, 712, 5, 105, 0, 0, 712, 713, 5, 110, 0, 0, 713, 714, 5, 105, 0, 0, 714,
    715, 5, 116, 0, 0, 715, 88, 1, 0, 0, 0, 716, 717, 5, 100, 0, 0, 717, 718, 5, 101, 0, 0, 718, 719,
    5, 105, 0, 0, 719, 720, 5, 110, 0, 0, 720, 721, 5, 105, 0, 0, 721, 722, 5, 116, 0, 0, 722, 90, 1,
    0, 0, 0, 723, 724, 5, 97, 0, 0, 724, 725, 5, 115, 0, 0, 725, 726, 5, 115, 0, 0, 726, 727, 5, 111,
    0, 0, 727, 728, 5, 99, 0, 0, 728, 729, 5, 105, 0, 0, 729, 730, 5, 97, 0, 0, 730, 731, 5, 116, 0,
    0, 731, 732, 5, 101, 0, 0, 732, 733, 5, 100, 0, 0, 733, 734, 5, 116, 0, 0, 734, 735, 5, 121, 0,
    0, 735, 736, 5, 112, 0, 0, 736, 737, 5, 101, 0, 0, 737, 92, 1, 0, 0, 0, 738, 739, 5, 101, 0, 0, 739,
    740, 5, 120, 0, 0, 740, 741, 5, 116, 0, 0, 741, 742, 5, 101, 0, 0, 742, 743, 5, 110, 0, 0, 743,
    744, 5, 115, 0, 0, 744, 745, 5, 105, 0, 0, 745, 746, 5, 111, 0, 0, 746, 747, 5, 110, 0, 0, 747,
    94, 1, 0, 0, 0, 748, 749, 5, 115, 0, 0, 749, 750, 5, 117, 0, 0, 750, 751, 5, 98, 0, 0, 751, 752,
    5, 115, 0, 0, 752, 753, 5, 99, 0, 0, 753, 754, 5, 114, 0, 0, 754, 755, 5, 105, 0, 0, 755, 756, 5,
    112, 0, 0, 756, 757, 5, 116, 0, 0, 757, 96, 1, 0, 0, 0, 758, 759, 5, 112, 0, 0, 759, 760, 5, 114,
    0, 0, 760, 761, 5, 101, 0, 0, 761, 762, 5, 102, 0, 0, 762, 763, 5, 105, 0, 0, 763, 764, 5, 120,
    0, 0, 764, 98, 1, 0, 0, 0, 765, 766, 5, 105, 0, 0, 766, 767, 5, 110, 0, 0, 767, 768, 5, 102, 0, 0,
    768, 769, 5, 105, 0, 0, 769, 770, 5, 120, 0, 0, 770, 100, 1, 0, 0, 0, 771, 772, 5, 108, 0, 0, 772,
    773, 5, 101, 0, 0, 773, 774, 5, 102, 0, 0, 774, 775, 5, 116, 0, 0, 775, 102, 1, 0, 0, 0, 776, 777,
    5, 114, 0, 0, 777, 778, 5, 105, 0, 0, 778, 779, 5, 103, 0, 0, 779, 780, 5, 104, 0, 0, 780, 781,
    5, 116, 0, 0, 781, 104, 1, 0, 0, 0, 782, 783, 5, 110, 0, 0, 783, 784, 5, 111, 0, 0, 784, 785, 5,
    110, 0, 0, 785, 786, 5, 101, 0, 0, 786, 106, 1, 0, 0, 0, 787, 788, 5, 112, 0, 0, 788, 789, 5, 114,
    0, 0, 789, 790, 5, 101, 0, 0, 790, 791, 5, 99, 0, 0, 791, 792, 5, 101, 0, 0, 792, 793, 5, 100, 0,
    0, 793, 794, 5, 101, 0, 0, 794, 795, 5, 110, 0, 0, 795, 796, 5, 99, 0, 0, 796, 797, 5, 101, 0, 0,
    797, 798, 5, 103, 0, 0, 798, 799, 5, 114, 0, 0, 799, 800, 5, 111, 0, 0, 800, 801, 5, 117, 0, 0,
    801, 802, 5, 112, 0, 0, 802, 108, 1, 0, 0, 0, 803, 804, 5, 104, 0, 0, 804, 805, 5, 105, 0, 0, 805,
    806, 5, 103, 0, 0, 806, 807, 5, 104, 0, 0, 807, 808, 5, 101, 0, 0, 808, 809, 5, 114, 0, 0, 809,
    810, 5, 84, 0, 0, 810, 811, 5, 104, 0, 0, 811, 812, 5, 97, 0, 0, 812, 813, 5, 110, 0, 0, 813, 110,
    1, 0, 0, 0, 814, 815, 5, 108, 0, 0, 815, 816, 5, 111, 0, 0, 816, 817, 5, 119, 0, 0, 817, 818, 5,
    101, 0, 0, 818, 819, 5, 114, 0, 0, 819, 820, 5, 84, 0, 0, 820, 821, 5, 104, 0, 0, 821, 822, 5, 97,
    0, 0, 822, 823, 5, 110, 0, 0, 823, 112, 1, 0, 0, 0, 824, 825, 5, 97, 0, 0, 825, 826, 5, 115, 0, 0,
    826, 827, 5, 115, 0, 0, 827, 828, 5, 105, 0, 0, 828, 829, 5, 103, 0, 0, 829, 830, 5, 110, 0, 0,
    830, 831, 5, 109, 0, 0, 831, 832, 5, 101, 0, 0, 832, 833, 5, 110, 0, 0, 833, 834, 5, 116, 0, 0,
    834, 114, 1, 0, 0, 0, 835, 836, 5, 97, 0, 0, 836, 837, 5, 115, 0, 0, 837, 838, 5, 115, 0, 0, 838,
    839, 5, 111, 0, 0, 839, 840, 5, 99, 0, 0, 840, 841, 5, 105, 0, 0, 841, 842, 5, 97, 0, 0, 842, 843,
    5, 116, 0, 0, 843, 844, 5, 105, 0, 0, 844, 845, 5, 118, 0, 0, 845, 846, 5, 105, 0, 0, 846, 847,
    5, 116, 0, 0, 847, 848, 5, 121, 0, 0, 848, 116, 1, 0, 0, 0, 849, 850, 5, 112, 0, 0, 850, 851, 5,
    111, 0, 0, 851, 852, 5, 115, 0, 0, 852, 853, 5, 116, 0, 0, 853, 854, 5, 102, 0, 0, 854, 855, 5,
    105, 0, 0, 855, 856, 5, 120, 0, 0, 856, 118, 1, 0, 0, 0, 857, 858, 5, 111, 0, 0, 858, 859, 5, 112,
    0, 0, 859, 860, 5, 101, 0, 0, 860, 861, 5, 114, 0, 0, 861, 862, 5, 97, 0, 0, 862, 863, 5, 116, 0,
    0, 863, 864, 5, 111, 0, 0, 864, 865, 5, 114, 0, 0, 865, 120, 1, 0, 0, 0, 866, 867, 5, 116, 0, 0,
    867, 868, 5, 121, 0, 0, 868, 869, 5, 112, 0, 0, 869, 870, 5, 101, 0, 0, 870, 871, 5, 97, 0, 0, 871,
    872, 5, 108, 0, 0, 872, 873, 5, 105, 0, 0, 873, 874, 5, 97, 0, 0, 874, 875, 5, 115, 0, 0, 875, 122,
    1, 0, 0, 0, 876, 877, 5, 111, 0, 0, 877, 878, 5, 115, 0, 0, 878, 124, 1, 0, 0, 0, 879, 880, 5, 97,
    0, 0, 880, 881, 5, 114, 0, 0, 881, 882, 5, 99, 0, 0, 882, 883, 5, 104, 0, 0, 883, 126, 1, 0, 0, 0,
    884, 885, 5, 115, 0, 0, 885, 886, 5, 119, 0, 0, 886, 887, 5, 105, 0, 0, 887, 888, 5, 102, 0, 0,
    888, 889, 5, 116, 0, 0, 889, 128, 1, 0, 0, 0, 890, 891, 5, 99, 0, 0, 891, 892, 5, 111, 0, 0, 892,
    893, 5, 109, 0, 0, 893, 894, 5, 112, 0, 0, 894, 895, 5, 105, 0, 0, 895, 896, 5, 108, 0, 0, 896,
    897, 5, 101, 0, 0, 897, 898, 5, 114, 0, 0, 898, 130, 1, 0, 0, 0, 899, 900, 5, 99, 0, 0, 900, 901,
    5, 97, 0, 0, 901, 902, 5, 110, 0, 0, 902, 903, 5, 73, 0, 0, 903, 904, 5, 109, 0, 0, 904, 905, 5,
    112, 0, 0, 905, 906, 5, 111, 0, 0, 906, 907, 5, 114, 0, 0, 907, 908, 5, 116, 0, 0, 908, 132, 1,
    0, 0, 0, 909, 910, 5, 116, 0, 0, 910, 911, 5, 97, 0, 0, 911, 912, 5, 114, 0, 0, 912, 913, 5, 103,
    0, 0, 913, 914, 5, 101, 0, 0, 914, 915, 5, 116, 0, 0, 915, 916, 5, 69, 0, 0, 916, 917, 5, 110, 0,
    0, 917, 918, 5, 118, 0, 0, 918, 919, 5, 105, 0, 0, 919, 920, 5, 114, 0, 0, 920, 921, 5, 111, 0,
    0, 921, 922, 5, 110, 0, 0, 922, 923, 5, 109, 0, 0, 923, 924, 5, 101, 0, 0, 924, 925, 5, 110, 0,
    0, 925, 926, 5, 116, 0, 0, 926, 134, 1, 0, 0, 0, 927, 928, 5, 99, 0, 0, 928, 929, 5, 111, 0, 0, 929,
    930, 5, 110, 0, 0, 930, 931, 5, 118, 0, 0, 931, 932, 5, 101, 0, 0, 932, 933, 5, 110, 0, 0, 933,
    934, 5, 105, 0, 0, 934, 935, 5, 101, 0, 0, 935, 936, 5, 110, 0, 0, 936, 937, 5, 99, 0, 0, 937, 938,
    5, 101, 0, 0, 938, 136, 1, 0, 0, 0, 939, 940, 5, 100, 0, 0, 940, 941, 5, 121, 0, 0, 941, 942, 5,
    110, 0, 0, 942, 943, 5, 97, 0, 0, 943, 944, 5, 109, 0, 0, 944, 945, 5, 105, 0, 0, 945, 946, 5, 99,
    0, 0, 946, 138, 1, 0, 0, 0, 947, 948, 5, 108, 0, 0, 948, 949, 5, 97, 0, 0, 949, 950, 5, 122, 0, 0,
    950, 951, 5, 121, 0, 0, 951, 140, 1, 0, 0, 0, 952, 953, 5, 111, 0, 0, 953, 954, 5, 112, 0, 0, 954,
    955, 5, 116, 0, 0, 955, 956, 5, 105, 0, 0, 956, 957, 5, 111, 0, 0, 957, 958, 5, 110, 0, 0, 958,
    959, 5, 97, 0, 0, 959, 960, 5, 108, 0, 0, 960, 142, 1, 0, 0, 0, 961, 962, 5, 111, 0, 0, 962, 963,
    5, 118, 0, 0, 963, 964, 5, 101, 0, 0, 964, 965, 5, 114, 0, 0, 965, 966, 5, 114, 0, 0, 966, 967,
    5, 105, 0, 0, 967, 968, 5, 100, 0, 0, 968, 969, 5, 101, 0, 0, 969, 144, 1, 0, 0, 0, 970, 971, 5,
    114, 0, 0, 971, 972, 5, 101, 0, 0, 972, 973, 5, 113, 0, 0, 973, 974, 5, 117, 0, 0, 974, 975, 5,
    105, 0, 0, 975, 976, 5, 114, 0, 0, 976, 977, 5, 101, 0, 0, 977, 978, 5, 100, 0, 0, 978, 146, 1,
    0, 0, 0, 979, 980, 5, 115, 0, 0, 980, 981, 5, 116, 0, 0, 981, 982, 5, 97, 0, 0, 982, 983, 5, 116,
    0, 0, 983, 984, 5, 105, 0, 0, 984, 985, 5, 99, 0, 0, 985, 148, 1, 0, 0, 0, 986, 987, 5, 119, 0, 0,
    987, 988, 5, 101, 0, 0, 988, 989, 5, 97, 0, 0, 989, 990, 5, 107, 0, 0, 990, 150, 1, 0, 0, 0, 991,
    992, 5, 117, 0, 0, 992, 993, 5, 110, 0, 0, 993, 994, 5, 111, 0, 0, 994, 995, 5, 119, 0, 0, 995,
    996, 5, 110, 0, 0, 996, 997, 5, 101, 0, 0, 997, 998, 5, 100, 0, 0, 998, 152, 1, 0, 0, 0, 999, 1000,
    5, 115, 0, 0, 1000, 1001, 5, 97, 0, 0, 1001, 1002, 5, 102, 0, 0, 1002, 1003, 5, 101, 0, 0, 1003,
    154, 1, 0, 0, 0, 1004, 1005, 5, 117, 0, 0, 1005, 1006, 5, 110, 0, 0, 1006, 1007, 5, 115, 0, 0,
    1007, 1008, 5, 97, 0, 0, 1008, 1009, 5, 102, 0, 0, 1009, 1010, 5, 101, 0, 0, 1010, 156, 1, 0,
    0, 0, 1011, 1012, 5, 109, 0, 0, 1012, 1013, 5, 117, 0, 0, 1013, 1014, 5, 116, 0, 0, 1014, 1015,
    5, 97, 0, 0, 1015, 1016, 5, 116, 0, 0, 1016, 1017, 5, 105, 0, 0, 1017, 1018, 5, 110, 0, 0, 1018,
    1019, 5, 103, 0, 0, 1019, 158, 1, 0, 0, 0, 1020, 1021, 5, 110, 0, 0, 1021, 1022, 5, 111, 0, 0,
    1022, 1023, 5, 110, 0, 0, 1023, 1024, 5, 109, 0, 0, 1024, 1025, 5, 117, 0, 0, 1025, 1026, 5,
    116, 0, 0, 1026, 1027, 5, 97, 0, 0, 1027, 1028, 5, 116, 0, 0, 1028, 1029, 5, 105, 0, 0, 1029,
    1030, 5, 110, 0, 0, 1030, 1031, 5, 103, 0, 0, 1031, 160, 1, 0, 0, 0, 1032, 1033, 5, 102, 0, 0,
    1033, 1034, 5, 105, 0, 0, 1034, 1035, 5, 108, 0, 0, 1035, 1036, 5, 101, 0, 0, 1036, 1037, 5,
    112, 0, 0, 1037, 1038, 5, 114, 0, 0, 1038, 1039, 5, 105, 0, 0, 1039, 1040, 5, 118, 0, 0, 1040,
    1041, 5, 97, 0, 0, 1041, 1042, 5, 116, 0, 0, 1042, 1043, 5, 101, 0, 0, 1043, 162, 1, 0, 0, 0, 1044,
    1045, 5, 105, 0, 0, 1045, 1046, 5, 115, 0, 0, 1046, 164, 1, 0, 0, 0, 1047, 1048, 5, 116, 0, 0,
    1048, 1049, 5, 114, 0, 0, 1049, 1050, 5, 121, 0, 0, 1050, 166, 1, 0, 0, 0, 1051, 1052, 5, 115,
    0, 0, 1052, 1053, 5, 117, 0, 0, 1053, 1054, 5, 112, 0, 0, 1054, 1055, 5, 101, 0, 0, 1055, 1056,
    5, 114, 0, 0, 1056, 168, 1, 0, 0, 0, 1057, 1058, 5, 65, 0, 0, 1058, 1059, 5, 110, 0, 0, 1059, 1060,
    5, 121, 0, 0, 1060, 170, 1, 0, 0, 0, 1061, 1062, 5, 102, 0, 0, 1062, 1063, 5, 97, 0, 0, 1063, 1064,
    5, 108, 0, 0, 1064, 1065, 5, 115, 0, 0, 1065, 1066, 5, 101, 0, 0, 1066, 172, 1, 0, 0, 0, 1067,
    1068, 5, 114, 0, 0, 1068, 1069, 5, 101, 0, 0, 1069, 1070, 5, 100, 0, 0, 1070, 174, 1, 0, 0, 0,
    1071, 1072, 5, 98, 0, 0, 1072, 1073, 5, 108, 0, 0, 1073, 1074, 5, 117, 0, 0, 1074, 1075, 5, 101,
    0, 0, 1075, 176, 1, 0, 0, 0, 1076, 1077, 5, 103, 0, 0, 1077, 1078, 5, 114, 0, 0, 1078, 1079, 5,
    101, 0, 0, 1079, 1080, 5, 101, 0, 0, 1080, 1081, 5, 110, 0, 0, 1081, 178, 1, 0, 0, 0, 1082, 1083,
    5, 114, 0, 0, 1083, 1084, 5, 101, 0, 0, 1084, 1085, 5, 115, 0, 0, 1085, 1086, 5, 111, 0, 0, 1086,
    1087, 5, 117, 0, 0, 1087, 1088, 5, 114, 0, 0, 1088, 1089, 5, 99, 0, 0, 1089, 1090, 5, 101, 0,
    0, 1090, 1091, 5, 78, 0, 0, 1091, 1092, 5, 97, 0, 0, 1092, 1093, 5, 109, 0, 0, 1093, 1094, 5,
    101, 0, 0, 1094, 180, 1, 0, 0, 0, 1095, 1096, 5, 116, 0, 0, 1096, 1097, 5, 114, 0, 0, 1097, 1098,
    5, 117, 0, 0, 1098, 1099, 5, 101, 0, 0, 1099, 182, 1, 0, 0, 0, 1100, 1101, 5, 110, 0, 0, 1101,
    1102, 5, 105, 0, 0, 1102, 1103, 5, 108, 0, 0, 1103, 184, 1, 0, 0, 0, 1104, 1105, 5, 105, 0, 0,
    1105, 1106, 5, 110, 0, 0, 1106, 1107, 5, 111, 0, 0, 1107, 1108, 5, 117, 0, 0, 1108, 1109, 5,
    116, 0, 0, 1109, 186, 1, 0, 0, 0, 1110, 1111, 5, 115, 0, 0, 1111, 1112, 5, 111, 0, 0, 1112, 1113,
    5, 109, 0, 0, 1113, 1114, 5, 101, 0, 0, 1114, 188, 1, 0, 0, 0, 1115, 1116, 5, 84, 0, 0, 1116, 1117,
    5, 121, 0, 0, 1117, 1118, 5, 112, 0, 0, 1118, 1119, 5, 101, 0, 0, 1119, 190, 1, 0, 0, 0, 1120,
    1121, 5, 112, 0, 0, 1121, 1122, 5, 114, 0, 0, 1122, 1123, 5, 101, 0, 0, 1123, 1124, 5, 99, 0,
    0, 1124, 1125, 5, 101, 0, 0, 1125, 1126, 5, 100, 0, 0, 1126, 1127, 5, 101, 0, 0, 1127, 1128,
    5, 110, 0, 0, 1128, 1129, 5, 99, 0, 0, 1129, 1130, 5, 101, 0, 0, 1130, 192, 1, 0, 0, 0, 1131, 1132,
    5, 115, 0, 0, 1132, 1133, 5, 101, 0, 0, 1133, 1134, 5, 108, 0, 0, 1134, 1135, 5, 102, 0, 0, 1135,
    194, 1, 0, 0, 0, 1136, 1137, 5, 83, 0, 0, 1137, 1138, 5, 101, 0, 0, 1138, 1139, 5, 108, 0, 0, 1139,
    1140, 5, 102, 0, 0, 1140, 196, 1, 0, 0, 0, 1141, 1142, 5, 109, 0, 0, 1142, 1143, 5, 97, 0, 0, 1143,
    1144, 5, 99, 0, 0, 1144, 1145, 5, 79, 0, 0, 1145, 1146, 5, 83, 0, 0, 1146, 198, 1, 0, 0, 0, 1147,
    1148, 5, 105, 0, 0, 1148, 1149, 5, 79, 0, 0, 1149, 1150, 5, 83, 0, 0, 1150, 200, 1, 0, 0, 0, 1151,
    1152, 5, 79, 0, 0, 1152, 1153, 5, 83, 0, 0, 1153, 1154, 5, 88, 0, 0, 1154, 202, 1, 0, 0, 0, 1155,
    1156, 5, 119, 0, 0, 1156, 1157, 5, 97, 0, 0, 1157, 1158, 5, 116, 0, 0, 1158, 1159, 5, 99, 0, 0,
    1159, 1160, 5, 104, 0, 0, 1160, 1161, 5, 79, 0, 0, 1161, 1162, 5, 83, 0, 0, 1162, 204, 1, 0, 0,
    0, 1163, 1164, 5, 116, 0, 0, 1164, 1165, 5, 118, 0, 0, 1165, 1166, 5, 79, 0, 0, 1166, 1167, 5,
    83, 0, 0, 1167, 206, 1, 0, 0, 0, 1168, 1169, 5, 76, 0, 0, 1169, 1170, 5, 105, 0, 0, 1170, 1171,
    5, 110, 0, 0, 1171, 1172, 5, 117, 0, 0, 1172, 1173, 5, 120, 0, 0, 1173, 208, 1, 0, 0, 0, 1174,
    1175, 5, 87, 0, 0, 1175, 1176, 5, 105, 0, 0, 1176, 1177, 5, 110, 0, 0, 1177, 1178, 5, 100, 0,
    0, 1178, 1179, 5, 111, 0, 0, 1179, 1180, 5, 119, 0, 0, 1180, 1181, 5, 115, 0, 0, 1181, 210, 1,
    0, 0, 0, 1182, 1183, 5, 105, 0, 0, 1183, 1184, 5, 51, 0, 0, 1184, 1185, 5, 56, 0, 0, 1185, 1186,
    5, 54, 0, 0, 1186, 212, 1, 0, 0, 0, 1187, 1188, 5, 120, 0, 0, 1188, 1189, 5, 56, 0, 0, 1189, 1190,
    5, 54, 0, 0, 1190, 1191, 5, 95, 0, 0, 1191, 1192, 5, 54, 0, 0, 1192, 1193, 5, 52, 0, 0, 1193, 214,
    1, 0, 0, 0, 1194, 1195, 5, 97, 0, 0, 1195, 1196, 5, 114, 0, 0, 1196, 1197, 5, 109, 0, 0, 1197,
    216, 1, 0, 0, 0, 1198, 1199, 5, 97, 0, 0, 1199, 1200, 5, 114, 0, 0, 1200, 1201, 5, 109, 0, 0, 1201,
    1202, 5, 54, 0, 0, 1202, 1203, 5, 52, 0, 0, 1203, 218, 1, 0, 0, 0, 1204, 1205, 5, 115, 0, 0, 1205,
    1206, 5, 105, 0, 0, 1206, 1207, 5, 109, 0, 0, 1207, 1208, 5, 117, 0, 0, 1208, 1209, 5, 108, 0,
    0, 1209, 1210, 5, 97, 0, 0, 1210, 1211, 5, 116, 0, 0, 1211, 1212, 5, 111, 0, 0, 1212, 1213, 5,
    114, 0, 0, 1213, 220, 1, 0, 0, 0, 1214, 1215, 5, 109, 0, 0, 1215, 1216, 5, 97, 0, 0, 1216, 1217,
    5, 99, 0, 0, 1217, 1218, 5, 67, 0, 0, 1218, 1219, 5, 97, 0, 0, 1219, 1220, 5, 116, 0, 0, 1220,
    1221, 5, 97, 0, 0, 1221, 1222, 5, 108, 0, 0, 1222, 1223, 5, 121, 0, 0, 1223, 1224, 5, 115, 0,
    0, 1224, 1225, 5, 116, 0, 0, 1225, 222, 1, 0, 0, 0, 1226, 1227, 5, 105, 0, 0, 1227, 1228, 5, 79,
    0, 0, 1228, 1229, 5, 83, 0, 0, 1229, 1230, 5, 65, 0, 0, 1230, 1231, 5, 112, 0, 0, 1231, 1232,
    5, 112, 0, 0, 1232, 1233, 5, 108, 0, 0, 1233, 1234, 5, 105, 0, 0, 1234, 1235, 5, 99, 0, 0, 1235,
    1236, 5, 97, 0, 0, 1236, 1237, 5, 116, 0, 0, 1237, 1238, 5, 105, 0, 0, 1238, 1239, 5, 111, 0,
    0, 1239, 1240, 5, 110, 0, 0, 1240, 1241, 5, 69, 0, 0, 1241, 1242, 5, 120, 0, 0, 1242, 1243, 5,
    116, 0, 0, 1243, 1244, 5, 101, 0, 0, 1244, 1245, 5, 110, 0, 0, 1245, 1246, 5, 115, 0, 0, 1246,
    1247, 5, 105, 0, 0, 1247, 1248, 5, 111, 0, 0, 1248, 1249, 5, 110, 0, 0, 1249, 224, 1, 0, 0, 0,
    1250, 1251, 5, 109, 0, 0, 1251, 1252, 5, 97, 0, 0, 1252, 1253, 5, 99, 0, 0, 1253, 1254, 5, 67,
    0, 0, 1254, 1255, 5, 97, 0, 0, 1255, 1256, 5, 116, 0, 0, 1256, 1257, 5, 97, 0, 0, 1257, 1258,
    5, 108, 0, 0, 1258, 1259, 5, 121, 0, 0, 1259, 1260, 5, 115, 0, 0, 1260, 1261, 5, 116, 0, 0, 1261,
    1262, 5, 65, 0, 0, 1262, 1263, 5, 112, 0, 0, 1263, 1264, 5, 112, 0, 0, 1264, 1265, 5, 108, 0,
    0, 1265, 1266, 5, 105, 0, 0, 1266, 1267, 5, 99, 0, 0, 1267, 1268, 5, 97, 0, 0, 1268, 1269, 5,
    116, 0, 0, 1269, 1270, 5, 105, 0, 0, 1270, 1271, 5, 111, 0, 0, 1271, 1272, 5, 110, 0, 0, 1272,
    1273, 5, 69, 0, 0, 1273, 1274, 5, 120, 0, 0, 1274, 1275, 5, 116, 0, 0, 1275, 1276, 5, 101, 0,
    0, 1276, 1277, 5, 110, 0, 0, 1277, 1278, 5, 115, 0, 0, 1278, 1279, 5, 105, 0, 0, 1279, 1280,
    5, 111, 0, 0, 1280, 1281, 5, 110, 0, 0, 1281, 226, 1, 0, 0, 0, 1282, 1283, 5, 109, 0, 0, 1283,
    1284, 5, 97, 0, 0, 1284, 1285, 5, 99, 0, 0, 1285, 1286, 5, 79, 0, 0, 1286, 1287, 5, 83, 0, 0, 1287,
    1288, 5, 65, 0, 0, 1288, 1289, 5, 112, 0, 0, 1289, 1290, 5, 112, 0, 0, 1290, 1291, 5, 108, 0,
    0, 1291, 1292, 5, 105, 0, 0, 1292, 1293, 5, 99, 0, 0, 1293, 1294, 5, 97, 0, 0, 1294, 1295, 5,
    116, 0, 0, 1295, 1296, 5, 105, 0, 0, 1296, 1297, 5, 111, 0, 0, 1297, 1298, 5, 110, 0, 0, 1298,
    1299, 5, 69, 0, 0, 1299, 1300, 5, 120, 0, 0, 1300, 1301, 5, 116, 0, 0, 1301, 1302, 5, 101, 0,
    0, 1302, 1303, 5, 110, 0, 0, 1303, 1304, 5, 115, 0, 0, 1304, 1305, 5, 105, 0, 0, 1305, 1306,
    5, 111, 0, 0, 1306, 1307, 5, 110, 0, 0, 1307, 228, 1, 0, 0, 0, 1308, 1309, 5, 35, 0, 0, 1309, 1310,
    5, 115, 0, 0, 1310, 1311, 5, 111, 0, 0, 1311, 1312, 5, 117, 0, 0, 1312, 1313, 5, 114, 0, 0, 1313,
    1314, 5, 99, 0, 0, 1314, 1315, 5, 101, 0, 0, 1315, 1316, 5, 76, 0, 0, 1316, 1317, 5, 111, 0, 0,
    1317, 1318, 5, 99, 0, 0, 1318, 1319, 5, 97, 0, 0, 1319, 1320, 5, 116, 0, 0, 1320, 1321, 5, 105,
    0, 0, 1321, 1322, 5, 111, 0, 0, 1322, 1323, 5, 110, 0, 0, 1323, 230, 1, 0, 0, 0, 1324, 1325, 5,
    102, 0, 0, 1325, 1326, 5, 105, 0, 0, 1326, 1327, 5, 108, 0, 0, 1327, 1328, 5, 101, 0, 0, 1328,
    232, 1, 0, 0, 0, 1329, 1330, 5, 108, 0, 0, 1330, 1331, 5, 105, 0, 0, 1331, 1332, 5, 110, 0, 0,
    1332, 1333, 5, 101, 0, 0, 1333, 234, 1, 0, 0, 0, 1334, 1335, 5, 35, 0, 0, 1335, 1336, 5, 101,
    0, 0, 1336, 1337, 5, 114, 0, 0, 1337, 1338, 5, 114, 0, 0, 1338, 1339, 5, 111, 0, 0, 1339, 1340,
    5, 114, 0, 0, 1340, 236, 1, 0, 0, 0, 1341, 1342, 5, 35, 0, 0, 1342, 1343, 5, 119, 0, 0, 1343, 1344,
    5, 97, 0, 0, 1344, 1345, 5, 114, 0, 0, 1345, 1346, 5, 110, 0, 0, 1346, 1347, 5, 105, 0, 0, 1347,
    1348, 5, 110, 0, 0, 1348, 1349, 5, 103, 0, 0, 1349, 238, 1, 0, 0, 0, 1350, 1351, 5, 35, 0, 0, 1351,
    1352, 5, 97, 0, 0, 1352, 1353, 5, 118, 0, 0, 1353, 1354, 5, 97, 0, 0, 1354, 1355, 5, 105, 0, 0,
    1355, 1356, 5, 108, 0, 0, 1356, 1357, 5, 97, 0, 0, 1357, 1358, 5, 98, 0, 0, 1358, 1359, 5, 108,
    0, 0, 1359, 1360, 5, 101, 0, 0, 1360, 240, 1, 0, 0, 0, 1361, 1362, 5, 35, 0, 0, 1362, 1363, 5,
    105, 0, 0, 1363, 1364, 5, 102, 0, 0, 1364, 242, 1, 0, 0, 0, 1365, 1366, 5, 35, 0, 0, 1366, 1367,
    5, 101, 0, 0, 1367, 1368, 5, 108, 0, 0, 1368, 1369, 5, 115, 0, 0, 1369, 1370, 5, 101, 0, 0, 1370,
    1371, 5, 105, 0, 0, 1371, 1372, 5, 102, 0, 0, 1372, 244, 1, 0, 0, 0, 1373, 1374, 5, 35, 0, 0, 1374,
    1375, 5, 101, 0, 0, 1375, 1376, 5, 108, 0, 0, 1376, 1377, 5, 115, 0, 0, 1377, 1378, 5, 101, 0,
    0, 1378, 246, 1, 0, 0, 0, 1379, 1380, 5, 35, 0, 0, 1380, 1381, 5, 101, 0, 0, 1381, 1382, 5, 110,
    0, 0, 1382, 1383, 5, 100, 0, 0, 1383, 1384, 5, 105, 0, 0, 1384, 1385, 5, 102, 0, 0, 1385, 248,
    1, 0, 0, 0, 1386, 1387, 5, 35, 0, 0, 1387, 1388, 5, 102, 0, 0, 1388, 1389, 5, 105, 0, 0, 1389,
    1390, 5, 108, 0, 0, 1390, 1391, 5, 101, 0, 0, 1391, 250, 1, 0, 0, 0, 1392, 1393, 5, 35, 0, 0, 1393,
    1394, 5, 102, 0, 0, 1394, 1395, 5, 105, 0, 0, 1395, 1396, 5, 108, 0, 0, 1396, 1397, 5, 101, 0,
    0, 1397, 1398, 5, 73, 0, 0, 1398, 1399, 5, 68, 0, 0, 1399, 252, 1, 0, 0, 0, 1400, 1401, 5, 35,
    0, 0, 1401, 1402, 5, 102, 0, 0, 1402, 1403, 5, 105, 0, 0, 1403, 1404, 5, 108, 0, 0, 1404, 1405,
    5, 101, 0, 0, 1405, 1406, 5, 80, 0, 0, 1406, 1407, 5, 97, 0, 0, 1407, 1408, 5, 116, 0, 0, 1408,
    1409, 5, 104, 0, 0, 1409, 254, 1, 0, 0, 0, 1410, 1411, 5, 35, 0, 0, 1411, 1412, 5, 108, 0, 0, 1412,
    1413, 5, 105, 0, 0, 1413, 1414, 5, 110, 0, 0, 1414, 1415, 5, 101, 0, 0, 1415, 256, 1, 0, 0, 0,
    1416, 1417, 5, 35, 0, 0, 1417, 1418, 5, 99, 0, 0, 1418, 1419, 5, 111, 0, 0, 1419, 1420, 5, 108,
    0, 0, 1420, 1421, 5, 117, 0, 0, 1421, 1422, 5, 109, 0, 0, 1422, 1423, 5, 110, 0, 0, 1423, 258,
    1, 0, 0, 0, 1424, 1425, 5, 35, 0, 0, 1425, 1426, 5, 102, 0, 0, 1426, 1427, 5, 117, 0, 0, 1427,
    1428, 5, 110, 0, 0, 1428, 1429, 5, 99, 0, 0, 1429, 1430, 5, 116, 0, 0, 1430, 1431, 5, 105, 0,
    0, 1431, 1432, 5, 111, 0, 0, 1432, 1433, 5, 110, 0, 0, 1433, 260, 1, 0, 0, 0, 1434, 1435, 5, 35,
    0, 0, 1435, 1436, 5, 100, 0, 0, 1436, 1437, 5, 115, 0, 0, 1437, 1438, 5, 111, 0, 0, 1438, 1439,
    5, 104, 0, 0, 1439, 1440, 5, 97, 0, 0, 1440, 1441, 5, 110, 0, 0, 1441, 1442, 5, 100, 0, 0, 1442,
    1443, 5, 108, 0, 0, 1443, 1444, 5, 101, 0, 0, 1444, 262, 1, 0, 0, 0, 1445, 1446, 5, 35, 0, 0, 1446,
    1447, 5, 115, 0, 0, 1447, 1448, 5, 101, 0, 0, 1448, 1449, 5, 108, 0, 0, 1449, 1450, 5, 101, 0,
    0, 1450, 1451, 5, 99, 0, 0, 1451, 1452, 5, 116, 0, 0, 1452, 1453, 5, 111, 0, 0, 1453, 1454, 5,
    114, 0, 0, 1454, 264, 1, 0, 0, 0, 1455, 1456, 5, 35, 0, 0, 1456, 1457, 5, 107, 0, 0, 1457, 1458,
    5, 101, 0, 0, 1458, 1459, 5, 121, 0, 0, 1459, 1460, 5, 80, 0, 0, 1460, 1461, 5, 97, 0, 0, 1461,
    1462, 5, 116, 0, 0, 1462, 1463, 5, 104, 0, 0, 1463, 266, 1, 0, 0, 0, 1464, 1465, 5, 35, 0, 0, 1465,
    1466, 5, 99, 0, 0, 1466, 1467, 5, 111, 0, 0, 1467, 1468, 5, 108, 0, 0, 1468, 1469, 5, 111, 0,
    0, 1469, 1470, 5, 114, 0, 0, 1470, 1471, 5, 76, 0, 0, 1471, 1472, 5, 105, 0, 0, 1472, 1473, 5,
    116, 0, 0, 1473, 1474, 5, 101, 0, 0, 1474, 1475, 5, 114, 0, 0, 1475, 1476, 5, 97, 0, 0, 1476,
    1477, 5, 108, 0, 0, 1477, 268, 1, 0, 0, 0, 1478, 1479, 5, 35, 0, 0, 1479, 1480, 5, 102, 0, 0, 1480,
    1481, 5, 105, 0, 0, 1481, 1482, 5, 108, 0, 0, 1482, 1483, 5, 101, 0, 0, 1483, 1484, 5, 76, 0,
    0, 1484, 1485, 5, 105, 0, 0, 1485, 1486, 5, 116, 0, 0, 1486, 1487, 5, 101, 0, 0, 1487, 1488,
    5, 114, 0, 0, 1488, 1489, 5, 97, 0, 0, 1489, 1490, 5, 108, 0, 0, 1490, 270, 1, 0, 0, 0, 1491, 1492,
    5, 35, 0, 0, 1492, 1493, 5, 105, 0, 0, 1493, 1494, 5, 109, 0, 0, 1494, 1495, 5, 97, 0, 0, 1495,
    1496, 5, 103, 0, 0, 1496, 1497, 5, 101, 0, 0, 1497, 1498, 5, 76, 0, 0, 1498, 1499, 5, 105, 0,
    0, 1499, 1500, 5, 116, 0, 0, 1500, 1501, 5, 101, 0, 0, 1501, 1502, 5, 114, 0, 0, 1502, 1503,
    5, 97, 0, 0, 1503, 1504, 5, 108, 0, 0, 1504, 272, 1, 0, 0, 0, 1505, 1506, 5, 103, 0, 0, 1506, 1507,
    5, 101, 0, 0, 1507, 1508, 5, 116, 0, 0, 1508, 1509, 5, 116, 0, 0, 1509, 1510, 5, 101, 0, 0, 1510,
    1511, 5, 114, 0, 0, 1511, 274, 1, 0, 0, 0, 1512, 1513, 5, 115, 0, 0, 1513, 1514, 5, 101, 0, 0,
    1514, 1515, 5, 116, 0, 0, 1515, 1516, 5, 116, 0, 0, 1516, 1517, 5, 101, 0, 0, 1517, 1518, 5,
    114, 0, 0, 1518, 276, 1, 0, 0, 0, 1519, 1521, 3, 279, 137, 0, 1520, 1522, 3, 283, 139, 0, 1521,
    1520, 1, 0, 0, 0, 1521, 1522, 1, 0, 0, 0, 1522, 1526, 1, 0, 0, 0, 1523, 1526, 3, 285, 140, 0, 1524,
    1526, 3, 287, 141, 0, 1525, 1519, 1, 0, 0, 0, 1525, 1523, 1, 0, 0, 0, 1525, 1524, 1, 0, 0, 0, 1526,
    278, 1, 0, 0, 0, 1527, 1529, 7, 0, 0, 0, 1528, 1527, 1, 0, 0, 0, 1529, 280, 1, 0, 0, 0, 1530, 1533,
    7, 1, 0, 0, 1531, 1533, 3, 279, 137, 0, 1532, 1530, 1, 0, 0, 0, 1532, 1531, 1, 0, 0, 0, 1533, 282,
    1, 0, 0, 0, 1534, 1536, 3, 281, 138, 0, 1535, 1534, 1, 0, 0, 0, 1536, 1537, 1, 0, 0, 0, 1537, 1535,
    1, 0, 0, 0, 1537, 1538, 1, 0, 0, 0, 1538, 284, 1, 0, 0, 0, 1539, 1540, 5, 36, 0, 0, 1540, 1541,
    3, 369, 182, 0, 1541, 286, 1, 0, 0, 0, 1542, 1543, 5, 36, 0, 0, 1543, 1544, 3, 283, 139, 0, 1544,
    288, 1, 0, 0, 0, 1545, 1546, 5, 46, 0, 0, 1546, 290, 1, 0, 0, 0, 1547, 1548, 5, 123, 0, 0, 1548,
    292, 1, 0, 0, 0, 1549, 1550, 5, 40, 0, 0, 1550, 1551, 6, 144, 0, 0, 1551, 294, 1, 0, 0, 0, 1552,
    1553, 5, 91, 0, 0, 1553, 296, 1, 0, 0, 0, 1554, 1555, 5, 125, 0, 0, 1555, 298, 1, 0, 0, 0, 1556,
    1557, 5, 41, 0, 0, 1557, 1558, 6, 147, 1, 0, 1558, 300, 1, 0, 0, 0, 1559, 1560, 5, 93, 0, 0, 1560,
    302, 1, 0, 0, 0, 1561, 1562, 5, 44, 0, 0, 1562, 304, 1, 0, 0, 0, 1563, 1564, 5, 58, 0, 0, 1564,
    306, 1, 0, 0, 0, 1565, 1566, 5, 59, 0, 0, 1566, 308, 1, 0, 0, 0, 1567, 1568, 5, 60, 0, 0, 1568,
    310, 1, 0, 0, 0, 1569, 1570, 5, 62, 0, 0, 1570, 312, 1, 0, 0, 0, 1571, 1572, 5, 95, 0, 0, 1572,
    314, 1, 0, 0, 0, 1573, 1574, 5, 33, 0, 0, 1574, 316, 1, 0, 0, 0, 1575, 1576, 5, 63, 0, 0, 1576,
    318, 1, 0, 0, 0, 1577, 1578, 5, 64, 0, 0, 1578, 320, 1, 0, 0, 0, 1579, 1580, 5, 38, 0, 0, 1580,
    322, 1, 0, 0, 0, 1581, 1582, 5, 45, 0, 0, 1582, 324, 1, 0, 0, 0, 1583, 1584, 5, 61, 0, 0, 1584,
    326, 1, 0, 0, 0, 1585, 1586, 5, 124, 0, 0, 1586, 328, 1, 0, 0, 0, 1587, 1588, 5, 47, 0, 0, 1588,
    330, 1, 0, 0, 0, 1589, 1590, 5, 43, 0, 0, 1590, 332, 1, 0, 0, 0, 1591, 1592, 5, 42, 0, 0, 1592,
    334, 1, 0, 0, 0, 1593, 1594, 5, 37, 0, 0, 1594, 336, 1, 0, 0, 0, 1595, 1596, 5, 94, 0, 0, 1596,
    338, 1, 0, 0, 0, 1597, 1598, 5, 126, 0, 0, 1598, 340, 1, 0, 0, 0, 1599, 1600, 5, 35, 0, 0, 1600,
    342, 1, 0, 0, 0, 1601, 1602, 5, 96, 0, 0, 1602, 344, 1, 0, 0, 0, 1603, 1604, 5, 36, 0, 0, 1604,
    346, 1, 0, 0, 0, 1605, 1606, 5, 92, 0, 0, 1606, 348, 1, 0, 0, 0, 1607, 1609, 7, 2, 0, 0, 1608, 1607,
    1, 0, 0, 0, 1609, 350, 1, 0, 0, 0, 1610, 1612, 7, 3, 0, 0, 1611, 1610, 1, 0, 0, 0, 1612, 352, 1,
    0, 0, 0, 1613, 1614, 5, 48, 0, 0, 1614, 1615, 5, 98, 0, 0, 1615, 1616, 1, 0, 0, 0, 1616, 1618,
    3, 355, 175, 0, 1617, 1619, 3, 359, 177, 0, 1618, 1617, 1, 0, 0, 0, 1618, 1619, 1, 0, 0, 0, 1619,
    354, 1, 0, 0, 0, 1620, 1621, 7, 4, 0, 0, 1621, 356, 1, 0, 0, 0, 1622, 1625, 3, 355, 175, 0, 1623,
    1625, 5, 95, 0, 0, 1624, 1622, 1, 0, 0, 0, 1624, 1623, 1, 0, 0, 0, 1625, 358, 1, 0, 0, 0, 1626,
    1628, 3, 357, 176, 0, 1627, 1626, 1, 0, 0, 0, 1628, 1629, 1, 0, 0, 0, 1629, 1627, 1, 0, 0, 0, 1629,
    1630, 1, 0, 0, 0, 1630, 360, 1, 0, 0, 0, 1631, 1632, 5, 48, 0, 0, 1632, 1633, 5, 111, 0, 0, 1633,
    1634, 1, 0, 0, 0, 1634, 1636, 3, 363, 179, 0, 1635, 1637, 3, 367, 181, 0, 1636, 1635, 1, 0, 0,
    0, 1636, 1637, 1, 0, 0, 0, 1637, 362, 1, 0, 0, 0, 1638, 1639, 7, 5, 0, 0, 1639, 364, 1, 0, 0, 0,
    1640, 1643, 3, 363, 179, 0, 1641, 1643, 5, 95, 0, 0, 1642, 1640, 1, 0, 0, 0, 1642, 1641, 1, 0,
    0, 0, 1643, 366, 1, 0, 0, 0, 1644, 1646, 3, 365, 180, 0, 1645, 1644, 1, 0, 0, 0, 1646, 1647, 1,
    0, 0, 0, 1647, 1645, 1, 0, 0, 0, 1647, 1648, 1, 0, 0, 0, 1648, 368, 1, 0, 0, 0, 1649, 1651, 3, 373,
    184, 0, 1650, 1649, 1, 0, 0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1650, 1, 0, 0, 0, 1652, 1653, 1,
    0, 0, 0, 1653, 370, 1, 0, 0, 0, 1654, 1656, 3, 373, 184, 0, 1655, 1657, 3, 377, 186, 0, 1656,
    1655, 1, 0, 0, 0, 1656, 1657, 1, 0, 0, 0, 1657, 372, 1, 0, 0, 0, 1658, 1659, 7, 6, 0, 0, 1659, 374,
    1, 0, 0, 0, 1660, 1663, 3, 373, 184, 0, 1661, 1663, 5, 95, 0, 0, 1662, 1660, 1, 0, 0, 0, 1662,
    1661, 1, 0, 0, 0, 1663, 376, 1, 0, 0, 0, 1664, 1666, 3, 375, 185, 0, 1665, 1664, 1, 0, 0, 0, 1666,
    1667, 1, 0, 0, 0, 1667, 1665, 1, 0, 0, 0, 1667, 1668, 1, 0, 0, 0, 1668, 378, 1, 0, 0, 0, 1669, 1670,
    5, 48, 0, 0, 1670, 1671, 5, 120, 0, 0, 1671, 1672, 1, 0, 0, 0, 1672, 1674, 3, 381, 188, 0, 1673,
    1675, 3, 385, 190, 0, 1674, 1673, 1, 0, 0, 0, 1674, 1675, 1, 0, 0, 0, 1675, 380, 1, 0, 0, 0, 1676,
    1677, 7, 7, 0, 0, 1677, 382, 1, 0, 0, 0, 1678, 1681, 3, 381, 188, 0, 1679, 1681, 5, 95, 0, 0, 1680,
    1678, 1, 0, 0, 0, 1680, 1679, 1, 0, 0, 0, 1681, 384, 1, 0, 0, 0, 1682, 1684, 3, 383, 189, 0, 1683,
    1682, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1683, 1, 0, 0, 0, 1685, 1686, 1, 0, 0, 0, 1686,
    386, 1, 0, 0, 0, 1687, 1689, 3, 371, 183, 0, 1688, 1690, 3, 389, 192, 0, 1689, 1688, 1, 0, 0,
    0, 1689, 1690, 1, 0, 0, 0, 1690, 1692, 1, 0, 0, 0, 1691, 1693, 3, 391, 193, 0, 1692, 1691, 1,
    0, 0, 0, 1692, 1693, 1, 0, 0, 0, 1693, 1701, 1, 0, 0, 0, 1694, 1696, 3, 379, 187, 0, 1695, 1697,
    3, 393, 194, 0, 1696, 1695, 1, 0, 0, 0, 1696, 1697, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1699,
    3, 395, 195, 0, 1699, 1701, 1, 0, 0, 0, 1700, 1687, 1, 0, 0, 0, 1700, 1694, 1, 0, 0, 0, 1701, 388,
    1, 0, 0, 0, 1702, 1703, 5, 46, 0, 0, 1703, 1704, 3, 371, 183, 0, 1704, 390, 1, 0, 0, 0, 1705, 1707,
    3, 397, 196, 0, 1706, 1708, 3, 401, 198, 0, 1707, 1706, 1, 0, 0, 0, 1707, 1708, 1, 0, 0, 0, 1708,
    1709, 1, 0, 0, 0, 1709, 1710, 3, 371, 183, 0, 1710, 392, 1, 0, 0, 0, 1711, 1712, 5, 46, 0, 0, 1712,
    1714, 3, 381, 188, 0, 1713, 1715, 3, 385, 190, 0, 1714, 1713, 1, 0, 0, 0, 1714, 1715, 1, 0, 0,
    0, 1715, 394, 1, 0, 0, 0, 1716, 1718, 3, 399, 197, 0, 1717, 1719, 3, 401, 198, 0, 1718, 1717,
    1, 0, 0, 0, 1718, 1719, 1, 0, 0, 0, 1719, 1720, 1, 0, 0, 0, 1720, 1721, 3, 371, 183, 0, 1721, 396,
    1, 0, 0, 0, 1722, 1723, 7, 8, 0, 0, 1723, 398, 1, 0, 0, 0, 1724, 1725, 7, 9, 0, 0, 1725, 400, 1,
    0, 0, 0, 1726, 1727, 7, 10, 0, 0, 1727, 402, 1, 0, 0, 0, 1728, 1730, 7, 11, 0, 0, 1729, 1728, 1,
    0, 0, 0, 1730, 1731, 1, 0, 0, 0, 1731, 1729, 1, 0, 0, 0, 1731, 1732, 1, 0, 0, 0, 1732, 1733, 1,
    0, 0, 0, 1733, 1734, 6, 199, 2, 0, 1734, 404, 1, 0, 0, 0, 1735, 1736, 5, 35, 0, 0, 1736, 1737,
    5, 33, 0, 0, 1737, 1741, 1, 0, 0, 0, 1738, 1740, 9, 0, 0, 0, 1739, 1738, 1, 0, 0, 0, 1740, 1743,
    1, 0, 0, 0, 1741, 1742, 1, 0, 0, 0, 1741, 1739, 1, 0, 0, 0, 1742, 1745, 1, 0, 0, 0, 1743, 1741,
    1, 0, 0, 0, 1744, 1746, 7, 12, 0, 0, 1745, 1744, 1, 0, 0, 0, 1746, 1747, 1, 0, 0, 0, 1747, 1745,
    1, 0, 0, 0, 1747, 1748, 1, 0, 0, 0, 1748, 1749, 1, 0, 0, 0, 1749, 1750, 6, 200, 2, 0, 1750, 406,
    1, 0, 0, 0, 1751, 1752, 5, 47, 0, 0, 1752, 1753, 5, 42, 0, 0, 1753, 1758, 1, 0, 0, 0, 1754, 1757,
    3, 407, 201, 0, 1755, 1757, 9, 0, 0, 0, 1756, 1754, 1, 0, 0, 0, 1756, 1755, 1, 0, 0, 0, 1757, 1760,
    1, 0, 0, 0, 1758, 1759, 1, 0, 0, 0, 1758, 1756, 1, 0, 0, 0, 1759, 1761, 1, 0, 0, 0, 1760, 1758,
    1, 0, 0, 0, 1761, 1762, 5, 42, 0, 0, 1762, 1763, 5, 47, 0, 0, 1763, 1764, 1, 0, 0, 0, 1764, 1765,
    6, 201, 2, 0, 1765, 408, 1, 0, 0, 0, 1766, 1767, 5, 47, 0, 0, 1767, 1768, 5, 47, 0, 0, 1768, 1772,
    1, 0, 0, 0, 1769, 1771, 9, 0, 0, 0, 1770, 1769, 1, 0, 0, 0, 1771, 1774, 1, 0, 0, 0, 1772, 1773,
    1, 0, 0, 0, 1772, 1770, 1, 0, 0, 0, 1773, 1776, 1, 0, 0, 0, 1774, 1772, 1, 0, 0, 0, 1775, 1777,
    7, 13, 0, 0, 1776, 1775, 1, 0, 0, 0, 1777, 1778, 1, 0, 0, 0, 1778, 1779, 6, 202, 2, 0, 1779, 410,
    1, 0, 0, 0, 1780, 1782, 5, 35, 0, 0, 1781, 1780, 1, 0, 0, 0, 1782, 1783, 1, 0, 0, 0, 1783, 1781,
    1, 0, 0, 0, 1783, 1784, 1, 0, 0, 0, 1784, 1785, 1, 0, 0, 0, 1785, 1786, 5, 34, 0, 0, 1786, 1787,
    5, 34, 0, 0, 1787, 1788, 5, 34, 0, 0, 1788, 1789, 1, 0, 0, 0, 1789, 1790, 6, 203, 3, 0, 1790, 412,
    1, 0, 0, 0, 1791, 1793, 5, 35, 0, 0, 1792, 1791, 1, 0, 0, 0, 1793, 1794, 1, 0, 0, 0, 1794, 1792,
    1, 0, 0, 0, 1794, 1795, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0, 1796, 1797, 5, 34, 0, 0, 1797, 1798,
    1, 0, 0, 0, 1798, 1799, 6, 204, 4, 0, 1799, 414, 1, 0, 0, 0, 1800, 1801, 5, 34, 0, 0, 1801, 1802,
    5, 34, 0, 0, 1802, 1803, 5, 34, 0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 1805, 6, 205, 5, 0, 1805, 416,
    1, 0, 0, 0, 1806, 1807, 5, 34, 0, 0, 1807, 1808, 1, 0, 0, 0, 1808, 1809, 6, 206, 6, 0, 1809, 418,
    1, 0, 0, 0, 1810, 1811, 5, 92, 0, 0, 1811, 1812, 5, 40, 0, 0, 1812, 1813, 1, 0, 0, 0, 1813, 1814,
    6, 207, 7, 0, 1814, 1815, 1, 0, 0, 0, 1815, 1816, 6, 207, 8, 0, 1816, 420, 1, 0, 0, 0, 1817, 1818,
    5, 34, 0, 0, 1818, 1819, 1, 0, 0, 0, 1819, 1820, 6, 208, 9, 0, 1820, 422, 1, 0, 0, 0, 1821, 1822,
    3, 439, 217, 0, 1822, 424, 1, 0, 0, 0, 1823, 1824, 5, 92, 0, 0, 1824, 1825, 5, 40, 0, 0, 1825,
    1826, 1, 0, 0, 0, 1826, 1827, 6, 210, 10, 0, 1827, 1828, 1, 0, 0, 0, 1828, 1829, 6, 210, 8, 0,
    1829, 426, 1, 0, 0, 0, 1830, 1831, 5, 34, 0, 0, 1831, 1832, 5, 34, 0, 0, 1832, 1833, 5, 34, 0,
    0, 1833, 1834, 1, 0, 0, 0, 1834, 1835, 6, 211, 9, 0, 1835, 428, 1, 0, 0, 0, 1836, 1837, 3, 443,
    219, 0, 1837, 430, 1, 0, 0, 0, 1838, 1840, 5, 34, 0, 0, 1839, 1841, 5, 35, 0, 0, 1840, 1839, 1,
    0, 0, 0, 1841, 1842, 1, 0, 0, 0, 1842, 1840, 1, 0, 0, 0, 1842, 1843, 1, 0, 0, 0, 1843, 1844, 1,
    0, 0, 0, 1844, 1845, 6, 213, 9, 0, 1845, 432, 1, 0, 0, 0, 1846, 1848, 8, 14, 0, 0, 1847, 1846,
    1, 0, 0, 0, 1848, 1849, 1, 0, 0, 0, 1849, 1847, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 434, 1,
    0, 0, 0, 1851, 1852, 5, 34, 0, 0, 1852, 1853, 5, 34, 0, 0, 1853, 1854, 5, 34, 0, 0, 1854, 1856,
    1, 0, 0, 0, 1855, 1857, 5, 35, 0, 0, 1856, 1855, 1, 0, 0, 0, 1857, 1858, 1, 0, 0, 0, 1858, 1856,
    1, 0, 0, 0, 1858, 1859, 1, 0, 0, 0, 1859, 1860, 1, 0, 0, 0, 1860, 1861, 6, 215, 9, 0, 1861, 436,
    1, 0, 0, 0, 1862, 1864, 8, 15, 0, 0, 1863, 1862, 1, 0, 0, 0, 1864, 1865, 1, 0, 0, 0, 1865, 1863,
    1, 0, 0, 0, 1865, 1866, 1, 0, 0, 0, 1866, 1872, 1, 0, 0, 0, 1867, 1869, 5, 34, 0, 0, 1868, 1870,
    5, 34, 0, 0, 1869, 1868, 1, 0, 0, 0, 1869, 1870, 1, 0, 0, 0, 1870, 1872, 1, 0, 0, 0, 1871, 1863,
    1, 0, 0, 0, 1871, 1867, 1, 0, 0, 0, 1872, 438, 1, 0, 0, 0, 1873, 1875, 3, 441, 218, 0, 1874, 1873,
    1, 0, 0, 0, 1875, 1876, 1, 0, 0, 0, 1876, 1874, 1, 0, 0, 0, 1876, 1877, 1, 0, 0, 0, 1877, 440, 1,
    0, 0, 0, 1878, 1881, 3, 447, 221, 0, 1879, 1881, 8, 16, 0, 0, 1880, 1878, 1, 0, 0, 0, 1880, 1879,
    1, 0, 0, 0, 1881, 442, 1, 0, 0, 0, 1882, 1894, 3, 447, 221, 0, 1883, 1885, 8, 17, 0, 0, 1884, 1883,
    1, 0, 0, 0, 1885, 1886, 1, 0, 0, 0, 1886, 1884, 1, 0, 0, 0, 1886, 1887, 1, 0, 0, 0, 1887, 1894,
    1, 0, 0, 0, 1888, 1890, 5, 34, 0, 0, 1889, 1891, 5, 34, 0, 0, 1890, 1889, 1, 0, 0, 0, 1890, 1891,
    1, 0, 0, 0, 1891, 1894, 1, 0, 0, 0, 1892, 1894, 3, 451, 223, 0, 1893, 1882, 1, 0, 0, 0, 1893, 1884,
    1, 0, 0, 0, 1893, 1888, 1, 0, 0, 0, 1893, 1892, 1, 0, 0, 0, 1894, 444, 1, 0, 0, 0, 1895, 1899, 5,
    92, 0, 0, 1896, 1898, 5, 35, 0, 0, 1897, 1896, 1, 0, 0, 0, 1898, 1901, 1, 0, 0, 0, 1899, 1897,
    1, 0, 0, 0, 1899, 1900, 1, 0, 0, 0, 1900, 446, 1, 0, 0, 0, 1901, 1899, 1, 0, 0, 0, 1902, 1909, 3,
    445, 220, 0, 1903, 1910, 7, 18, 0, 0, 1904, 1905, 5, 117, 0, 0, 1905, 1906, 5, 123, 0, 0, 1906,
    1907, 3, 449, 222, 0, 1907, 1908, 5, 125, 0, 0, 1908, 1910, 1, 0, 0, 0, 1909, 1903, 1, 0, 0, 0,
    1909, 1904, 1, 0, 0, 0, 1910, 448, 1, 0, 0, 0, 1911, 1913, 3, 381, 188, 0, 1912, 1914, 3, 381,
    188, 0, 1913, 1912, 1, 0, 0, 0, 1913, 1914, 1, 0, 0, 0, 1914, 1916, 1, 0, 0, 0, 1915, 1917, 3,
    381, 188, 0, 1916, 1915, 1, 0, 0, 0, 1916, 1917, 1, 0, 0, 0, 1917, 1919, 1, 0, 0, 0, 1918, 1920,
    3, 381, 188, 0, 1919, 1918, 1, 0, 0, 0, 1919, 1920, 1, 0, 0, 0, 1920, 1922, 1, 0, 0, 0, 1921, 1923,
    3, 381, 188, 0, 1922, 1921, 1, 0, 0, 0, 1922, 1923, 1, 0, 0, 0, 1923, 1925, 1, 0, 0, 0, 1924, 1926,
    3, 381, 188, 0, 1925, 1924, 1, 0, 0, 0, 1925, 1926, 1, 0, 0, 0, 1926, 1928, 1, 0, 0, 0, 1927, 1929,
    3, 381, 188, 0, 1928, 1927, 1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 1931, 1, 0, 0, 0, 1930, 1932,
    3, 381, 188, 0, 1931, 1930, 1, 0, 0, 0, 1931, 1932, 1, 0, 0, 0, 1932, 450, 1, 0, 0, 0, 1933, 1935,
    3, 445, 220, 0, 1934, 1936, 3, 453, 224, 0, 1935, 1934, 1, 0, 0, 0, 1935, 1936, 1, 0, 0, 0, 1936,
    1937, 1, 0, 0, 0, 1937, 1938, 3, 455, 225, 0, 1938, 452, 1, 0, 0, 0, 1939, 1940, 7, 19, 0, 0, 1940,
    454, 1, 0, 0, 0, 1941, 1945, 7, 12, 0, 0, 1942, 1943, 5, 13, 0, 0, 1943, 1945, 5, 10, 0, 0, 1944,
    1941, 1, 0, 0, 0, 1944, 1942, 1, 0, 0, 0, 1945, 456, 1, 0, 0, 0, 63, 0, 1, 2, 3, 4, 1521, 1525, 1528,
    1532, 1537, 1608, 1611, 1618, 1624, 1629, 1636, 1642, 1647, 1652, 1656, 1662, 1667, 1674,
    1680, 1685, 1689, 1692, 1696, 1700, 1707, 1714, 1718, 1731, 1741, 1747, 1756, 1758, 1772,
    1776, 1783, 1794, 1842, 1849, 1858, 1865, 1869, 1871, 1876, 1880, 1886, 1890, 1893, 1899,
    1909, 1913, 1916, 1919, 1922, 1925, 1928, 1931, 1935, 1944, 11, 1, 144, 0, 1, 147, 1, 0, 1,
    0, 5, 4, 0, 5, 3, 0, 5, 2, 0, 5, 1, 0, 1, 207, 2, 5, 0, 0, 4, 0, 0, 1, 210, 3];
const atn = new antlr4_1.default.atn.ATNDeserializer().deserialize(serializedATN);
const decisionsToDFA = atn.decisionToState.map((ds, index) => new antlr4_1.default.dfa.DFA(ds, index));
class Swift5Lexer extends antlr4_1.default.Lexer {
    static grammarFileName = "Swift5Lexer.g4";
    static channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
    static modeNames = ["DEFAULT_MODE", "SingleLine", "MultiLine", "SingleLineExtended",
        "MultiLineExtended"];
    static literalNames = [null, "'as'", "'alpha'", "'break'", "'case'", "'catch'",
        "'class'", "'continue'", "'default'", "'defer'",
        "'do'", "'guard'", "'else'", "'enum'", "'for'",
        "'fallthrough'", "'func'", "'in'", "'if'", "'import'",
        "'internal'", "'final'", "'open'", "'private'",
        "'public'", "'where'", "'while'", "'let'", "'var'",
        "'protocol'", "'get'", "'set'", "'willSet'", "'didSet'",
        "'repeat'", "'switch'", "'struct'", "'return'",
        "'throw'", "'throws'", "'rethrows'", "'indirect'",
        "'init'", "'deinit'", "'associatedtype'", "'extension'",
        "'subscript'", "'prefix'", "'infix'", "'left'",
        "'right'", "'none'", "'precedencegroup'", "'higherThan'",
        "'lowerThan'", "'assignment'", "'associativity'",
        "'postfix'", "'operator'", "'typealias'", "'os'",
        "'arch'", "'swift'", "'compiler'", "'canImport'",
        "'targetEnvironment'", "'convenience'", "'dynamic'",
        "'lazy'", "'optional'", "'override'", "'required'",
        "'static'", "'weak'", "'unowned'", "'safe'", "'unsafe'",
        "'mutating'", "'nonmutating'", "'fileprivate'",
        "'is'", "'try'", "'super'", "'Any'", "'false'",
        "'red'", "'blue'", "'green'", "'resourceName'",
        "'true'", "'nil'", "'inout'", "'some'", "'Type'",
        "'precedence'", "'self'", "'Self'", "'macOS'",
        "'iOS'", "'OSX'", "'watchOS'", "'tvOS'", "'Linux'",
        "'Windows'", "'i386'", "'x86_64'", "'arm'", "'arm64'",
        "'simulator'", "'macCatalyst'", "'iOSApplicationExtension'",
        "'macCatalystApplicationExtension'", "'macOSApplicationExtension'",
        "'#sourceLocation'", "'file'", "'line'", "'#error'",
        "'#warning'", "'#available'", "'#if'", "'#elseif'",
        "'#else'", "'#endif'", "'#file'", "'#fileID'",
        "'#filePath'", "'#line'", "'#column'", "'#function'",
        "'#dsohandle'", "'#selector'", "'#keyPath'", "'#colorLiteral'",
        "'#fileLiteral'", "'#imageLiteral'", "'getter'",
        "'setter'", null, "'.'", "'{'", "'('", "'['", "'}'",
        "')'", "']'", "','", "':'", "';'", "'<'", "'>'",
        "'_'", "'!'", "'?'", "'@'", "'&'", "'-'", "'='",
        "'|'", "'/'", "'+'", "'*'", "'%'", "'^'", "'~'",
        "'#'", "'`'", "'$'", "'\\'"];
    static symbolicNames = [null, "AS", "ALPHA", "BREAK", "CASE", "CATCH",
        "CLASS", "CONTINUE", "DEFAULT", "DEFER", "DO",
        "GUARD", "ELSE", "ENUM", "FOR", "FALLTHROUGH",
        "FUNC", "IN", "IF", "IMPORT", "INTERNAL", "FINAL",
        "OPEN", "PRIVATE", "PUBLIC", "WHERE", "WHILE",
        "LET", "VAR", "PROTOCOL", "GET", "SET", "WILL_SET",
        "DID_SET", "REPEAT", "SWITCH", "STRUCT", "RETURN",
        "THROW", "THROWS", "RETHROWS", "INDIRECT", "INIT",
        "DEINIT", "ASSOCIATED_TYPE", "EXTENSION", "SUBSCRIPT",
        "PREFIX", "INFIX", "LEFT", "RIGHT", "NONE", "PRECEDENCE_GROUP",
        "HIGHER_THAN", "LOWER_THAN", "ASSIGNMENT", "ASSOCIATIVITY",
        "POSTFIX", "OPERATOR", "TYPEALIAS", "OS", "ARCH",
        "SWIFT", "COMPILER", "CAN_IMPORT", "TARGET_ENVIRONMENT",
        "CONVENIENCE", "DYNAMIC", "LAZY", "OPTIONAL",
        "OVERRIDE", "REQUIRED", "STATIC", "WEAK", "UNOWNED",
        "SAFE", "UNSAFE", "MUTATING", "NONMUTATING", "FILE_PRIVATE",
        "IS", "TRY", "SUPER", "ANY", "FALSE", "RED", "BLUE",
        "GREEN", "RESOURCE_NAME", "TRUE", "NIL", "INOUT",
        "SOME", "TYPE", "PRECEDENCE", "SELF", "SELF_BIG",
        "MAC_OS", "I_OS", "OSX", "WATCH_OS", "TV_OS",
        "LINUX", "WINDOWS", "I386", "X86_64", "ARM", "ARM64",
        "SIMULATOR", "MAC_CATALYST", "I_OS_APPLICATION_EXTENSION",
        "MAC_CATALYST_APPLICATION_EXTENSION", "MAC_OS_APPLICATION_EXTENSION",
        "SOURCE_LOCATION", "FILE", "LINE", "ERROR", "WARNING",
        "AVAILABLE", "HASH_IF", "HASH_ELSEIF", "HASH_ELSE",
        "HASH_ENDIF", "HASH_FILE", "HASH_FILE_ID", "HASH_FILE_PATH",
        "HASH_LINE", "HASH_COLUMN", "HASH_FUNCTION", "HASH_DSO_HANDLE",
        "HASH_SELECTOR", "HASH_KEYPATH", "HASH_COLOR_LITERAL",
        "HASH_FILE_LITERAL", "HASH_IMAGE_LITERAL", "GETTER",
        "SETTER", "Identifier", "DOT", "LCURLY", "LPAREN",
        "LBRACK", "RCURLY", "RPAREN", "RBRACK", "COMMA",
        "COLON", "SEMI", "LT", "GT", "UNDERSCORE", "BANG",
        "QUESTION", "AT", "AND", "SUB", "EQUAL", "OR",
        "DIV", "ADD", "MUL", "MOD", "CARET", "TILDE",
        "HASH", "BACKTICK", "DOLLAR", "BACKSLASH", "Operator_head_other",
        "Operator_following_character", "Binary_literal",
        "Octal_literal", "Decimal_digits", "Decimal_literal",
        "Hexadecimal_literal", "Floating_point_literal",
        "WS", "HASHBANG", "Block_comment", "Line_comment",
        "Multi_line_extended_string_open", "Single_line_extended_string_open",
        "Multi_line_string_open", "Single_line_string_open",
        "Interpolataion_single_line", "Single_line_string_close",
        "Quoted_single_line_text", "Interpolataion_multi_line",
        "Multi_line_string_close", "Quoted_multi_line_text",
        "Single_line_extended_string_close", "Quoted_single_line_extended_text",
        "Multi_line_extended_string_close", "Quoted_multi_line_extended_text"];
    static ruleNames = ["AS", "ALPHA", "BREAK", "CASE", "CATCH", "CLASS",
        "CONTINUE", "DEFAULT", "DEFER", "DO", "GUARD", "ELSE",
        "ENUM", "FOR", "FALLTHROUGH", "FUNC", "IN", "IF",
        "IMPORT", "INTERNAL", "FINAL", "OPEN", "PRIVATE",
        "PUBLIC", "WHERE", "WHILE", "LET", "VAR", "PROTOCOL",
        "GET", "SET", "WILL_SET", "DID_SET", "REPEAT", "SWITCH",
        "STRUCT", "RETURN", "THROW", "THROWS", "RETHROWS",
        "INDIRECT", "INIT", "DEINIT", "ASSOCIATED_TYPE", "EXTENSION",
        "SUBSCRIPT", "PREFIX", "INFIX", "LEFT", "RIGHT", "NONE",
        "PRECEDENCE_GROUP", "HIGHER_THAN", "LOWER_THAN", "ASSIGNMENT",
        "ASSOCIATIVITY", "POSTFIX", "OPERATOR", "TYPEALIAS",
        "OS", "ARCH", "SWIFT", "COMPILER", "CAN_IMPORT", "TARGET_ENVIRONMENT",
        "CONVENIENCE", "DYNAMIC", "LAZY", "OPTIONAL", "OVERRIDE",
        "REQUIRED", "STATIC", "WEAK", "UNOWNED", "SAFE", "UNSAFE",
        "MUTATING", "NONMUTATING", "FILE_PRIVATE", "IS", "TRY",
        "SUPER", "ANY", "FALSE", "RED", "BLUE", "GREEN", "RESOURCE_NAME",
        "TRUE", "NIL", "INOUT", "SOME", "TYPE", "PRECEDENCE",
        "SELF", "SELF_BIG", "MAC_OS", "I_OS", "OSX", "WATCH_OS",
        "TV_OS", "LINUX", "WINDOWS", "I386", "X86_64", "ARM",
        "ARM64", "SIMULATOR", "MAC_CATALYST", "I_OS_APPLICATION_EXTENSION",
        "MAC_CATALYST_APPLICATION_EXTENSION", "MAC_OS_APPLICATION_EXTENSION",
        "SOURCE_LOCATION", "FILE", "LINE", "ERROR", "WARNING",
        "AVAILABLE", "HASH_IF", "HASH_ELSEIF", "HASH_ELSE",
        "HASH_ENDIF", "HASH_FILE", "HASH_FILE_ID", "HASH_FILE_PATH",
        "HASH_LINE", "HASH_COLUMN", "HASH_FUNCTION", "HASH_DSO_HANDLE",
        "HASH_SELECTOR", "HASH_KEYPATH", "HASH_COLOR_LITERAL",
        "HASH_FILE_LITERAL", "HASH_IMAGE_LITERAL", "GETTER",
        "SETTER", "Identifier", "Identifier_head", "Identifier_character",
        "Identifier_characters", "Implicit_parameter_name",
        "Property_wrapper_projection", "DOT", "LCURLY", "LPAREN",
        "LBRACK", "RCURLY", "RPAREN", "RBRACK", "COMMA", "COLON",
        "SEMI", "LT", "GT", "UNDERSCORE", "BANG", "QUESTION",
        "AT", "AND", "SUB", "EQUAL", "OR", "DIV", "ADD", "MUL",
        "MOD", "CARET", "TILDE", "HASH", "BACKTICK", "DOLLAR",
        "BACKSLASH", "Operator_head_other", "Operator_following_character",
        "Binary_literal", "Binary_digit", "Binary_literal_character",
        "Binary_literal_characters", "Octal_literal", "Octal_digit",
        "Octal_literal_character", "Octal_literal_characters",
        "Decimal_digits", "Decimal_literal", "Decimal_digit",
        "Decimal_literal_character", "Decimal_literal_characters",
        "Hexadecimal_literal", "Hexadecimal_digit", "Hexadecimal_literal_character",
        "Hexadecimal_literal_characters", "Floating_point_literal",
        "Decimal_fraction", "Decimal_exponent", "Hexadecimal_fraction",
        "Hexadecimal_exponent", "Floating_point_e", "Floating_point_p",
        "Sign", "WS", "HASHBANG", "Block_comment", "Line_comment",
        "Multi_line_extended_string_open", "Single_line_extended_string_open",
        "Multi_line_string_open", "Single_line_string_open",
        "Interpolataion_single_line", "Single_line_string_close",
        "Quoted_single_line_text", "Interpolataion_multi_line",
        "Multi_line_string_close", "Quoted_multi_line_text",
        "Single_line_extended_string_close", "Quoted_single_line_extended_text",
        "Multi_line_extended_string_close", "Quoted_multi_line_extended_text",
        "Quoted_text", "Quoted_text_item", "Multiline_quoted_text",
        "Escape_sequence", "Escaped_character", "Unicode_scalar_digits",
        "Escaped_newline", "Inline_spaces", "Line_break"];
    constructor(input) {
        super(input);
        this._interp = new antlr4_1.default.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4_1.default.PredictionContextCache());
        this.parenthesis = new Stack_1.Stack();
    }
    reset() {
        super.reset();
        this.parenthesis.clear();
    }
    get atn() {
        return atn;
    }
}
exports["default"] = Swift5Lexer;
Swift5Lexer.EOF = antlr4_1.default.Token.EOF;
Swift5Lexer.AS = 1;
Swift5Lexer.ALPHA = 2;
Swift5Lexer.BREAK = 3;
Swift5Lexer.CASE = 4;
Swift5Lexer.CATCH = 5;
Swift5Lexer.CLASS = 6;
Swift5Lexer.CONTINUE = 7;
Swift5Lexer.DEFAULT = 8;
Swift5Lexer.DEFER = 9;
Swift5Lexer.DO = 10;
Swift5Lexer.GUARD = 11;
Swift5Lexer.ELSE = 12;
Swift5Lexer.ENUM = 13;
Swift5Lexer.FOR = 14;
Swift5Lexer.FALLTHROUGH = 15;
Swift5Lexer.FUNC = 16;
Swift5Lexer.IN = 17;
Swift5Lexer.IF = 18;
Swift5Lexer.IMPORT = 19;
Swift5Lexer.INTERNAL = 20;
Swift5Lexer.FINAL = 21;
Swift5Lexer.OPEN = 22;
Swift5Lexer.PRIVATE = 23;
Swift5Lexer.PUBLIC = 24;
Swift5Lexer.WHERE = 25;
Swift5Lexer.WHILE = 26;
Swift5Lexer.LET = 27;
Swift5Lexer.VAR = 28;
Swift5Lexer.PROTOCOL = 29;
Swift5Lexer.GET = 30;
Swift5Lexer.SET = 31;
Swift5Lexer.WILL_SET = 32;
Swift5Lexer.DID_SET = 33;
Swift5Lexer.REPEAT = 34;
Swift5Lexer.SWITCH = 35;
Swift5Lexer.STRUCT = 36;
Swift5Lexer.RETURN = 37;
Swift5Lexer.THROW = 38;
Swift5Lexer.THROWS = 39;
Swift5Lexer.RETHROWS = 40;
Swift5Lexer.INDIRECT = 41;
Swift5Lexer.INIT = 42;
Swift5Lexer.DEINIT = 43;
Swift5Lexer.ASSOCIATED_TYPE = 44;
Swift5Lexer.EXTENSION = 45;
Swift5Lexer.SUBSCRIPT = 46;
Swift5Lexer.PREFIX = 47;
Swift5Lexer.INFIX = 48;
Swift5Lexer.LEFT = 49;
Swift5Lexer.RIGHT = 50;
Swift5Lexer.NONE = 51;
Swift5Lexer.PRECEDENCE_GROUP = 52;
Swift5Lexer.HIGHER_THAN = 53;
Swift5Lexer.LOWER_THAN = 54;
Swift5Lexer.ASSIGNMENT = 55;
Swift5Lexer.ASSOCIATIVITY = 56;
Swift5Lexer.POSTFIX = 57;
Swift5Lexer.OPERATOR = 58;
Swift5Lexer.TYPEALIAS = 59;
Swift5Lexer.OS = 60;
Swift5Lexer.ARCH = 61;
Swift5Lexer.SWIFT = 62;
Swift5Lexer.COMPILER = 63;
Swift5Lexer.CAN_IMPORT = 64;
Swift5Lexer.TARGET_ENVIRONMENT = 65;
Swift5Lexer.CONVENIENCE = 66;
Swift5Lexer.DYNAMIC = 67;
Swift5Lexer.LAZY = 68;
Swift5Lexer.OPTIONAL = 69;
Swift5Lexer.OVERRIDE = 70;
Swift5Lexer.REQUIRED = 71;
Swift5Lexer.STATIC = 72;
Swift5Lexer.WEAK = 73;
Swift5Lexer.UNOWNED = 74;
Swift5Lexer.SAFE = 75;
Swift5Lexer.UNSAFE = 76;
Swift5Lexer.MUTATING = 77;
Swift5Lexer.NONMUTATING = 78;
Swift5Lexer.FILE_PRIVATE = 79;
Swift5Lexer.IS = 80;
Swift5Lexer.TRY = 81;
Swift5Lexer.SUPER = 82;
Swift5Lexer.ANY = 83;
Swift5Lexer.FALSE = 84;
Swift5Lexer.RED = 85;
Swift5Lexer.BLUE = 86;
Swift5Lexer.GREEN = 87;
Swift5Lexer.RESOURCE_NAME = 88;
Swift5Lexer.TRUE = 89;
Swift5Lexer.NIL = 90;
Swift5Lexer.INOUT = 91;
Swift5Lexer.SOME = 92;
Swift5Lexer.TYPE = 93;
Swift5Lexer.PRECEDENCE = 94;
Swift5Lexer.SELF = 95;
Swift5Lexer.SELF_BIG = 96;
Swift5Lexer.MAC_OS = 97;
Swift5Lexer.I_OS = 98;
Swift5Lexer.OSX = 99;
Swift5Lexer.WATCH_OS = 100;
Swift5Lexer.TV_OS = 101;
Swift5Lexer.LINUX = 102;
Swift5Lexer.WINDOWS = 103;
Swift5Lexer.I386 = 104;
Swift5Lexer.X86_64 = 105;
Swift5Lexer.ARM = 106;
Swift5Lexer.ARM64 = 107;
Swift5Lexer.SIMULATOR = 108;
Swift5Lexer.MAC_CATALYST = 109;
Swift5Lexer.I_OS_APPLICATION_EXTENSION = 110;
Swift5Lexer.MAC_CATALYST_APPLICATION_EXTENSION = 111;
Swift5Lexer.MAC_OS_APPLICATION_EXTENSION = 112;
Swift5Lexer.SOURCE_LOCATION = 113;
Swift5Lexer.FILE = 114;
Swift5Lexer.LINE = 115;
Swift5Lexer.ERROR = 116;
Swift5Lexer.WARNING = 117;
Swift5Lexer.AVAILABLE = 118;
Swift5Lexer.HASH_IF = 119;
Swift5Lexer.HASH_ELSEIF = 120;
Swift5Lexer.HASH_ELSE = 121;
Swift5Lexer.HASH_ENDIF = 122;
Swift5Lexer.HASH_FILE = 123;
Swift5Lexer.HASH_FILE_ID = 124;
Swift5Lexer.HASH_FILE_PATH = 125;
Swift5Lexer.HASH_LINE = 126;
Swift5Lexer.HASH_COLUMN = 127;
Swift5Lexer.HASH_FUNCTION = 128;
Swift5Lexer.HASH_DSO_HANDLE = 129;
Swift5Lexer.HASH_SELECTOR = 130;
Swift5Lexer.HASH_KEYPATH = 131;
Swift5Lexer.HASH_COLOR_LITERAL = 132;
Swift5Lexer.HASH_FILE_LITERAL = 133;
Swift5Lexer.HASH_IMAGE_LITERAL = 134;
Swift5Lexer.GETTER = 135;
Swift5Lexer.SETTER = 136;
Swift5Lexer.Identifier = 137;
Swift5Lexer.DOT = 138;
Swift5Lexer.LCURLY = 139;
Swift5Lexer.LPAREN = 140;
Swift5Lexer.LBRACK = 141;
Swift5Lexer.RCURLY = 142;
Swift5Lexer.RPAREN = 143;
Swift5Lexer.RBRACK = 144;
Swift5Lexer.COMMA = 145;
Swift5Lexer.COLON = 146;
Swift5Lexer.SEMI = 147;
Swift5Lexer.LT = 148;
Swift5Lexer.GT = 149;
Swift5Lexer.UNDERSCORE = 150;
Swift5Lexer.BANG = 151;
Swift5Lexer.QUESTION = 152;
Swift5Lexer.AT = 153;
Swift5Lexer.AND = 154;
Swift5Lexer.SUB = 155;
Swift5Lexer.EQUAL = 156;
Swift5Lexer.OR = 157;
Swift5Lexer.DIV = 158;
Swift5Lexer.ADD = 159;
Swift5Lexer.MUL = 160;
Swift5Lexer.MOD = 161;
Swift5Lexer.CARET = 162;
Swift5Lexer.TILDE = 163;
Swift5Lexer.HASH = 164;
Swift5Lexer.BACKTICK = 165;
Swift5Lexer.DOLLAR = 166;
Swift5Lexer.BACKSLASH = 167;
Swift5Lexer.Operator_head_other = 168;
Swift5Lexer.Operator_following_character = 169;
Swift5Lexer.Binary_literal = 170;
Swift5Lexer.Octal_literal = 171;
Swift5Lexer.Decimal_digits = 172;
Swift5Lexer.Decimal_literal = 173;
Swift5Lexer.Hexadecimal_literal = 174;
Swift5Lexer.Floating_point_literal = 175;
Swift5Lexer.WS = 176;
Swift5Lexer.HASHBANG = 177;
Swift5Lexer.Block_comment = 178;
Swift5Lexer.Line_comment = 179;
Swift5Lexer.Multi_line_extended_string_open = 180;
Swift5Lexer.Single_line_extended_string_open = 181;
Swift5Lexer.Multi_line_string_open = 182;
Swift5Lexer.Single_line_string_open = 183;
Swift5Lexer.Interpolataion_single_line = 184;
Swift5Lexer.Single_line_string_close = 185;
Swift5Lexer.Quoted_single_line_text = 186;
Swift5Lexer.Interpolataion_multi_line = 187;
Swift5Lexer.Multi_line_string_close = 188;
Swift5Lexer.Quoted_multi_line_text = 189;
Swift5Lexer.Single_line_extended_string_close = 190;
Swift5Lexer.Quoted_single_line_extended_text = 191;
Swift5Lexer.Multi_line_extended_string_close = 192;
Swift5Lexer.Quoted_multi_line_extended_text = 193;
Swift5Lexer.SingleLine = 1;
Swift5Lexer.MultiLine = 2;
Swift5Lexer.SingleLineExtended = 3;
Swift5Lexer.MultiLineExtended = 4;
Swift5Lexer.prototype.action = function (localctx, ruleIndex, actionIndex) {
    switch (ruleIndex) {
        case 144:
            this.LPAREN_action(localctx, actionIndex);
            break;
        case 147:
            this.RPAREN_action(localctx, actionIndex);
            break;
        case 207:
            this.Interpolataion_single_line_action(localctx, actionIndex);
            break;
        case 210:
            this.Interpolataion_multi_line_action(localctx, actionIndex);
            break;
        default:
            throw "No registered action for:" + ruleIndex;
    }
};
Swift5Lexer.prototype.LPAREN_action = function (localctx, actionIndex) {
    switch (actionIndex) {
        case 0:
            if (!this.parenthesis.isEmpty())
                this.parenthesis.push(this.parenthesis.pop() + 1);
            break;
        default:
            throw "No registered action for:" + actionIndex;
    }
};
Swift5Lexer.prototype.RPAREN_action = function (localctx, actionIndex) {
    switch (actionIndex) {
        case 1:
            if (!this.parenthesis.isEmpty()) {
                this.parenthesis.push(this.parenthesis.pop() - 1);
                if (this.parenthesis.peek() == 0) {
                    this.parenthesis.pop();
                    this.popMode();
                }
            }
            break;
        default:
            throw "No registered action for:" + actionIndex;
    }
};
Swift5Lexer.prototype.Interpolataion_single_line_action = function (localctx, actionIndex) {
    switch (actionIndex) {
        case 2:
            this.parenthesis.push(1);
            break;
        default:
            throw "No registered action for:" + actionIndex;
    }
};
Swift5Lexer.prototype.Interpolataion_multi_line_action = function (localctx, actionIndex) {
    switch (actionIndex) {
        case 3:
            this.parenthesis.push(1);
            break;
        default:
            throw "No registered action for:" + actionIndex;
    }
};
//# sourceMappingURL=Swift5Lexer.js.map

/***/ }),

/***/ 2434:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Swift5ParserCompat = void 0;
const antlr4_1 = __importDefault(__webpack_require__(7228));
exports.Swift5ParserCompat = {
    EOF: antlr4_1.default.Token.EOF,
    AS: 1,
    ALPHA: 2,
    BREAK: 3,
    CASE: 4,
    CATCH: 5,
    CLASS: 6,
    CONTINUE: 7,
    DEFAULT: 8,
    DEFER: 9,
    DO: 10,
    GUARD: 11,
    ELSE: 12,
    ENUM: 13,
    FOR: 14,
    FALLTHROUGH: 15,
    FUNC: 16,
    IN: 17,
    IF: 18,
    IMPORT: 19,
    INTERNAL: 20,
    FINAL: 21,
    OPEN: 22,
    PRIVATE: 23,
    PUBLIC: 24,
    WHERE: 25,
    WHILE: 26,
    LET: 27,
    VAR: 28,
    PROTOCOL: 29,
    GET: 30,
    SET: 31,
    WILL_SET: 32,
    DID_SET: 33,
    REPEAT: 34,
    SWITCH: 35,
    STRUCT: 36,
    RETURN: 37,
    THROW: 38,
    THROWS: 39,
    RETHROWS: 40,
    INDIRECT: 41,
    INIT: 42,
    DEINIT: 43,
    ASSOCIATED_TYPE: 44,
    EXTENSION: 45,
    SUBSCRIPT: 46,
    PREFIX: 47,
    INFIX: 48,
    LEFT: 49,
    RIGHT: 50,
    NONE: 51,
    PRECEDENCE_GROUP: 52,
    HIGHER_THAN: 53,
    LOWER_THAN: 54,
    ASSIGNMENT: 55,
    ASSOCIATIVITY: 56,
    POSTFIX: 57,
    OPERATOR: 58,
    TYPEALIAS: 59,
    OS: 60,
    ARCH: 61,
    SWIFT: 62,
    COMPILER: 63,
    CAN_IMPORT: 64,
    TARGET_ENVIRONMENT: 65,
    CONVENIENCE: 66,
    DYNAMIC: 67,
    LAZY: 68,
    OPTIONAL: 69,
    OVERRIDE: 70,
    REQUIRED: 71,
    STATIC: 72,
    WEAK: 73,
    UNOWNED: 74,
    SAFE: 75,
    UNSAFE: 76,
    MUTATING: 77,
    NONMUTATING: 78,
    FILE_PRIVATE: 79,
    IS: 80,
    TRY: 81,
    SUPER: 82,
    ANY: 83,
    FALSE: 84,
    RED: 85,
    BLUE: 86,
    GREEN: 87,
    RESOURCE_NAME: 88,
    TRUE: 89,
    NIL: 90,
    INOUT: 91,
    SOME: 92,
    TYPE: 93,
    PRECEDENCE: 94,
    SELF: 95,
    SELF_BIG: 96,
    MAC_OS: 97,
    I_OS: 98,
    OSX: 99,
    WATCH_OS: 100,
    TV_OS: 101,
    LINUX: 102,
    WINDOWS: 103,
    I386: 104,
    X86_64: 105,
    ARM: 106,
    ARM64: 107,
    SIMULATOR: 108,
    MAC_CATALYST: 109,
    I_OS_APPLICATION_EXTENSION: 110,
    MAC_CATALYST_APPLICATION_EXTENSION: 111,
    MAC_OS_APPLICATION_EXTENSION: 112,
    SOURCE_LOCATION: 113,
    FILE: 114,
    LINE: 115,
    ERROR: 116,
    WARNING: 117,
    AVAILABLE: 118,
    HASH_IF: 119,
    HASH_ELSEIF: 120,
    HASH_ELSE: 121,
    HASH_ENDIF: 122,
    HASH_FILE: 123,
    HASH_FILE_ID: 124,
    HASH_FILE_PATH: 125,
    HASH_LINE: 126,
    HASH_COLUMN: 127,
    HASH_FUNCTION: 128,
    HASH_DSO_HANDLE: 129,
    HASH_SELECTOR: 130,
    HASH_KEYPATH: 131,
    HASH_COLOR_LITERAL: 132,
    HASH_FILE_LITERAL: 133,
    HASH_IMAGE_LITERAL: 134,
    GETTER: 135,
    SETTER: 136,
    Identifier: 137,
    DOT: 138,
    LCURLY: 139,
    LPAREN: 140,
    LBRACK: 141,
    RCURLY: 142,
    RPAREN: 143,
    RBRACK: 144,
    COMMA: 145,
    COLON: 146,
    SEMI: 147,
    LT: 148,
    GT: 149,
    UNDERSCORE: 150,
    BANG: 151,
    QUESTION: 152,
    AT: 153,
    AND: 154,
    SUB: 155,
    EQUAL: 156,
    OR: 157,
    DIV: 158,
    ADD: 159,
    MUL: 160,
    MOD: 161,
    CARET: 162,
    TILDE: 163,
    HASH: 164,
    BACKTICK: 165,
    DOLLAR: 166,
    BACKSLASH: 167,
    Operator_head_other: 168,
    Operator_following_character: 169,
    Binary_literal: 170,
    Octal_literal: 171,
    Decimal_digits: 172,
    Decimal_literal: 173,
    Hexadecimal_literal: 174,
    Floating_point_literal: 175,
    WS: 176,
    HASHBANG: 177,
    Block_comment: 178,
    Line_comment: 179,
    Multi_line_extended_string_open: 180,
    Single_line_extended_string_open: 181,
    Multi_line_string_open: 182,
    Single_line_string_open: 183,
    Interpolataion_single_line: 184,
    Single_line_string_close: 185,
    Quoted_single_line_text: 186,
    Interpolataion_multi_line: 187,
    Multi_line_string_close: 188,
    Quoted_multi_line_text: 189,
    Single_line_extended_string_close: 190,
    Quoted_single_line_extended_text: 191,
    Multi_line_extended_string_close: 192,
    Quoted_multi_line_extended_text: 193,
};
//# sourceMappingURL=Swift5ParserCompat.js.map

/***/ }),

/***/ 2118:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Generated from ./assets/swift/Swift5Parser.g4 by ANTLR 4.10.1
// jshint ignore: start
const antlr4_1 = __importDefault(__webpack_require__(7228));
// This class defines a complete listener for a parse tree produced by Swift5Parser.
class Swift5ParserListener extends antlr4_1.default.tree.ParseTreeListener {
    // Enter a parse tree produced by Swift5Parser#top_level.
    enterTop_level(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#top_level.
    exitTop_level(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#statement.
    enterStatement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#statement.
    exitStatement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#statements.
    enterStatements(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#statements.
    exitStatements(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#loop_statement.
    enterLoop_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#loop_statement.
    exitLoop_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#for_in_statement.
    enterFor_in_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#for_in_statement.
    exitFor_in_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#while_statement.
    enterWhile_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#while_statement.
    exitWhile_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#condition_list.
    enterCondition_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#condition_list.
    exitCondition_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#condition.
    enterCondition(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#condition.
    exitCondition(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#case_condition.
    enterCase_condition(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#case_condition.
    exitCase_condition(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#optional_binding_condition.
    enterOptional_binding_condition(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#optional_binding_condition.
    exitOptional_binding_condition(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#repeat_while_statement.
    enterRepeat_while_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#repeat_while_statement.
    exitRepeat_while_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#branch_statement.
    enterBranch_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#branch_statement.
    exitBranch_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#if_statement.
    enterIf_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#if_statement.
    exitIf_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#else_clause.
    enterElse_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#else_clause.
    exitElse_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#guard_statement.
    enterGuard_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#guard_statement.
    exitGuard_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#switch_statement.
    enterSwitch_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#switch_statement.
    exitSwitch_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#switch_cases.
    enterSwitch_cases(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#switch_cases.
    exitSwitch_cases(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#switch_case.
    enterSwitch_case(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#switch_case.
    exitSwitch_case(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#case_label.
    enterCase_label(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#case_label.
    exitCase_label(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#case_item_list.
    enterCase_item_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#case_item_list.
    exitCase_item_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#default_label.
    enterDefault_label(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#default_label.
    exitDefault_label(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#where_clause.
    enterWhere_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#where_clause.
    exitWhere_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#where_expression.
    enterWhere_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#where_expression.
    exitWhere_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#conditional_switch_case.
    enterConditional_switch_case(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#conditional_switch_case.
    exitConditional_switch_case(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#switch_if_directive_clause.
    enterSwitch_if_directive_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#switch_if_directive_clause.
    exitSwitch_if_directive_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#switch_elseif_directive_clauses.
    enterSwitch_elseif_directive_clauses(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#switch_elseif_directive_clauses.
    exitSwitch_elseif_directive_clauses(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#switch_elseif_directive_clause.
    enterSwitch_elseif_directive_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#switch_elseif_directive_clause.
    exitSwitch_elseif_directive_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#switch_else_directive_clause.
    enterSwitch_else_directive_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#switch_else_directive_clause.
    exitSwitch_else_directive_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#labeled_statement.
    enterLabeled_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#labeled_statement.
    exitLabeled_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#statement_label.
    enterStatement_label(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#statement_label.
    exitStatement_label(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#label_name.
    enterLabel_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#label_name.
    exitLabel_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#control_transfer_statement.
    enterControl_transfer_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#control_transfer_statement.
    exitControl_transfer_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#break_statement.
    enterBreak_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#break_statement.
    exitBreak_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#continue_statement.
    enterContinue_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#continue_statement.
    exitContinue_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#fallthrough_statement.
    enterFallthrough_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#fallthrough_statement.
    exitFallthrough_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#return_statement.
    enterReturn_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#return_statement.
    exitReturn_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#throw_statement.
    enterThrow_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#throw_statement.
    exitThrow_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#defer_statement.
    enterDefer_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#defer_statement.
    exitDefer_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#do_statement.
    enterDo_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#do_statement.
    exitDo_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#catch_clauses.
    enterCatch_clauses(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#catch_clauses.
    exitCatch_clauses(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#catch_clause.
    enterCatch_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#catch_clause.
    exitCatch_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#catch_pattern_list.
    enterCatch_pattern_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#catch_pattern_list.
    exitCatch_pattern_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#catch_pattern.
    enterCatch_pattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#catch_pattern.
    exitCatch_pattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#compiler_control_statement.
    enterCompiler_control_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#compiler_control_statement.
    exitCompiler_control_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#conditional_compilation_block.
    enterConditional_compilation_block(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#conditional_compilation_block.
    exitConditional_compilation_block(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#if_directive_clause.
    enterIf_directive_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#if_directive_clause.
    exitIf_directive_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#elseif_directive_clauses.
    enterElseif_directive_clauses(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#elseif_directive_clauses.
    exitElseif_directive_clauses(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#elseif_directive_clause.
    enterElseif_directive_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#elseif_directive_clause.
    exitElseif_directive_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#else_directive_clause.
    enterElse_directive_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#else_directive_clause.
    exitElse_directive_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#compilation_condition.
    enterCompilation_condition(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#compilation_condition.
    exitCompilation_condition(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#platform_condition.
    enterPlatform_condition(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#platform_condition.
    exitPlatform_condition(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#swift_version.
    enterSwift_version(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#swift_version.
    exitSwift_version(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#swift_version_continuation.
    enterSwift_version_continuation(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#swift_version_continuation.
    exitSwift_version_continuation(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#operating_system.
    enterOperating_system(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#operating_system.
    exitOperating_system(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#architecture.
    enterArchitecture(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#architecture.
    exitArchitecture(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#module_name.
    enterModule_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#module_name.
    exitModule_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#environment.
    enterEnvironment(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#environment.
    exitEnvironment(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#line_control_statement.
    enterLine_control_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#line_control_statement.
    exitLine_control_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#line_number.
    enterLine_number(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#line_number.
    exitLine_number(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#file_name.
    enterFile_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#file_name.
    exitFile_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#diagnostic_statement.
    enterDiagnostic_statement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#diagnostic_statement.
    exitDiagnostic_statement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#diagnostic_message.
    enterDiagnostic_message(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#diagnostic_message.
    exitDiagnostic_message(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#availability_condition.
    enterAvailability_condition(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#availability_condition.
    exitAvailability_condition(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#availability_arguments.
    enterAvailability_arguments(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#availability_arguments.
    exitAvailability_arguments(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#availability_argument.
    enterAvailability_argument(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#availability_argument.
    exitAvailability_argument(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#platform_name.
    enterPlatform_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#platform_name.
    exitPlatform_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#platform_version.
    enterPlatform_version(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#platform_version.
    exitPlatform_version(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#generic_parameter_clause.
    enterGeneric_parameter_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#generic_parameter_clause.
    exitGeneric_parameter_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#generic_parameter_list.
    enterGeneric_parameter_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#generic_parameter_list.
    exitGeneric_parameter_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#generic_parameter.
    enterGeneric_parameter(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#generic_parameter.
    exitGeneric_parameter(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#generic_where_clause.
    enterGeneric_where_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#generic_where_clause.
    exitGeneric_where_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#requirement_list.
    enterRequirement_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#requirement_list.
    exitRequirement_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#requirement.
    enterRequirement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#requirement.
    exitRequirement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#conformance_requirement.
    enterConformance_requirement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#conformance_requirement.
    exitConformance_requirement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#same_type_requirement.
    enterSame_type_requirement(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#same_type_requirement.
    exitSame_type_requirement(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#generic_argument_clause.
    enterGeneric_argument_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#generic_argument_clause.
    exitGeneric_argument_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#generic_argument_list.
    enterGeneric_argument_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#generic_argument_list.
    exitGeneric_argument_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#generic_argument.
    enterGeneric_argument(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#generic_argument.
    exitGeneric_argument(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#declaration.
    enterDeclaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#declaration.
    exitDeclaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#declarations.
    enterDeclarations(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#declarations.
    exitDeclarations(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#top_level_declaration.
    enterTop_level_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#top_level_declaration.
    exitTop_level_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#code_block.
    enterCode_block(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#code_block.
    exitCode_block(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#import_declaration.
    enterImport_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#import_declaration.
    exitImport_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#import_kind.
    enterImport_kind(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#import_kind.
    exitImport_kind(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#import_path.
    enterImport_path(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#import_path.
    exitImport_path(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#import_path_identifier.
    enterImport_path_identifier(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#import_path_identifier.
    exitImport_path_identifier(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#constant_declaration.
    enterConstant_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#constant_declaration.
    exitConstant_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#pattern_initializer_list.
    enterPattern_initializer_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#pattern_initializer_list.
    exitPattern_initializer_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#pattern_initializer.
    enterPattern_initializer(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#pattern_initializer.
    exitPattern_initializer(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#initializer.
    enterInitializer(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#initializer.
    exitInitializer(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#variable_declaration.
    enterVariable_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#variable_declaration.
    exitVariable_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#variable_declaration_head.
    enterVariable_declaration_head(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#variable_declaration_head.
    exitVariable_declaration_head(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#variable_name.
    enterVariable_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#variable_name.
    exitVariable_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#getter_setter_block.
    enterGetter_setter_block(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#getter_setter_block.
    exitGetter_setter_block(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#getter_clause.
    enterGetter_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#getter_clause.
    exitGetter_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#setter_clause.
    enterSetter_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#setter_clause.
    exitSetter_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#setter_name.
    enterSetter_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#setter_name.
    exitSetter_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#getter_setter_keyword_block.
    enterGetter_setter_keyword_block(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#getter_setter_keyword_block.
    exitGetter_setter_keyword_block(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#getter_keyword_clause.
    enterGetter_keyword_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#getter_keyword_clause.
    exitGetter_keyword_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#setter_keyword_clause.
    enterSetter_keyword_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#setter_keyword_clause.
    exitSetter_keyword_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#willSet_didSet_block.
    enterWillSet_didSet_block(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#willSet_didSet_block.
    exitWillSet_didSet_block(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#willSet_clause.
    enterWillSet_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#willSet_clause.
    exitWillSet_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#didSet_clause.
    enterDidSet_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#didSet_clause.
    exitDidSet_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#typealias_declaration.
    enterTypealias_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#typealias_declaration.
    exitTypealias_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#typealias_name.
    enterTypealias_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#typealias_name.
    exitTypealias_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#typealias_assignment.
    enterTypealias_assignment(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#typealias_assignment.
    exitTypealias_assignment(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_declaration.
    enterFunction_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_declaration.
    exitFunction_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_head.
    enterFunction_head(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_head.
    exitFunction_head(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_name.
    enterFunction_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_name.
    exitFunction_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_signature.
    enterFunction_signature(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_signature.
    exitFunction_signature(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_result.
    enterFunction_result(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_result.
    exitFunction_result(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_body.
    enterFunction_body(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_body.
    exitFunction_body(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#parameter_clause.
    enterParameter_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#parameter_clause.
    exitParameter_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#parameter_list.
    enterParameter_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#parameter_list.
    exitParameter_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#parameter.
    enterParameter(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#parameter.
    exitParameter(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#external_parameter_name.
    enterExternal_parameter_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#external_parameter_name.
    exitExternal_parameter_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#local_parameter_name.
    enterLocal_parameter_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#local_parameter_name.
    exitLocal_parameter_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#default_argument_clause.
    enterDefault_argument_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#default_argument_clause.
    exitDefault_argument_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#enum_declaration.
    enterEnum_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#enum_declaration.
    exitEnum_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#union_style_enum.
    enterUnion_style_enum(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#union_style_enum.
    exitUnion_style_enum(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#union_style_enum_members.
    enterUnion_style_enum_members(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#union_style_enum_members.
    exitUnion_style_enum_members(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#union_style_enum_member.
    enterUnion_style_enum_member(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#union_style_enum_member.
    exitUnion_style_enum_member(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#union_style_enum_case_clause.
    enterUnion_style_enum_case_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#union_style_enum_case_clause.
    exitUnion_style_enum_case_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#union_style_enum_case_list.
    enterUnion_style_enum_case_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#union_style_enum_case_list.
    exitUnion_style_enum_case_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#union_style_enum_case.
    enterUnion_style_enum_case(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#union_style_enum_case.
    exitUnion_style_enum_case(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#enum_name.
    enterEnum_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#enum_name.
    exitEnum_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#enum_case_name.
    enterEnum_case_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#enum_case_name.
    exitEnum_case_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#raw_value_style_enum.
    enterRaw_value_style_enum(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#raw_value_style_enum.
    exitRaw_value_style_enum(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#raw_value_style_enum_members.
    enterRaw_value_style_enum_members(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#raw_value_style_enum_members.
    exitRaw_value_style_enum_members(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#raw_value_style_enum_member.
    enterRaw_value_style_enum_member(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#raw_value_style_enum_member.
    exitRaw_value_style_enum_member(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#raw_value_style_enum_case_clause.
    enterRaw_value_style_enum_case_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#raw_value_style_enum_case_clause.
    exitRaw_value_style_enum_case_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#raw_value_style_enum_case_list.
    enterRaw_value_style_enum_case_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#raw_value_style_enum_case_list.
    exitRaw_value_style_enum_case_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#raw_value_style_enum_case.
    enterRaw_value_style_enum_case(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#raw_value_style_enum_case.
    exitRaw_value_style_enum_case(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#raw_value_assignment.
    enterRaw_value_assignment(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#raw_value_assignment.
    exitRaw_value_assignment(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#raw_value_literal.
    enterRaw_value_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#raw_value_literal.
    exitRaw_value_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#struct_declaration.
    enterStruct_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#struct_declaration.
    exitStruct_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#struct_name.
    enterStruct_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#struct_name.
    exitStruct_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#struct_body.
    enterStruct_body(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#struct_body.
    exitStruct_body(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#struct_members.
    enterStruct_members(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#struct_members.
    exitStruct_members(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#struct_member.
    enterStruct_member(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#struct_member.
    exitStruct_member(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#class_declaration.
    enterClass_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#class_declaration.
    exitClass_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#class_name.
    enterClass_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#class_name.
    exitClass_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#class_body.
    enterClass_body(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#class_body.
    exitClass_body(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#class_members.
    enterClass_members(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#class_members.
    exitClass_members(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#class_member.
    enterClass_member(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#class_member.
    exitClass_member(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_declaration.
    enterProtocol_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_declaration.
    exitProtocol_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_name.
    enterProtocol_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_name.
    exitProtocol_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_body.
    enterProtocol_body(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_body.
    exitProtocol_body(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_members.
    enterProtocol_members(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_members.
    exitProtocol_members(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_member.
    enterProtocol_member(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_member.
    exitProtocol_member(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_member_declaration.
    enterProtocol_member_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_member_declaration.
    exitProtocol_member_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_property_declaration.
    enterProtocol_property_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_property_declaration.
    exitProtocol_property_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_method_declaration.
    enterProtocol_method_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_method_declaration.
    exitProtocol_method_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_initializer_declaration.
    enterProtocol_initializer_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_initializer_declaration.
    exitProtocol_initializer_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_subscript_declaration.
    enterProtocol_subscript_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_subscript_declaration.
    exitProtocol_subscript_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_associated_type_declaration.
    enterProtocol_associated_type_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_associated_type_declaration.
    exitProtocol_associated_type_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#initializer_declaration.
    enterInitializer_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#initializer_declaration.
    exitInitializer_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#initializer_head.
    enterInitializer_head(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#initializer_head.
    exitInitializer_head(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#initializer_body.
    enterInitializer_body(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#initializer_body.
    exitInitializer_body(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#deinitializer_declaration.
    enterDeinitializer_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#deinitializer_declaration.
    exitDeinitializer_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#extension_declaration.
    enterExtension_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#extension_declaration.
    exitExtension_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#extension_body.
    enterExtension_body(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#extension_body.
    exitExtension_body(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#extension_members.
    enterExtension_members(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#extension_members.
    exitExtension_members(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#extension_member.
    enterExtension_member(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#extension_member.
    exitExtension_member(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#subscript_declaration.
    enterSubscript_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#subscript_declaration.
    exitSubscript_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#subscript_head.
    enterSubscript_head(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#subscript_head.
    exitSubscript_head(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#subscript_result.
    enterSubscript_result(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#subscript_result.
    exitSubscript_result(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#operator_declaration.
    enterOperator_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#operator_declaration.
    exitOperator_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#prefix_operator_declaration.
    enterPrefix_operator_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#prefix_operator_declaration.
    exitPrefix_operator_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#postfix_operator_declaration.
    enterPostfix_operator_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#postfix_operator_declaration.
    exitPostfix_operator_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#infix_operator_declaration.
    enterInfix_operator_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#infix_operator_declaration.
    exitInfix_operator_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#infix_operator_group.
    enterInfix_operator_group(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#infix_operator_group.
    exitInfix_operator_group(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#precedence_group_declaration.
    enterPrecedence_group_declaration(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#precedence_group_declaration.
    exitPrecedence_group_declaration(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#precedence_group_attributes.
    enterPrecedence_group_attributes(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#precedence_group_attributes.
    exitPrecedence_group_attributes(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#precedence_group_attribute.
    enterPrecedence_group_attribute(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#precedence_group_attribute.
    exitPrecedence_group_attribute(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#precedence_group_relation.
    enterPrecedence_group_relation(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#precedence_group_relation.
    exitPrecedence_group_relation(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#precedence_group_assignment.
    enterPrecedence_group_assignment(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#precedence_group_assignment.
    exitPrecedence_group_assignment(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#precedence_group_associativity.
    enterPrecedence_group_associativity(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#precedence_group_associativity.
    exitPrecedence_group_associativity(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#precedence_group_names.
    enterPrecedence_group_names(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#precedence_group_names.
    exitPrecedence_group_names(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#precedence_group_name.
    enterPrecedence_group_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#precedence_group_name.
    exitPrecedence_group_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#declaration_modifier.
    enterDeclaration_modifier(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#declaration_modifier.
    exitDeclaration_modifier(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#declaration_modifiers.
    enterDeclaration_modifiers(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#declaration_modifiers.
    exitDeclaration_modifiers(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#access_level_modifier.
    enterAccess_level_modifier(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#access_level_modifier.
    exitAccess_level_modifier(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#mutation_modifier.
    enterMutation_modifier(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#mutation_modifier.
    exitMutation_modifier(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#pattern.
    enterPattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#pattern.
    exitPattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#wildcard_pattern.
    enterWildcard_pattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#wildcard_pattern.
    exitWildcard_pattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#identifier_pattern.
    enterIdentifier_pattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#identifier_pattern.
    exitIdentifier_pattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#value_binding_pattern.
    enterValue_binding_pattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#value_binding_pattern.
    exitValue_binding_pattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_pattern.
    enterTuple_pattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_pattern.
    exitTuple_pattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_pattern_element_list.
    enterTuple_pattern_element_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_pattern_element_list.
    exitTuple_pattern_element_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_pattern_element.
    enterTuple_pattern_element(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_pattern_element.
    exitTuple_pattern_element(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#enum_case_pattern.
    enterEnum_case_pattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#enum_case_pattern.
    exitEnum_case_pattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#optional_pattern.
    enterOptional_pattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#optional_pattern.
    exitOptional_pattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#expression_pattern.
    enterExpression_pattern(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#expression_pattern.
    exitExpression_pattern(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#attribute.
    enterAttribute(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#attribute.
    exitAttribute(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#attribute_name.
    enterAttribute_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#attribute_name.
    exitAttribute_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#attribute_argument_clause.
    enterAttribute_argument_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#attribute_argument_clause.
    exitAttribute_argument_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#attributes.
    enterAttributes(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#attributes.
    exitAttributes(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#balanced_tokens.
    enterBalanced_tokens(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#balanced_tokens.
    exitBalanced_tokens(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#balanced_token.
    enterBalanced_token(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#balanced_token.
    exitBalanced_token(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#balanced_token_punctuation.
    enterBalanced_token_punctuation(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#balanced_token_punctuation.
    exitBalanced_token_punctuation(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#expression.
    enterExpression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#expression.
    exitExpression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#expression_list.
    enterExpression_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#expression_list.
    exitExpression_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#prefix_expression.
    enterPrefix_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#prefix_expression.
    exitPrefix_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#in_out_expression.
    enterIn_out_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#in_out_expression.
    exitIn_out_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#try_operator.
    enterTry_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#try_operator.
    exitTry_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#binary_expression.
    enterBinary_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#binary_expression.
    exitBinary_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#binary_expressions.
    enterBinary_expressions(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#binary_expressions.
    exitBinary_expressions(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#conditional_operator.
    enterConditional_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#conditional_operator.
    exitConditional_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#type_casting_operator.
    enterType_casting_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#type_casting_operator.
    exitType_casting_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#primary_expression.
    enterPrimary_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#primary_expression.
    exitPrimary_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#unqualified_name.
    enterUnqualified_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#unqualified_name.
    exitUnqualified_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#literal_expression.
    enterLiteral_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#literal_expression.
    exitLiteral_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#array_literal.
    enterArray_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#array_literal.
    exitArray_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#array_literal_items.
    enterArray_literal_items(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#array_literal_items.
    exitArray_literal_items(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#array_literal_item.
    enterArray_literal_item(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#array_literal_item.
    exitArray_literal_item(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#dictionary_literal.
    enterDictionary_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#dictionary_literal.
    exitDictionary_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#dictionary_literal_items.
    enterDictionary_literal_items(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#dictionary_literal_items.
    exitDictionary_literal_items(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#dictionary_literal_item.
    enterDictionary_literal_item(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#dictionary_literal_item.
    exitDictionary_literal_item(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#playground_literal.
    enterPlayground_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#playground_literal.
    exitPlayground_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#self_pure_expression.
    enterSelf_pure_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#self_pure_expression.
    exitSelf_pure_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#self_method_expression.
    enterSelf_method_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#self_method_expression.
    exitSelf_method_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#self_subscript_expression.
    enterSelf_subscript_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#self_subscript_expression.
    exitSelf_subscript_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#self_initializer_expression.
    enterSelf_initializer_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#self_initializer_expression.
    exitSelf_initializer_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#superclass_method_expression.
    enterSuperclass_method_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#superclass_method_expression.
    exitSuperclass_method_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#superclass_subscript_expression.
    enterSuperclass_subscript_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#superclass_subscript_expression.
    exitSuperclass_subscript_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#superclass_initializer_expression.
    enterSuperclass_initializer_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#superclass_initializer_expression.
    exitSuperclass_initializer_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#closure_expression.
    enterClosure_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#closure_expression.
    exitClosure_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#closure_signature.
    enterClosure_signature(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#closure_signature.
    exitClosure_signature(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#closure_parameter_clause.
    enterClosure_parameter_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#closure_parameter_clause.
    exitClosure_parameter_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#closure_parameter_list.
    enterClosure_parameter_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#closure_parameter_list.
    exitClosure_parameter_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#closure_parameter.
    enterClosure_parameter(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#closure_parameter.
    exitClosure_parameter(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#capture_list.
    enterCapture_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#capture_list.
    exitCapture_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#capture_list_items.
    enterCapture_list_items(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#capture_list_items.
    exitCapture_list_items(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#capture_list_item.
    enterCapture_list_item(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#capture_list_item.
    exitCapture_list_item(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#capture_specifier.
    enterCapture_specifier(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#capture_specifier.
    exitCapture_specifier(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#implicit_member_expression.
    enterImplicit_member_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#implicit_member_expression.
    exitImplicit_member_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#parenthesized_operator.
    enterParenthesized_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#parenthesized_operator.
    exitParenthesized_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#parenthesized_expression.
    enterParenthesized_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#parenthesized_expression.
    exitParenthesized_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_expression.
    enterTuple_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_expression.
    exitTuple_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_element_list.
    enterTuple_element_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_element_list.
    exitTuple_element_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_element.
    enterTuple_element(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_element.
    exitTuple_element(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#wildcard_expression.
    enterWildcard_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#wildcard_expression.
    exitWildcard_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#key_path_expression.
    enterKey_path_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#key_path_expression.
    exitKey_path_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#key_path_components.
    enterKey_path_components(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#key_path_components.
    exitKey_path_components(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#key_path_component.
    enterKey_path_component(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#key_path_component.
    exitKey_path_component(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#key_path_postfixes.
    enterKey_path_postfixes(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#key_path_postfixes.
    exitKey_path_postfixes(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#key_path_postfix.
    enterKey_path_postfix(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#key_path_postfix.
    exitKey_path_postfix(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#selector_expression.
    enterSelector_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#selector_expression.
    exitSelector_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#key_path_string_expression.
    enterKey_path_string_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#key_path_string_expression.
    exitKey_path_string_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#postfix_expression.
    enterPostfix_expression(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#postfix_expression.
    exitPostfix_expression(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_call_suffix.
    enterFunction_call_suffix(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_call_suffix.
    exitFunction_call_suffix(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#initializer_suffix.
    enterInitializer_suffix(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#initializer_suffix.
    exitInitializer_suffix(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#explicit_member_suffix.
    enterExplicit_member_suffix(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#explicit_member_suffix.
    exitExplicit_member_suffix(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#postfix_self_suffix.
    enterPostfix_self_suffix(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#postfix_self_suffix.
    exitPostfix_self_suffix(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#subscript_suffix.
    enterSubscript_suffix(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#subscript_suffix.
    exitSubscript_suffix(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#forced_value_suffix.
    enterForced_value_suffix(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#forced_value_suffix.
    exitForced_value_suffix(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#optional_chaining_suffix.
    enterOptional_chaining_suffix(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#optional_chaining_suffix.
    exitOptional_chaining_suffix(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_call_argument_clause.
    enterFunction_call_argument_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_call_argument_clause.
    exitFunction_call_argument_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_call_argument_list.
    enterFunction_call_argument_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_call_argument_list.
    exitFunction_call_argument_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_call_argument.
    enterFunction_call_argument(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_call_argument.
    exitFunction_call_argument(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#trailing_closures.
    enterTrailing_closures(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#trailing_closures.
    exitTrailing_closures(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#labeled_trailing_closures.
    enterLabeled_trailing_closures(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#labeled_trailing_closures.
    exitLabeled_trailing_closures(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#labeled_trailing_closure.
    enterLabeled_trailing_closure(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#labeled_trailing_closure.
    exitLabeled_trailing_closure(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#argument_names.
    enterArgument_names(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#argument_names.
    exitArgument_names(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#argument_name.
    enterArgument_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#argument_name.
    exitArgument_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#type.
    enterType(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#type.
    exitType(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#type_annotation.
    enterType_annotation(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#type_annotation.
    exitType_annotation(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#type_identifier.
    enterType_identifier(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#type_identifier.
    exitType_identifier(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#type_name.
    enterType_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#type_name.
    exitType_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_type.
    enterTuple_type(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_type.
    exitTuple_type(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_type_element_list.
    enterTuple_type_element_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_type_element_list.
    exitTuple_type_element_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#tuple_type_element.
    enterTuple_type_element(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#tuple_type_element.
    exitTuple_type_element(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#element_name.
    enterElement_name(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#element_name.
    exitElement_name(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_type.
    enterFunction_type(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_type.
    exitFunction_type(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_type_argument_clause.
    enterFunction_type_argument_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_type_argument_clause.
    exitFunction_type_argument_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_type_argument_list.
    enterFunction_type_argument_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_type_argument_list.
    exitFunction_type_argument_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#function_type_argument.
    enterFunction_type_argument(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#function_type_argument.
    exitFunction_type_argument(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#argument_label.
    enterArgument_label(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#argument_label.
    exitArgument_label(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#array_type.
    enterArray_type(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#array_type.
    exitArray_type(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#dictionary_type.
    enterDictionary_type(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#dictionary_type.
    exitDictionary_type(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#protocol_composition_type.
    enterProtocol_composition_type(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#protocol_composition_type.
    exitProtocol_composition_type(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#trailing_composition_and.
    enterTrailing_composition_and(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#trailing_composition_and.
    exitTrailing_composition_and(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#opaque_type.
    enterOpaque_type(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#opaque_type.
    exitOpaque_type(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#any_type.
    enterAny_type(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#any_type.
    exitAny_type(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#self_type.
    enterSelf_type(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#self_type.
    exitSelf_type(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#type_inheritance_clause.
    enterType_inheritance_clause(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#type_inheritance_clause.
    exitType_inheritance_clause(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#type_inheritance_list.
    enterType_inheritance_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#type_inheritance_list.
    exitType_inheritance_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#identifier.
    enterIdentifier(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#identifier.
    exitIdentifier(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#identifier_list.
    enterIdentifier_list(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#identifier_list.
    exitIdentifier_list(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#keyword.
    enterKeyword(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#keyword.
    exitKeyword(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#assignment_operator.
    enterAssignment_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#assignment_operator.
    exitAssignment_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#negate_prefix_operator.
    enterNegate_prefix_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#negate_prefix_operator.
    exitNegate_prefix_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#compilation_condition_AND.
    enterCompilation_condition_AND(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#compilation_condition_AND.
    exitCompilation_condition_AND(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#compilation_condition_OR.
    enterCompilation_condition_OR(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#compilation_condition_OR.
    exitCompilation_condition_OR(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#compilation_condition_GE.
    enterCompilation_condition_GE(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#compilation_condition_GE.
    exitCompilation_condition_GE(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#compilation_condition_L.
    enterCompilation_condition_L(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#compilation_condition_L.
    exitCompilation_condition_L(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#arrow_operator.
    enterArrow_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#arrow_operator.
    exitArrow_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#range_operator.
    enterRange_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#range_operator.
    exitRange_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#same_type_equals.
    enterSame_type_equals(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#same_type_equals.
    exitSame_type_equals(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#binary_operator.
    enterBinary_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#binary_operator.
    exitBinary_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#prefix_operator.
    enterPrefix_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#prefix_operator.
    exitPrefix_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#postfix_operator.
    enterPostfix_operator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#postfix_operator.
    exitPostfix_operator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#operator.
    enterOperator(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#operator.
    exitOperator(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#operator_head.
    enterOperator_head(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#operator_head.
    exitOperator_head(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#operator_character.
    enterOperator_character(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#operator_character.
    exitOperator_character(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#operator_characters.
    enterOperator_characters(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#operator_characters.
    exitOperator_characters(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#dot_operator_head.
    enterDot_operator_head(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#dot_operator_head.
    exitDot_operator_head(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#dot_operator_character.
    enterDot_operator_character(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#dot_operator_character.
    exitDot_operator_character(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#dot_operator_characters.
    enterDot_operator_characters(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#dot_operator_characters.
    exitDot_operator_characters(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#literal.
    enterLiteral(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#literal.
    exitLiteral(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#numeric_literal.
    enterNumeric_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#numeric_literal.
    exitNumeric_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#boolean_literal.
    enterBoolean_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#boolean_literal.
    exitBoolean_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#nil_literal.
    enterNil_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#nil_literal.
    exitNil_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#integer_literal.
    enterInteger_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#integer_literal.
    exitInteger_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#string_literal.
    enterString_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#string_literal.
    exitString_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#extended_string_literal.
    enterExtended_string_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#extended_string_literal.
    exitExtended_string_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#static_string_literal.
    enterStatic_string_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#static_string_literal.
    exitStatic_string_literal(ctx) {
    }
    // Enter a parse tree produced by Swift5Parser#interpolated_string_literal.
    enterInterpolated_string_literal(ctx) {
    }
    // Exit a parse tree produced by Swift5Parser#interpolated_string_literal.
    exitInterpolated_string_literal(ctx) {
    }
}
exports["default"] = Swift5ParserListener;
//# sourceMappingURL=Swift5ParserListener.js.map

/***/ }),

/***/ 4310:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Generated from ./assets/swift/Swift5Parser.g4 by ANTLR 4.10.1
// jshint ignore: start
const antlr4_1 = __importDefault(__webpack_require__(7228));
// This class defines a complete generic visitor for a parse tree produced by Swift5Parser.
class Swift5ParserVisitor extends antlr4_1.default.tree.ParseTreeVisitor {
    // Visit a parse tree produced by Swift5Parser#top_level.
    visitTop_level(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#statement.
    visitStatement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#statements.
    visitStatements(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#loop_statement.
    visitLoop_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#for_in_statement.
    visitFor_in_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#while_statement.
    visitWhile_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#condition_list.
    visitCondition_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#condition.
    visitCondition(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#case_condition.
    visitCase_condition(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#optional_binding_condition.
    visitOptional_binding_condition(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#repeat_while_statement.
    visitRepeat_while_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#branch_statement.
    visitBranch_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#if_statement.
    visitIf_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#else_clause.
    visitElse_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#guard_statement.
    visitGuard_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#switch_statement.
    visitSwitch_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#switch_cases.
    visitSwitch_cases(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#switch_case.
    visitSwitch_case(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#case_label.
    visitCase_label(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#case_item_list.
    visitCase_item_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#default_label.
    visitDefault_label(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#where_clause.
    visitWhere_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#where_expression.
    visitWhere_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#conditional_switch_case.
    visitConditional_switch_case(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#switch_if_directive_clause.
    visitSwitch_if_directive_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#switch_elseif_directive_clauses.
    visitSwitch_elseif_directive_clauses(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#switch_elseif_directive_clause.
    visitSwitch_elseif_directive_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#switch_else_directive_clause.
    visitSwitch_else_directive_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#labeled_statement.
    visitLabeled_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#statement_label.
    visitStatement_label(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#label_name.
    visitLabel_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#control_transfer_statement.
    visitControl_transfer_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#break_statement.
    visitBreak_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#continue_statement.
    visitContinue_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#fallthrough_statement.
    visitFallthrough_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#return_statement.
    visitReturn_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#throw_statement.
    visitThrow_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#defer_statement.
    visitDefer_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#do_statement.
    visitDo_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#catch_clauses.
    visitCatch_clauses(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#catch_clause.
    visitCatch_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#catch_pattern_list.
    visitCatch_pattern_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#catch_pattern.
    visitCatch_pattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#compiler_control_statement.
    visitCompiler_control_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#conditional_compilation_block.
    visitConditional_compilation_block(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#if_directive_clause.
    visitIf_directive_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#elseif_directive_clauses.
    visitElseif_directive_clauses(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#elseif_directive_clause.
    visitElseif_directive_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#else_directive_clause.
    visitElse_directive_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#compilation_condition.
    visitCompilation_condition(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#platform_condition.
    visitPlatform_condition(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#swift_version.
    visitSwift_version(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#swift_version_continuation.
    visitSwift_version_continuation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#operating_system.
    visitOperating_system(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#architecture.
    visitArchitecture(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#module_name.
    visitModule_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#environment.
    visitEnvironment(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#line_control_statement.
    visitLine_control_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#line_number.
    visitLine_number(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#file_name.
    visitFile_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#diagnostic_statement.
    visitDiagnostic_statement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#diagnostic_message.
    visitDiagnostic_message(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#availability_condition.
    visitAvailability_condition(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#availability_arguments.
    visitAvailability_arguments(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#availability_argument.
    visitAvailability_argument(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#platform_name.
    visitPlatform_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#platform_version.
    visitPlatform_version(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#generic_parameter_clause.
    visitGeneric_parameter_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#generic_parameter_list.
    visitGeneric_parameter_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#generic_parameter.
    visitGeneric_parameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#generic_where_clause.
    visitGeneric_where_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#requirement_list.
    visitRequirement_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#requirement.
    visitRequirement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#conformance_requirement.
    visitConformance_requirement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#same_type_requirement.
    visitSame_type_requirement(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#generic_argument_clause.
    visitGeneric_argument_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#generic_argument_list.
    visitGeneric_argument_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#generic_argument.
    visitGeneric_argument(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#declaration.
    visitDeclaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#declarations.
    visitDeclarations(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#top_level_declaration.
    visitTop_level_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#code_block.
    visitCode_block(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#import_declaration.
    visitImport_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#import_kind.
    visitImport_kind(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#import_path.
    visitImport_path(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#import_path_identifier.
    visitImport_path_identifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#constant_declaration.
    visitConstant_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#pattern_initializer_list.
    visitPattern_initializer_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#pattern_initializer.
    visitPattern_initializer(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#initializer.
    visitInitializer(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#variable_declaration.
    visitVariable_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#variable_declaration_head.
    visitVariable_declaration_head(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#variable_name.
    visitVariable_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#getter_setter_block.
    visitGetter_setter_block(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#getter_clause.
    visitGetter_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#setter_clause.
    visitSetter_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#setter_name.
    visitSetter_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#getter_setter_keyword_block.
    visitGetter_setter_keyword_block(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#getter_keyword_clause.
    visitGetter_keyword_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#setter_keyword_clause.
    visitSetter_keyword_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#willSet_didSet_block.
    visitWillSet_didSet_block(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#willSet_clause.
    visitWillSet_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#didSet_clause.
    visitDidSet_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#typealias_declaration.
    visitTypealias_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#typealias_name.
    visitTypealias_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#typealias_assignment.
    visitTypealias_assignment(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_declaration.
    visitFunction_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_head.
    visitFunction_head(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_name.
    visitFunction_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_signature.
    visitFunction_signature(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_result.
    visitFunction_result(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_body.
    visitFunction_body(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#parameter_clause.
    visitParameter_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#parameter_list.
    visitParameter_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#parameter.
    visitParameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#external_parameter_name.
    visitExternal_parameter_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#local_parameter_name.
    visitLocal_parameter_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#default_argument_clause.
    visitDefault_argument_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#enum_declaration.
    visitEnum_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#union_style_enum.
    visitUnion_style_enum(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#union_style_enum_members.
    visitUnion_style_enum_members(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#union_style_enum_member.
    visitUnion_style_enum_member(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#union_style_enum_case_clause.
    visitUnion_style_enum_case_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#union_style_enum_case_list.
    visitUnion_style_enum_case_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#union_style_enum_case.
    visitUnion_style_enum_case(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#enum_name.
    visitEnum_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#enum_case_name.
    visitEnum_case_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#raw_value_style_enum.
    visitRaw_value_style_enum(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#raw_value_style_enum_members.
    visitRaw_value_style_enum_members(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#raw_value_style_enum_member.
    visitRaw_value_style_enum_member(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#raw_value_style_enum_case_clause.
    visitRaw_value_style_enum_case_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#raw_value_style_enum_case_list.
    visitRaw_value_style_enum_case_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#raw_value_style_enum_case.
    visitRaw_value_style_enum_case(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#raw_value_assignment.
    visitRaw_value_assignment(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#raw_value_literal.
    visitRaw_value_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#struct_declaration.
    visitStruct_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#struct_name.
    visitStruct_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#struct_body.
    visitStruct_body(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#struct_members.
    visitStruct_members(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#struct_member.
    visitStruct_member(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#class_declaration.
    visitClass_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#class_name.
    visitClass_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#class_body.
    visitClass_body(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#class_members.
    visitClass_members(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#class_member.
    visitClass_member(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_declaration.
    visitProtocol_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_name.
    visitProtocol_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_body.
    visitProtocol_body(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_members.
    visitProtocol_members(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_member.
    visitProtocol_member(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_member_declaration.
    visitProtocol_member_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_property_declaration.
    visitProtocol_property_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_method_declaration.
    visitProtocol_method_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_initializer_declaration.
    visitProtocol_initializer_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_subscript_declaration.
    visitProtocol_subscript_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_associated_type_declaration.
    visitProtocol_associated_type_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#initializer_declaration.
    visitInitializer_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#initializer_head.
    visitInitializer_head(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#initializer_body.
    visitInitializer_body(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#deinitializer_declaration.
    visitDeinitializer_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#extension_declaration.
    visitExtension_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#extension_body.
    visitExtension_body(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#extension_members.
    visitExtension_members(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#extension_member.
    visitExtension_member(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#subscript_declaration.
    visitSubscript_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#subscript_head.
    visitSubscript_head(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#subscript_result.
    visitSubscript_result(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#operator_declaration.
    visitOperator_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#prefix_operator_declaration.
    visitPrefix_operator_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#postfix_operator_declaration.
    visitPostfix_operator_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#infix_operator_declaration.
    visitInfix_operator_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#infix_operator_group.
    visitInfix_operator_group(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#precedence_group_declaration.
    visitPrecedence_group_declaration(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#precedence_group_attributes.
    visitPrecedence_group_attributes(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#precedence_group_attribute.
    visitPrecedence_group_attribute(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#precedence_group_relation.
    visitPrecedence_group_relation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#precedence_group_assignment.
    visitPrecedence_group_assignment(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#precedence_group_associativity.
    visitPrecedence_group_associativity(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#precedence_group_names.
    visitPrecedence_group_names(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#precedence_group_name.
    visitPrecedence_group_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#declaration_modifier.
    visitDeclaration_modifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#declaration_modifiers.
    visitDeclaration_modifiers(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#access_level_modifier.
    visitAccess_level_modifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#mutation_modifier.
    visitMutation_modifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#pattern.
    visitPattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#wildcard_pattern.
    visitWildcard_pattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#identifier_pattern.
    visitIdentifier_pattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#value_binding_pattern.
    visitValue_binding_pattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_pattern.
    visitTuple_pattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_pattern_element_list.
    visitTuple_pattern_element_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_pattern_element.
    visitTuple_pattern_element(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#enum_case_pattern.
    visitEnum_case_pattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#optional_pattern.
    visitOptional_pattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#expression_pattern.
    visitExpression_pattern(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#attribute.
    visitAttribute(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#attribute_name.
    visitAttribute_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#attribute_argument_clause.
    visitAttribute_argument_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#attributes.
    visitAttributes(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#balanced_tokens.
    visitBalanced_tokens(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#balanced_token.
    visitBalanced_token(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#balanced_token_punctuation.
    visitBalanced_token_punctuation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#expression.
    visitExpression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#expression_list.
    visitExpression_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#prefix_expression.
    visitPrefix_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#in_out_expression.
    visitIn_out_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#try_operator.
    visitTry_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#binary_expression.
    visitBinary_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#binary_expressions.
    visitBinary_expressions(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#conditional_operator.
    visitConditional_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#type_casting_operator.
    visitType_casting_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#primary_expression.
    visitPrimary_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#unqualified_name.
    visitUnqualified_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#literal_expression.
    visitLiteral_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#array_literal.
    visitArray_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#array_literal_items.
    visitArray_literal_items(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#array_literal_item.
    visitArray_literal_item(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#dictionary_literal.
    visitDictionary_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#dictionary_literal_items.
    visitDictionary_literal_items(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#dictionary_literal_item.
    visitDictionary_literal_item(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#playground_literal.
    visitPlayground_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#self_pure_expression.
    visitSelf_pure_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#self_method_expression.
    visitSelf_method_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#self_subscript_expression.
    visitSelf_subscript_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#self_initializer_expression.
    visitSelf_initializer_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#superclass_method_expression.
    visitSuperclass_method_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#superclass_subscript_expression.
    visitSuperclass_subscript_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#superclass_initializer_expression.
    visitSuperclass_initializer_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#closure_expression.
    visitClosure_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#closure_signature.
    visitClosure_signature(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#closure_parameter_clause.
    visitClosure_parameter_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#closure_parameter_list.
    visitClosure_parameter_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#closure_parameter.
    visitClosure_parameter(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#capture_list.
    visitCapture_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#capture_list_items.
    visitCapture_list_items(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#capture_list_item.
    visitCapture_list_item(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#capture_specifier.
    visitCapture_specifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#implicit_member_expression.
    visitImplicit_member_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#parenthesized_operator.
    visitParenthesized_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#parenthesized_expression.
    visitParenthesized_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_expression.
    visitTuple_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_element_list.
    visitTuple_element_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_element.
    visitTuple_element(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#wildcard_expression.
    visitWildcard_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#key_path_expression.
    visitKey_path_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#key_path_components.
    visitKey_path_components(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#key_path_component.
    visitKey_path_component(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#key_path_postfixes.
    visitKey_path_postfixes(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#key_path_postfix.
    visitKey_path_postfix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#selector_expression.
    visitSelector_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#key_path_string_expression.
    visitKey_path_string_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#postfix_expression.
    visitPostfix_expression(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_call_suffix.
    visitFunction_call_suffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#initializer_suffix.
    visitInitializer_suffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#explicit_member_suffix.
    visitExplicit_member_suffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#postfix_self_suffix.
    visitPostfix_self_suffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#subscript_suffix.
    visitSubscript_suffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#forced_value_suffix.
    visitForced_value_suffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#optional_chaining_suffix.
    visitOptional_chaining_suffix(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_call_argument_clause.
    visitFunction_call_argument_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_call_argument_list.
    visitFunction_call_argument_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_call_argument.
    visitFunction_call_argument(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#trailing_closures.
    visitTrailing_closures(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#labeled_trailing_closures.
    visitLabeled_trailing_closures(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#labeled_trailing_closure.
    visitLabeled_trailing_closure(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#argument_names.
    visitArgument_names(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#argument_name.
    visitArgument_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#type.
    visitType(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#type_annotation.
    visitType_annotation(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#type_identifier.
    visitType_identifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#type_name.
    visitType_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_type.
    visitTuple_type(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_type_element_list.
    visitTuple_type_element_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#tuple_type_element.
    visitTuple_type_element(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#element_name.
    visitElement_name(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_type.
    visitFunction_type(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_type_argument_clause.
    visitFunction_type_argument_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_type_argument_list.
    visitFunction_type_argument_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#function_type_argument.
    visitFunction_type_argument(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#argument_label.
    visitArgument_label(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#array_type.
    visitArray_type(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#dictionary_type.
    visitDictionary_type(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#protocol_composition_type.
    visitProtocol_composition_type(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#trailing_composition_and.
    visitTrailing_composition_and(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#opaque_type.
    visitOpaque_type(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#any_type.
    visitAny_type(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#self_type.
    visitSelf_type(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#type_inheritance_clause.
    visitType_inheritance_clause(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#type_inheritance_list.
    visitType_inheritance_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#identifier.
    visitIdentifier(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#identifier_list.
    visitIdentifier_list(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#keyword.
    visitKeyword(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#assignment_operator.
    visitAssignment_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#negate_prefix_operator.
    visitNegate_prefix_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#compilation_condition_AND.
    visitCompilation_condition_AND(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#compilation_condition_OR.
    visitCompilation_condition_OR(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#compilation_condition_GE.
    visitCompilation_condition_GE(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#compilation_condition_L.
    visitCompilation_condition_L(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#arrow_operator.
    visitArrow_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#range_operator.
    visitRange_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#same_type_equals.
    visitSame_type_equals(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#binary_operator.
    visitBinary_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#prefix_operator.
    visitPrefix_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#postfix_operator.
    visitPostfix_operator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#operator.
    visitOperator(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#operator_head.
    visitOperator_head(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#operator_character.
    visitOperator_character(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#operator_characters.
    visitOperator_characters(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#dot_operator_head.
    visitDot_operator_head(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#dot_operator_character.
    visitDot_operator_character(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#dot_operator_characters.
    visitDot_operator_characters(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#literal.
    visitLiteral(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#numeric_literal.
    visitNumeric_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#boolean_literal.
    visitBoolean_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#nil_literal.
    visitNil_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#integer_literal.
    visitInteger_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#string_literal.
    visitString_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#extended_string_literal.
    visitExtended_string_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#static_string_literal.
    visitStatic_string_literal(ctx) {
        return this.visitChildren(ctx);
    }
    // Visit a parse tree produced by Swift5Parser#interpolated_string_literal.
    visitInterpolated_string_literal(ctx) {
        return this.visitChildren(ctx);
    }
}
exports["default"] = Swift5ParserVisitor;
//# sourceMappingURL=Swift5ParserVisitor.js.map

/***/ }),

/***/ 4667:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Swift5Lexer_1 = __importDefault(__webpack_require__(5401));
const BitSet_1 = __webpack_require__(1936);
const Swift5ParserCompat_1 = __webpack_require__(2434);
const Token_1 = __importDefault(__webpack_require__(5319));
const Interval_1 = __importDefault(__webpack_require__(4886));
class SwiftSupport {
    /* TODO
    There is one caveat to the rules above. If the ! or ? predefined operator
     has no whitespace on the left, it is treated as a postfix operator,
     regardless of whether it has whitespace on the right. To use the ? as
     the optional-chaining operator, it must not have whitespace on the left.
      To use it in the ternary conditional (? :) operator, it must have
      whitespace around both sides.
    */
    /*
    operator-head : /  =  -  +  !  *  %  <  >  &  |  ^  ~  ?
      | [\u00A1-\u00A7]
      | [\u00A9\u00AB]
      | [\u00AC\u00AE]
      | [\u00B0-\u00B1\u00B6\u00BB\u00BF\u00D7\u00F7]
      | [\u2016-\u2017\u2020-\u2027]
      | [\u2030-\u203E]
      | [\u2041-\u2053]
      | [\u2055-\u205E]
      | [\u2190-\u23FF]
      | [\u2500-\u2775]
      | [\u2794-\u2BFF]
      | [\u2E00-\u2E7F]
      | [\u3001-\u3003]
      | [\u3008-\u3030]
      ;
     */
    static operatorHead = new BitSet_1.BitSet(0x10000);
    static operatorCharacter;
    static leftWS = new BitSet_1.BitSet(255);
    static rightWS = new BitSet_1.BitSet(255);
    static initialize() {
        // operator-head → /  =­  -­  +­  !­  *­  %­  <­  >­  &­  |­  ^­  ~­  ?­
        this.operatorHead.set('/'.charCodeAt(0));
        this.operatorHead.set('='.charCodeAt(0));
        this.operatorHead.set('-'.charCodeAt(0));
        this.operatorHead.set('+'.charCodeAt(0));
        this.operatorHead.set('!'.charCodeAt(0));
        this.operatorHead.set('*'.charCodeAt(0));
        this.operatorHead.set('%'.charCodeAt(0));
        this.operatorHead.set('&'.charCodeAt(0));
        this.operatorHead.set('|'.charCodeAt(0));
        this.operatorHead.set('<'.charCodeAt(0));
        this.operatorHead.set('>'.charCodeAt(0));
        this.operatorHead.set('^'.charCodeAt(0));
        this.operatorHead.set('~'.charCodeAt(0));
        this.operatorHead.set('?'.charCodeAt(0));
        // operator-head → U+00A1–U+00A7
        this.operatorHead.set(0x00A1, 0x00A7 + 1);
        // operator-head → U+00A9 or U+00AB
        this.operatorHead.set(0x00A9);
        this.operatorHead.set(0x00AB);
        // operator-head → U+00AC or U+00AE
        this.operatorHead.set(0x00AC);
        this.operatorHead.set(0x00AE);
        // operator-head → U+00B0–U+00B1, U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7
        this.operatorHead.set(0x00B0, 0x00B1 + 1);
        this.operatorHead.set(0x00B6);
        this.operatorHead.set(0x00BB);
        this.operatorHead.set(0x00BF);
        this.operatorHead.set(0x00D7);
        this.operatorHead.set(0x00F7);
        // operator-head → U+2016–U+2017 or U+2020–U+2027
        this.operatorHead.set(0x2016, 0x2017 + 1);
        this.operatorHead.set(0x2020, 0x2027 + 1);
        // operator-head → U+2030–U+203E
        this.operatorHead.set(0x2030, 0x203E + 1);
        // operator-head → U+2041–U+2053
        this.operatorHead.set(0x2041, 0x2053 + 1);
        // operator-head → U+2055–U+205E
        this.operatorHead.set(0x2055, 0x205E + 1);
        // operator-head → U+2190–U+23FF
        this.operatorHead.set(0x2190, 0x23FF + 1);
        // operator-head → U+2500–U+2775
        this.operatorHead.set(0x2500, 0x2775 + 1);
        // operator-head → U+2794–U+2BFF
        this.operatorHead.set(0x2794, 0x2BFF + 1);
        // operator-head → U+2E00–U+2E7F
        this.operatorHead.set(0x2E00, 0x2E7F + 1);
        // operator-head → U+3001–U+3003
        this.operatorHead.set(0x3001, 0x3003 + 1);
        // operator-head → U+3008–U+3030
        this.operatorHead.set(0x3008, 0x3020 + 1);
        this.operatorHead.set(0x3030);
        // operator-character → operator-head­
        this.operatorCharacter = this.operatorHead.clone();
        // operator-character → U+0300–U+036F
        this.operatorCharacter.set(0x0300, 0x036F + 1);
        // operator-character → U+1DC0–U+1DFF
        this.operatorCharacter.set(0x1DC0, 0x1DFF + 1);
        // operator-character → U+20D0–U+20FF
        this.operatorCharacter.set(0x20D0, 0x20FF + 1);
        // operator-character → U+FE00–U+FE0F
        this.operatorCharacter.set(0xFE00, 0xFE0F + 1);
        // operator-character → U+FE20–U+FE2F
        this.operatorCharacter.set(0xFE20, 0xFE2F + 1);
        this.operatorCharacter.set(0xE0100, 0xE01EF + 1);
        // operator-character → U+E0100–U+E01EF
        // Java works with 16-bit unicode chars. However, it can work for targets in other languages, e.g. in Swift
        // operatorCharacter.set(0xE0100,0xE01EF+1);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.WS);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.LPAREN);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.Interpolataion_multi_line);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.Interpolataion_single_line);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.LBRACK);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.LCURLY);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.COMMA);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.COLON);
        this.leftWS.set(Swift5ParserCompat_1.Swift5ParserCompat.SEMI);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.WS);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.RPAREN);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.RBRACK);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.RCURLY);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.COMMA);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.COLON);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.SEMI);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.Line_comment);
        this.rightWS.set(Swift5ParserCompat_1.Swift5ParserCompat.Block_comment);
    }
    static isCharacterFromSet(token, bitSet) {
        if (token.type == Token_1.default.EOF) {
            return false;
        }
        else {
            const text = token.text;
            const codepoint = text.codePointAt(0);
            const charCount = codepoint >= 0x10000 ? 2 : 1; // Character.charCount(codepoint)
            if (charCount != text.length) {
                // not a single character
                return false;
            }
            else {
                return bitSet.get(codepoint);
            }
        }
    }
    static isOperatorHead(token) {
        return this.isCharacterFromSet(token, this.operatorHead);
    }
    static isOperatorCharacter(token) {
        return this.isCharacterFromSet(token, this.operatorCharacter);
    }
    static isOpNext(tokens) {
        const start = tokens.index;
        const lt = tokens.get(start);
        const stop = this.getLastOpTokenIndex(tokens);
        return stop !== -1;
    }
    /**
     * Find stop token index of next operator; return -1 if not operator.
     */
    static getLastOpTokenIndex(tokens) {
        let currentTokenIndex = tokens.index; // current on-channel lookahead token index
        let currentToken = tokens.get(currentTokenIndex);
        tokens.getText(undefined); // Ensures that tokens can be read
        // operator → dot-operator-head­ dot-operator-characters
        if (currentToken.type == Swift5ParserCompat_1.Swift5ParserCompat.DOT && tokens.get(currentTokenIndex + 1).type == Swift5ParserCompat_1.Swift5ParserCompat.DOT) {
            // dot-operator
            currentTokenIndex += 2; // point at token after ".."
            currentToken = tokens.get(currentTokenIndex);
            // dot-operator-character → .­ | operator-character­
            while (currentToken.type == Swift5ParserCompat_1.Swift5ParserCompat.DOT || this.isOperatorCharacter(currentToken)) {
                currentTokenIndex++;
                currentToken = tokens.get(currentTokenIndex);
            }
            return currentTokenIndex - 1;
        }
        // operator → operator-head­ operator-characters­?
        if (this.isOperatorHead(currentToken)) {
            currentToken = tokens.get(currentTokenIndex);
            while (this.isOperatorCharacter(currentToken)) {
                currentTokenIndex++;
                currentToken = tokens.get(currentTokenIndex);
            }
            return currentTokenIndex - 1;
        }
        else {
            return -1;
        }
    }
    /**
     * "If an operator has whitespace around both sides or around neither side,
     * it is treated as a binary operator. As an example, the + operator in a+b
     * and a + b is treated as a binary operator."
     */
    static isBinaryOp(tokens) {
        const stop = this.getLastOpTokenIndex(tokens);
        if (stop == -1)
            return false;
        const start = tokens.index;
        const currentToken = tokens.get(start);
        const prevToken = tokens.get(start - 1); // includes hidden-channel tokens
        const nextToken = tokens.get(stop + 1);
        const prevIsWS = this.isLeftOperatorWS(prevToken);
        const nextIsWS = this.isRightOperatorWS(nextToken);
        if (prevIsWS) {
            return nextIsWS;
        }
        else {
            if (currentToken.type == Swift5Lexer_1.default.BANG || currentToken.type == Swift5Lexer_1.default.QUESTION) {
                return false;
            }
            else {
                if (!nextIsWS)
                    return nextToken.type != Swift5Lexer_1.default.DOT;
            }
        }
        return false;
    }
    /**
     * "If an operator has whitespace on the left side only, it is treated as a
     * prefix unary operator. As an example, the ++ operator in a ++b is treated
     * as a prefix unary operator."
     */
    static isPrefixOp(tokens) {
        const stop = this.getLastOpTokenIndex(tokens);
        if (stop == -1)
            return false;
        const start = tokens.index;
        const prevToken = tokens.get(start - 1); // includes hidden-channel tokens
        const nextToken = tokens.get(stop + 1);
        const prevIsWS = this.isLeftOperatorWS(prevToken);
        const nextIsWS = this.isRightOperatorWS(nextToken);
        return prevIsWS && !nextIsWS;
    }
    /**
     * "If an operator has whitespace on the right side only, it is treated as a
     * postfix unary operator. As an example, the ++ operator in a++ b is treated
     * as a postfix unary operator."
     * <p>
     * "If an operator has no whitespace on the left but is followed immediately
     * by a dot (.), it is treated as a postfix unary operator. As an example,
     * the ++ operator in a++.b is treated as a postfix unary operator (a++ .b
     * rather than a ++ .b)."
     */
    static isPostfixOp(tokens) {
        const stop = this.getLastOpTokenIndex(tokens);
        if (stop == -1)
            return false;
        const start = tokens.index;
        const prevToken = tokens.get(start - 1); // includes hidden-channel tokens
        const nextToken = tokens.get(stop + 1);
        const prevIsWS = this.isLeftOperatorWS(prevToken);
        const nextIsWS = this.isRightOperatorWS(nextToken);
        return !prevIsWS && nextIsWS ||
            !prevIsWS && nextToken.type == Swift5ParserCompat_1.Swift5ParserCompat.DOT;
    }
    static isOperator(tokens, op) {
        const stop = this.getLastOpTokenIndex(tokens);
        if (stop == -1)
            return false;
        const start = tokens.index;
        const text = tokens.getText(new Interval_1.default(start, stop));
        return text === op;
    }
    static isLeftOperatorWS(t) {
        return this.leftWS.get(t.type);
    }
    static isRightOperatorWS(t) {
        return this.rightWS.get(t.type) || t.type == Token_1.default.EOF;
    }
    static isSeparatedStatement(tokens, indexOfPreviousStatement) {
        let indexFrom = indexOfPreviousStatement - 1;
        const indexTo = tokens.index - 1;
        if (indexFrom >= 0) {
            // Stupid check for new line and semicolon, can be optimized
            while (indexFrom >= 0 && tokens.get(indexFrom).getChannel == Token_1.default.HIDDEN_CHANNEL) {
                indexFrom--;
            }
            for (let i = indexTo; i >= indexFrom; i--) {
                const t = tokens.get(i).text;
                if (t.includes("\n") || t.includes(";")) {
                    return true;
                }
            }
            return false;
        }
        else {
            return true;
        }
    }
}
exports["default"] = SwiftSupport;
SwiftSupport.initialize();
//# sourceMappingURL=SwiftSupport.js.map

/***/ }),

/***/ 1936:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BitSet = void 0;
// import * as util from "util";
const MurmurHash_1 = __webpack_require__(253);
/**
 * Private empty array used to construct empty BitSets
 */
const EMPTY_DATA = new Uint16Array(0);
/**
 * Gets the word index of the `UInt16` element in `BitSet.data` containing the bit with the specified index.
 */
function getIndex(bitNumber) {
    return bitNumber >>> 4;
}
/**
 * Convert a word index into the bit index of the LSB of that word
 */
function unIndex(n) {
    return n * 16;
}
/**
 * Get's the bit number of the least signficant bit set LSB which is set in a word non-zero word;
 * Bit numbers run from LSB to MSB starting with 0.
 */
function findLSBSet(word) {
    let bit = 1;
    for (let i = 0; i < 16; i++) {
        if ((word & bit) !== 0) {
            return i;
        }
        bit = (bit << 1) >>> 0;
    }
    throw new RangeError("No specified bit found");
}
function findMSBSet(word) {
    let bit = (1 << 15) >>> 0;
    for (let i = 15; i >= 0; i--) {
        if ((word & bit) !== 0) {
            return i;
        }
        bit = bit >>> 1;
    }
    throw new RangeError("No specified bit found");
}
/**
 * Gets a 16-bit mask with bit numbers fromBit to toBit (inclusive) set.
 * Bit numbers run from LSB to MSB starting with 0.
 */
function bitsFor(fromBit, toBit) {
    fromBit &= 0xF;
    toBit &= 0xF;
    if (fromBit === toBit) {
        return (1 << fromBit) >>> 0;
    }
    return ((0xFFFF >>> (15 - toBit)) ^ (0xFFFF >>> (16 - fromBit)));
}
/**
 * A lookup table for number of set bits in a 16-bit integer.   This is used to quickly count the cardinality (number of unique elements) of a BitSet.
 */
const POP_CNT = new Uint8Array(65536);
for (let i = 0; i < 16; i++) {
    const stride = (1 << i) >>> 0;
    let index = 0;
    while (index < POP_CNT.length) {
        // skip the numbers where the bit isn't set
        index += stride;
        // increment the ones where the bit is set
        for (let j = 0; j < stride; j++) {
            POP_CNT[index]++;
            index++;
        }
    }
}
class BitSet {
    data;
    /*
    ** constructor implementation
    */
    constructor(arg) {
        if (!arg) {
            // covering the case of unspecified and nbits===0
            this.data = EMPTY_DATA;
        }
        else if (typeof arg === "number") {
            if (arg < 0) {
                throw new RangeError("nbits cannot be negative");
            }
            else {
                this.data = new Uint16Array(getIndex(arg - 1) + 1);
            }
        }
        else {
            if (arg instanceof BitSet) {
                this.data = arg.data.slice(0); // Clone the data
            }
            else {
                let max = -1;
                for (let v of arg) {
                    if (max < v) {
                        max = v;
                    }
                }
                this.data = new Uint16Array(getIndex(max - 1) + 1);
                for (let v of arg) {
                    this.set(v);
                }
            }
        }
    }
    /**
     * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that
     * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding
     * bit in the bit set argument also had the value `true`.
     */
    and(set) {
        const data = this.data;
        const other = set.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1; // Keep track of index of last non-zero word
        for (let i = 0; i < words; i++) {
            let value = data[i] &= other[i];
            if (value !== 0) {
                lastWord = i;
            }
        }
        if (lastWord === -1) {
            this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
            this.data = data.slice(0, lastWord + 1);
        }
    }
    /**
     * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.
     */
    andNot(set) {
        const data = this.data;
        const other = set.data;
        const words = Math.min(data.length, other.length);
        let lastWord = -1; // Keep track of index of last non-zero word
        for (let i = 0; i < words; i++) {
            let value = data[i] &= (other[i] ^ 0xFFFF);
            if (value !== 0) {
                lastWord = i;
            }
        }
        if (lastWord === -1) {
            this.data = EMPTY_DATA;
        }
        if (lastWord < data.length - 1) {
            this.data = data.slice(0, lastWord + 1);
        }
    }
    /**
     * Returns the number of bits set to `true` in this `BitSet`.
     */
    cardinality() {
        if (this.isEmpty) {
            return 0;
        }
        const data = this.data;
        const length = data.length;
        let result = 0;
        for (let i = 0; i < length; i++) {
            result += POP_CNT[data[i]];
        }
        return result;
    }
    clear(fromIndex, toIndex) {
        if (fromIndex == null) {
            this.data.fill(0);
        }
        else if (toIndex == null) {
            this.set(fromIndex, false);
        }
        else {
            this.set(fromIndex, toIndex, false);
        }
    }
    flip(fromIndex, toIndex) {
        if (toIndex == null) {
            toIndex = fromIndex;
        }
        if (fromIndex < 0 || toIndex < fromIndex) {
            throw new RangeError();
        }
        let word = getIndex(fromIndex);
        const lastWord = getIndex(toIndex);
        if (word === lastWord) {
            this.data[word] ^= bitsFor(fromIndex, toIndex);
        }
        else {
            this.data[word++] ^= bitsFor(fromIndex, 15);
            while (word < lastWord) {
                this.data[word++] ^= 0xFFFF;
            }
            this.data[word++] ^= bitsFor(0, toIndex);
        }
    }
    get(fromIndex, toIndex) {
        if (toIndex === undefined) {
            return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));
        }
        else {
            // return a BitSet
            let result = new BitSet(toIndex + 1);
            for (let i = fromIndex; i <= toIndex; i++) {
                result.set(i, this.get(i));
            }
            return result;
        }
    }
    /**
     * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.
     *
     * @param set `BitSet` to intersect with
     */
    intersects(set) {
        let smallerLength = Math.min(this.length(), set.length());
        if (smallerLength === 0) {
            return false;
        }
        let bound = getIndex(smallerLength - 1);
        for (let i = 0; i <= bound; i++) {
            if ((this.data[i] & set.data[i]) !== 0) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns true if this `BitSet` contains no bits that are set to `true`.
     */
    get isEmpty() {
        return this.length() === 0;
    }
    /**
     * Returns the "logical size" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns
     * zero if the `BitSet` contains no set bits.
     */
    length() {
        if (!this.data.length) {
            return 0;
        }
        return this.previousSetBit(unIndex(this.data.length) - 1) + 1;
    }
    /**
     * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,
     * If no such bit exists then `-1` is returned.
     *
     * @param fromIndex the index to start checking from (inclusive)
     *
     * @throws RangeError if the specified index is negative
     */
    nextClearBit(fromIndex) {
        if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
            return -1;
        }
        let ignore = 0xFFFF ^ bitsFor(fromIndex, 15);
        if ((data[word] | ignore) === 0xFFFF) {
            word++;
            ignore = 0;
            for (; word < length; word++) {
                if (data[word] !== 0xFFFF) {
                    break;
                }
            }
            if (word === length) {
                // Hit the end
                return -1;
            }
        }
        return unIndex(word) + findLSBSet((data[word] | ignore) ^ 0xFFFF);
    }
    /**
     * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.
     * If no such bit exists then `-1` is returned.
     *
     * To iterate over the `true` bits in a `BitSet`, use the following loop:
     *
     * ```
     * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
     *   // operate on index i here
     * }
     * ```
     *
     * @param fromIndex the index to start checking from (inclusive)
     *
     * @throws RangeError if the specified index is negative
     */
    nextSetBit(fromIndex) {
        if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word > length) {
            return -1;
        }
        let mask = bitsFor(fromIndex, 15);
        if ((data[word] & mask) === 0) {
            word++;
            mask = 0xFFFF;
            for (; word < length; word++) {
                if (data[word] !== 0) {
                    break;
                }
            }
            if (word >= length) {
                return -1;
            }
        }
        return unIndex(word) + findLSBSet(data[word] & mask);
    }
    /**
     * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it
     * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit
     * set argument has the value `true`.
     */
    or(set) {
        const data = this.data;
        const other = set.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        // Or those words both sets have in common
        for (let i = 0; i < minWords; i++) {
            let value = dest[i] = data[i] | other[i];
            if (value !== 0) {
                lastWord = i;
            }
        }
        // Copy words from larger set (if there is one)
        const longer = data.length > other.length ? data : other;
        for (let i = minWords; i < words; i++) {
            let value = dest[i] = longer[i];
            if (value !== 0) {
                lastWord = i;
            }
        }
        if (lastWord === -1) {
            this.data = EMPTY_DATA;
        }
        else if (dest.length === lastWord + 1) {
            this.data = dest;
        }
        else {
            this.data = dest.slice(0, lastWord);
        }
    }
    /**
     * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting
     * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
     *
     * @param fromIndex the index to start checking from (inclusive)
     *
     * @throws RangeError if the specified index is less than `-1`
     */
    previousClearBit(fromIndex) {
        if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
            word = length - 1;
        }
        let ignore = 0xFFFF ^ bitsFor(0, fromIndex);
        if ((data[word] | ignore) === 0xFFFF) {
            ignore = 0;
            word--;
            for (; word >= 0; word--) {
                if (data[word] !== 0xFFFF) {
                    break;
                }
            }
            if (word < 0) {
                // Hit the end
                return -1;
            }
        }
        return unIndex(word) + findMSBSet((data[word] | ignore) ^ 0xFFFF);
    }
    /**
     * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.
     * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.
     *
     * To iterate over the `true` bits in a `BitSet`, use the following loop:
     *
     * ```
     * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {
     *   // operate on index i here
     * }
     * ```
     *
     * @param fromIndex the index to start checking from (inclusive)
     *
     * @throws RangeError if the specified index is less than `-1`
     */
    previousSetBit(fromIndex) {
        if (fromIndex < 0) {
            throw new RangeError("fromIndex cannot be negative");
        }
        const data = this.data;
        const length = data.length;
        let word = getIndex(fromIndex);
        if (word >= length) {
            word = length - 1;
        }
        let mask = bitsFor(0, fromIndex);
        if ((data[word] & mask) === 0) {
            word--;
            mask = 0xFFFF;
            for (; word >= 0; word--) {
                if (data[word] !== 0) {
                    break;
                }
            }
            if (word < 0) {
                return -1;
            }
        }
        return unIndex(word) + findMSBSet(data[word] & mask);
    }
    set(fromIndex, toIndex, value) {
        if (toIndex === undefined) {
            toIndex = fromIndex;
            value = true;
        }
        else if (typeof toIndex === "boolean") {
            value = toIndex;
            toIndex = fromIndex;
        }
        if (value === undefined) {
            value = true;
        }
        if (fromIndex < 0 || fromIndex > toIndex) {
            throw new RangeError();
        }
        let word = getIndex(fromIndex);
        let lastWord = getIndex(toIndex);
        if (value && lastWord >= this.data.length) {
            // Grow array "just enough" for bits we need to set
            let temp = new Uint16Array(lastWord + 1);
            this.data.forEach((value, index) => temp[index] = value);
            this.data = temp;
        }
        else if (!value) {
            // But there is no need to grow array to clear bits.
            if (word >= this.data.length) {
                // Early exit
                return;
            }
            if (lastWord >= this.data.length) {
                // Adjust work to fit array
                lastWord = this.data.length - 1;
                toIndex = this.data.length * 16 - 1;
            }
        }
        if (word === lastWord) {
            this._setBits(word, value, bitsFor(fromIndex, toIndex));
        }
        else {
            this._setBits(word++, value, bitsFor(fromIndex, 15));
            while (word < lastWord) {
                this.data[word++] = value ? 0xFFFF : 0;
            }
            this._setBits(word, value, bitsFor(0, toIndex));
        }
    }
    _setBits(word, value, mask) {
        if (value) {
            this.data[word] |= mask;
        }
        else {
            this.data[word] &= 0xFFFF ^ mask;
        }
    }
    /**
     * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element
     * in the set is the size - 1st element.
     */
    get size() {
        return this.data.byteLength * 8;
    }
    /**
     * Returns a new byte array containing all the bits in this bit set.
     *
     * More precisely, if
     * `let bytes = s.toByteArray();`
     * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all
     * `n < 8 * bytes.length`.
     */
    // toByteArray(): Int8Array {
    // 	throw new Error("NOT IMPLEMENTED");
    // }
    /**
     * Returns a new integer array containing all the bits in this bit set.
     *
     * More precisely, if
     * `let integers = s.toIntegerArray();`
     * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all
     * `n < 32 * integers.length`.
     */
    // toIntegerArray(): Int32Array {
    // 	throw new Error("NOT IMPLEMENTED");
    // }
    hashCode() {
        return MurmurHash_1.MurmurHash.hashCode(this.data, 22);
    }
    /**
     * Compares this object against the specified object. The result is `true` if and only if the argument is not
     * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That
     * is, for every nonnegative index `k`,
     *
     * ```
     * ((BitSet)obj).get(k) == this.get(k)
     * ```
     *
     * must be true. The current sizes of the two bit sets are not compared.
     */
    equals(obj) {
        if (obj === this) {
            return true;
        }
        else if (!(obj instanceof BitSet)) {
            return false;
        }
        const len = this.length();
        if (len !== obj.length()) {
            return false;
        }
        if (len === 0) {
            return true;
        }
        let bound = getIndex(len - 1);
        for (let i = 0; i <= bound; i++) {
            if (this.data[i] !== obj.data[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the
     * set state, the decimal representation of that index is included in the result. Such indices are listed in order
     * from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual
     * mathematical notation for a set of integers.
     *
     * Example:
     *
     *     BitSet drPepper = new BitSet();
     *
     * Now `drPepper.toString()` returns `"{}"`.
     *
     *     drPepper.set(2);
     *
     * Now `drPepper.toString()` returns `"{2}"`.
     *
     *     drPepper.set(4);
     *     drPepper.set(10);
     *
     * Now `drPepper.toString()` returns `"{2, 4, 10}"`.
     */
    toString() {
        let result = "{";
        let first = true;
        for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {
            if (first) {
                first = false;
            }
            else {
                result += ", ";
            }
            result += i;
        }
        result += "}";
        return result;
    }
    // static valueOf(bytes: Int8Array): BitSet;
    // static valueOf(buffer: ArrayBuffer): BitSet;
    // static valueOf(integers: Int32Array): BitSet;
    // static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {
    // 	throw new Error("NOT IMPLEMENTED");
    // }
    /**
     * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in
     * it has the value `true` if and only if one of the following statements holds:
     *
     * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.
     * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.
     */
    xor(set) {
        const data = this.data;
        const other = set.data;
        const minWords = Math.min(data.length, other.length);
        const words = Math.max(data.length, other.length);
        const dest = data.length === words ? data : new Uint16Array(words);
        let lastWord = -1;
        // Xor those words both sets have in common
        for (let i = 0; i < minWords; i++) {
            let value = dest[i] = data[i] ^ other[i];
            if (value !== 0) {
                lastWord = i;
            }
        }
        // Copy words from larger set (if there is one)
        const longer = data.length > other.length ? data : other;
        for (let i = minWords; i < words; i++) {
            let value = dest[i] = longer[i];
            if (value !== 0) {
                lastWord = i;
            }
        }
        if (lastWord === -1) {
            this.data = EMPTY_DATA;
        }
        else if (dest.length === lastWord + 1) {
            this.data = dest;
        }
        else {
            this.data = dest.slice(0, lastWord + 1);
        }
    }
    clone() {
        return new BitSet(this);
    }
    [Symbol.iterator]() {
        return new BitSetIterator(this.data);
    }
}
exports.BitSet = BitSet;
class BitSetIterator {
    data;
    index = 0;
    mask = 0xFFFF;
    constructor(data) {
        this.data = data;
    }
    next() {
        while (this.index < this.data.length) {
            const bits = this.data[this.index] & this.mask;
            if (bits !== 0) {
                const bitNumber = unIndex(this.index) + findLSBSet(bits);
                this.mask = bitsFor(bitNumber + 1, 15);
                return { done: false, value: bitNumber };
            }
            this.index++;
            this.mask = 0xFFFF;
        }
        return { done: true, value: -1 };
    }
    [Symbol.iterator]() { return this; }
}
//# sourceMappingURL=BitSet.js.map

/***/ }),

/***/ 253:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/*!
 * Copyright 2016 The ANTLR Project. All rights reserved.
 * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MurmurHash = void 0;
/**
 *
 * @author Sam Harwell
 */
var MurmurHash;
(function (MurmurHash) {
    const DEFAULT_SEED = 0;
    /**
     * Initialize the hash using the specified `seed`.
     *
     * @param seed the seed (optional)
     * @returns the intermediate hash value
     */
    function initialize(seed = DEFAULT_SEED) {
        return seed;
    }
    MurmurHash.initialize = initialize;
    /**
     * Update the intermediate hash value for the next input `value`.
     *
     * @param hash the intermediate hash value
     * @param value the value to add to the current hash
     * @returns the updated intermediate hash value
     */
    function update(hash, value) {
        const c1 = 0xCC9E2D51;
        const c2 = 0x1B873593;
        const r1 = 15;
        const r2 = 13;
        const m = 5;
        const n = 0xE6546B64;
        if (value == null) {
            value = 0;
        }
        else if (typeof value === "string") {
            value = hashString(value);
        }
        else if (typeof value === "object") {
            value = value.hashCode();
        }
        let k = value;
        k = Math.imul(k, c1);
        k = (k << r1) | (k >>> (32 - r1));
        k = Math.imul(k, c2);
        hash = hash ^ k;
        hash = (hash << r2) | (hash >>> (32 - r2));
        hash = Math.imul(hash, m) + n;
        return hash & 0xFFFFFFFF;
    }
    MurmurHash.update = update;
    /**
     * Apply the final computation steps to the intermediate value `hash`
     * to form the final result of the MurmurHash 3 hash function.
     *
     * @param hash the intermediate hash value
     * @param numberOfWords the number of integer values added to the hash
     * @returns the final hash result
     */
    function finish(hash, numberOfWords) {
        hash = hash ^ (numberOfWords * 4);
        hash = hash ^ (hash >>> 16);
        hash = Math.imul(hash, 0x85EBCA6B);
        hash = hash ^ (hash >>> 13);
        hash = Math.imul(hash, 0xC2B2AE35);
        hash = hash ^ (hash >>> 16);
        return hash;
    }
    MurmurHash.finish = finish;
    /**
     * Utility function to compute the hash code of an array using the
     * MurmurHash algorithm.
     *
     * @param <T> the array element type
     * @param data the array data
     * @param seed the seed for the MurmurHash algorithm
     * @returns the hash code of the data
     */
    function hashCode(data, seed = DEFAULT_SEED) {
        let hash = initialize(seed);
        let length = 0;
        for (let value of data) {
            hash = update(hash, value);
            length++;
        }
        hash = finish(hash, length);
        return hash;
    }
    MurmurHash.hashCode = hashCode;
    /**
     * Function to hash a string. Based on the implementation found here:
     * http://stackoverflow.com/a/7616484
     */
    function hashString(str) {
        let len = str.length;
        if (len === 0) {
            return 0;
        }
        let hash = 0;
        for (let i = 0; i < len; i++) {
            let c = str.charCodeAt(i);
            hash = (((hash << 5) >>> 0) - hash) + c;
            hash |= 0;
        }
        return hash;
    }
})(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));
//# sourceMappingURL=MurmurHash.js.map

/***/ }),

/***/ 6209:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stack = void 0;
class Stack {
    data = [];
    constructor() {
    }
    isEmpty() {
        return this.data.length <= 0;
    }
    push(e) {
        this.data.push(e);
    }
    pop() {
        if (this.data.length <= 0)
            return undefined;
        return this.data.pop();
    }
    peek() {
        if (this.data.length <= 0)
            return undefined;
        return this.data[this.data.length - 1];
    }
    clear() {
        this.data = [];
    }
}
exports.Stack = Stack;
//# sourceMappingURL=Stack.js.map

/***/ }),

/***/ 3748:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(1717), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 1717:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transpileSwiftToKotlin = exports.preprocessSwiftTree = exports.convertSwiftTreeToKotlinTree = exports.printKotlin = exports.parseKotlin = exports.parseSwift = void 0;
const index_1 = __importDefault(__webpack_require__(7228));
const Swift5Lexer_1 = __importDefault(__webpack_require__(5401));
const Swift5Parser_1 = __importDefault(__webpack_require__(314));
const GrammarVisitor_1 = __webpack_require__(9013);
const KotlinParser_1 = __importDefault(__webpack_require__(2893));
const KotlinLexer_1 = __importDefault(__webpack_require__(7328));
const KotlinPrinter_1 = __webpack_require__(5340);
const SwiftKotlinConverter_1 = __webpack_require__(2683);
const KotlinPreprocessor_1 = __webpack_require__(4092);
// parser
function parseSwift(input) {
    const chars = new index_1.default.InputStream(input, undefined);
    const lexer = new Swift5Lexer_1.default(chars);
    const tokens = new index_1.default.CommonTokenStream(lexer, undefined);
    const parser = new Swift5Parser_1.default(tokens);
    parser.buildParseTrees = true;
    const tree = parser.top_level();
    return { top_level: tree.accept(new GrammarVisitor_1.GrammarVisitor()) };
}
exports.parseSwift = parseSwift;
function parseKotlin(input) {
    const chars = new index_1.default.InputStream(input, undefined);
    const lexer = new KotlinLexer_1.default(chars);
    const tokens = new index_1.default.CommonTokenStream(lexer, undefined);
    const parser = new KotlinParser_1.default(tokens);
    parser.buildParseTrees = true;
    const tree = parser.kotlinFile();
    return { kotlinFile: tree.accept(new GrammarVisitor_1.GrammarVisitor()) };
}
exports.parseKotlin = parseKotlin;
// printer
function printKotlin(tree) {
    const printer = new KotlinPrinter_1.KotlinPrinter();
    const lines = printer.printObject([], tree);
    return lines.join('\n');
}
exports.printKotlin = printKotlin;
// converter
function convertSwiftTreeToKotlinTree(swiftTree, info) {
    const converter = new SwiftKotlinConverter_1.SwiftKotlinConverter();
    converter.kotlinTable = info;
    return converter.visitObject([], swiftTree);
}
exports.convertSwiftTreeToKotlinTree = convertSwiftTreeToKotlinTree;
// preprocessor
function preprocessSwiftTree(swiftTree) {
    const preprocessor = new KotlinPreprocessor_1.KotlinPreprocessor();
    return preprocessor.clean([], swiftTree);
}
exports.preprocessSwiftTree = preprocessSwiftTree;
// transpiler
function transpileSwiftToKotlin(swiftCode, info) {
    const swiftTree = preprocessSwiftTree(parseSwift(swiftCode));
    const kotlinTree = convertSwiftTreeToKotlinTree(swiftTree, info);
    return printKotlin(kotlinTree);
}
exports.transpileSwiftToKotlin = transpileSwiftToKotlin;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 1656:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractPreprocessor = void 0;
class AbstractPreprocessor {
    clean(tree, value) {
        if (value === null)
            return [];
        if (typeof value === 'string')
            return this.cleanElement(tree, value);
        if (Array.isArray(value))
            return this.cleanArray(tree, value);
        if (typeof value === 'object')
            return this.cleanObject(tree, value);
        return value;
    }
    cleanArray(tree, elements) {
        const result = [];
        for (let e of elements) {
            if (typeof e === 'object') {
                result.push(this.cleanObject(tree, e));
            }
            else if (Array.isArray(e)) {
                result.push(this.cleanArray(tree, e));
            }
            else if (typeof e === 'string') {
                // NOTE: ignore empty space
                if (e.length > 0) {
                    result.push(this.cleanElement(tree, e));
                }
            }
        }
        return result;
    }
    cleanObject(tree, obj) {
        const result = {};
        for (let key of Object.keys(obj)) {
            tree.push(key);
            const v = obj[key];
            if (typeof v === 'object') {
                result[key] = this.cleanKeyValue(tree, key, v);
            }
            else if (Array.isArray(v)) {
                result[key] = this.cleanArray(tree, v);
            }
            else if (typeof v === 'string') {
                result[key] = this.cleanElement(tree, v);
            }
            tree.pop();
        }
        return result;
    }
    cleanKeyValue(tree, key, value) {
        const customPrinter = this.getCustomCleaner(key);
        if (customPrinter)
            return customPrinter(this, tree, value);
        return this.clean(tree, value);
    }
    cleanElement(tree, value) {
        return value;
    }
    getCustomCleaner(key) {
        return null;
    }
}
exports.AbstractPreprocessor = AbstractPreprocessor;
//# sourceMappingURL=AbstractPreprocessor.js.map

/***/ }),

/***/ 4092:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KotlinPreprocessor = void 0;
const AbstractPreprocessor_1 = __webpack_require__(1656);
class KotlinPreprocessor extends AbstractPreprocessor_1.AbstractPreprocessor {
}
exports.KotlinPreprocessor = KotlinPreprocessor;
//# sourceMappingURL=KotlinPreprocessor.js.map

/***/ }),

/***/ 1643:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractPrinter = void 0;
class AbstractPrinter {
    isPrefixSpace(tree) {
        return false;
    }
    isSuffixSpace(tree) {
        return false;
    }
    getDisplayStyle(tree) {
        return null;
    }
    getNewlineCount(tree) {
        return 0;
    }
    getIndent() {
        return "  ";
    }
    isJoinWithSpace(tree) {
        return false;
    }
    isArrayEqual(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0, n = a.length; i < n; ++i) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    }
    getCustomPrinter(key) {
        return null;
    }
    print(tree, value) {
        if (value === null)
            return [];
        if (typeof value === 'string')
            return this.printElement(tree, value);
        if (Array.isArray(value))
            return this.printArray(tree, value);
        if (typeof value === 'object')
            return this.printObject(tree, value);
        return [];
    }
    printArray(tree, elements) {
        const result = [];
        for (let e of elements) {
            if (typeof e === 'object') {
                result.push(...this.printObject(tree, e));
            }
            else if (Array.isArray(e)) {
                result.push(...this.printArray(tree, e));
            }
            else if (typeof e === 'string') {
                result.push(...this.printElement(tree, e));
            }
        }
        return result;
    }
    printObject(tree, obj) {
        const result = [];
        for (let key of Object.keys(obj)) {
            tree.push(key);
            const v = obj[key];
            if (typeof v === 'object') {
                result.push(...this.printKeyValue(tree, key, v));
            }
            else if (Array.isArray(v)) {
                result.push(...this.printArray(tree, v));
            }
            else if (typeof v === 'string') {
                result.push(...this.printElement(tree, v));
            }
            tree.pop();
        }
        return result;
    }
    printKeyValue(tree, key, value) {
        const customPrinter = this.getCustomPrinter(key);
        if (customPrinter)
            return customPrinter(this, tree, value);
        let lines = [];
        if (this.isPrefixSpace(tree))
            lines.push(" ");
        // execute
        lines.push(...this.print(tree, value));
        if (this.isJoinWithSpace(tree))
            lines = [lines.join(' ')];
        if (this.isSuffixSpace(tree))
            lines.push(" ");
        switch (this.getDisplayStyle(tree)) {
            case 'block': {
                lines = this.addIndent(lines, this.getIndent());
                break;
            }
            case 'inline': {
                lines = [lines.join('')];
                break;
            }
        }
        const newLineCount = this.getNewlineCount(tree);
        for (let i = 0; i < newLineCount; i++)
            lines.push('');
        return lines;
    }
    printElement(tree, value) {
        if (value === '<EOF>')
            return [];
        const result = [];
        tree.push(value);
        if (this.isPrefixSpace(tree))
            result.push(" ");
        result.push(value);
        if (this.isSuffixSpace(tree))
            result.push(" ");
        tree.pop();
        return result;
    }
    addIndent(lines, indent) {
        return lines.map(x => {
            if (x.length < 1)
                return x;
            return indent + x;
        });
    }
}
exports.AbstractPrinter = AbstractPrinter;
//# sourceMappingURL=AbstractPrinter.js.map

/***/ }),

/***/ 5340:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KotlinPrinter = void 0;
const AbstractPrinter_1 = __webpack_require__(1643);
class KotlinPrinter extends AbstractPrinter_1.AbstractPrinter {
    blockKeysList = [];
    prefixSpaceKeysList = [
        ["propertyDeclaration", '='],
        ["assignment", '='],
        ['objectDeclaration', 'classBody'],
        ['classDeclaration', 'classBody'],
        ["functionDeclaration", 'functionBody'],
    ];
    suffixSpaceKeysList = [
        ['packageHeader', 'package'],
        ['importHeader', 'import'],
        ['objectDeclaration', 'object'],
        ['classDeclaration', 'class'],
        ["functionDeclaration", 'fun'],
        ["functionDeclaration", ':'],
        // ["functionDeclaration", 'functionValueParameters'],
        ["propertyDeclaration", '='],
        ["assignment", '='],
        ["variableDeclaration", ':'],
        ['classParameters', ','],
        ['classParameter', ':'],
        ["functionBody", '='],
        ["functionValueParameter", ','],
        ["parameter", ':'],
        ['modifier'],
        ['val'],
        ['var'],
    ];
    inlineKeysList = [
        ['packageHeader'],
        ['importHeader'],
        ['classParameter'],
        ['classParameters'],
    ];
    newLineCountMap1 = {
        'packageHeader': 1,
        'importList': 1,
        'classDeclaration': 1,
    };
    joinWithSpaceList = [];
    customPrinterMap = {
        'classDeclaration': this.printClassDeclaration,
        'objectDeclaration': this.printObjectDeclaration,
        'functionDeclaration': this.printFunctionDeclaration,
        'propertyDeclaration': this.printPropertyDeclaration,
        'block': this.printBlock,
        'classBody': this.printClassBody,
        'functionBody': this.printFunctionBody,
        'lambdaLiteral': this.printLambdaLiteral,
        'postfixUnaryExpression': this.printPostfixUnaryExpression,
        'valueArguments': this.printValueArguments,
        'assignment': this.printAssignment,
        'semis': this.printSemis,
    };
    getDisplayStyle(tree) {
        if (this.containsKeysList(this.blockKeysList, tree))
            return 'block';
        if (this.containsKeysList(this.inlineKeysList, tree))
            return 'inline';
        return null;
    }
    getNewlineCount(tree) {
        if (tree.length < 1)
            return 0;
        const key = tree[tree.length - 1];
        return this.newLineCountMap1[key] ?? 0;
    }
    getCustomPrinter(key) {
        return this.customPrinterMap[key] ?? super.getCustomPrinter(key);
    }
    isPrefixSpace(tree) {
        if (this.containsKeysList(this.prefixSpaceKeysList, tree))
            return true;
        return super.isPrefixSpace(tree);
    }
    isSuffixSpace(tree) {
        if (this.containsKeysList(this.suffixSpaceKeysList, tree))
            return true;
        return super.isSuffixSpace(tree);
    }
    isJoinWithSpace(tree) {
        if (this.containsKeysList(this.joinWithSpaceList, tree))
            return true;
        return super.isJoinWithSpace(tree);
    }
    printClassDeclaration(self, tree, value) {
        return self.printObjectDeclaration(self, tree, value);
    }
    printObjectDeclaration(self, tree, value) {
        const valueArray = value;
        let classBodyIndex = valueArray.findIndex((v, i, o) => typeof v === 'object' && 'classBody' in v);
        const prefixArray = valueArray.slice(0, classBodyIndex);
        const prefixResult = self.printArray(tree, prefixArray);
        const suffixArray = valueArray.slice(classBodyIndex);
        const suffixResult = self.printArray(tree, suffixArray);
        const firstLine = [
            ...prefixResult,
            ' ',
            suffixResult[0]
        ].join('');
        const restLines = suffixResult.slice(1);
        return [
            firstLine,
            ...restLines,
        ];
    }
    printFunctionDeclaration(self, tree, value) {
        const valueArray = value;
        const functionBodyIndex = valueArray.findIndex(x => typeof x === 'object' && 'functionBody' in x);
        const prefixArray = valueArray.slice(0, functionBodyIndex);
        const prefixResult = self.printArray(tree, prefixArray);
        const suffixArray = valueArray.slice(functionBodyIndex);
        const suffixResult = self.printArray(tree, suffixArray);
        const firstLine = [
            ...prefixResult,
            ' ',
            suffixResult[0]
        ].join('');
        const restLines = suffixResult.slice(1);
        return [
            firstLine,
            ...restLines,
        ];
    }
    printPropertyDeclaration(self, tree, value) {
        return self.printPreExpressionStyle(self, tree, value, 'expression');
    }
    printAssignment(self, tree, value) {
        return self.printPreExpressionStyle(self, tree, value, 'expression');
    }
    printBlock(self, tree, value) {
        return self.printCurlyBracketStyle(self, tree, value, 'statements');
    }
    printClassBody(self, tree, value) {
        return self.printCurlyBracketStyle(self, tree, value, 'classMemberDeclarations');
    }
    printFunctionBody(self, tree, value) {
        const valueArray = value;
        const expressionIndex = valueArray.findIndex((v, i, o) => typeof v === "object" && 'expression' in v);
        if (expressionIndex < 0) {
            return self.printArray(tree, valueArray);
        }
        const prefixArray = valueArray.slice(0, expressionIndex);
        const prefixResult = self.printArray(tree, prefixArray);
        const suffixArray = valueArray.slice(expressionIndex);
        const suffixResult = self.printArray(tree, suffixArray);
        const firstLine = [
            ...prefixResult,
            suffixResult[0]
        ].join('');
        const restLines = suffixResult.slice(1);
        return [
            firstLine,
            ...restLines,
        ];
    }
    printLambdaLiteral(self, tree, value) {
        return self.printCurlyBracketStyle(self, tree, value, 'statements');
    }
    printPostfixUnaryExpression(self, tree, value) {
        const valueArray = value;
        let result = [];
        let firstLine = self.print(tree, valueArray[0]).join('');
        for (let i = 1; i < valueArray.length; i++) {
            const e = valueArray[i];
            const printer = self;
            const lines = printer.print(tree, e);
            if (lines.length <= 0)
                continue;
            const isCallSuffix = printer.hasKeysInObject(e, ['postfixUnarySuffix', 'callSuffix']);
            if (!isCallSuffix || lines.length == 1) {
                firstLine = firstLine + lines.join('');
                continue;
            }
            if (lines[0].startsWith('{'))
                firstLine += ' ';
            firstLine += lines[0];
            const restLines = lines.slice(1, lines.length - 1);
            result.push(firstLine);
            result.push(...restLines);
            firstLine = lines[lines.length - 1];
        }
        result.push(firstLine);
        return result;
    }
    printValueArguments(self, tree, value) {
        const valueArray = value;
        const linesMap = [];
        let hasMultilineArguments = false;
        let startValueArgumentIndex = -1;
        let endValueArgumentIndex = -1;
        for (let i = 0; i < valueArray.length; i++) {
            const element = valueArray[i];
            const lines = self.print(tree, element);
            if (typeof element === 'object' && element['valueArgument']) {
                if (lines.length > 1)
                    hasMultilineArguments = true;
                if (startValueArgumentIndex === -1)
                    startValueArgumentIndex = i;
                endValueArgumentIndex = i;
            }
            linesMap.push(lines);
        }
        if (hasMultilineArguments) {
            const results = [];
            for (let i = 0; i < valueArray.length; i++) {
                const element = valueArray[i];
                if (typeof element === 'object' && 'valueArgument' in element) {
                    results.push(...self.addIndent(linesMap[i], self.getIndent()));
                }
                else if (linesMap[i].length === 1 && linesMap[i][0] === ',') {
                    results[results.length - 1] += ',';
                }
                else {
                    results.push(...linesMap[i]);
                }
            }
            return results;
        }
        else {
            const results = [];
            for (let i = 0; i < valueArray.length; i++) {
                results.push(...linesMap[i]);
            }
            const single = [results.join('')];
            return single;
        }
    }
    printSemis(self, tree, value) {
        return [];
    }
    printPreExpressionStyle(self, tree, value, middleKeyName) {
        const valueArray = value;
        const expressionIndex = valueArray.findIndex((v, i, o) => typeof v === 'object' && v[middleKeyName]);
        if (expressionIndex > 0) {
            const prefixArray = valueArray.slice(0, expressionIndex);
            const prefixResult = self.printArray(tree, prefixArray);
            const suffixArray = valueArray.slice(expressionIndex);
            const suffixResult = self.printArray(tree, suffixArray);
            const prefixLine = prefixResult.join('') + suffixResult[0];
            const suffixLine = suffixResult.slice(1);
            return [
                prefixLine,
                ...suffixLine
            ];
        }
        else {
            const prefixResult = self.printArray(tree, valueArray);
            const prefixLine = prefixResult.join('');
            return [
                prefixLine
            ];
        }
    }
    printCurlyBracketStyle(self, tree, value, middleKeyName) {
        const valueArray = value;
        const middleIndex = valueArray.findIndex((v, i, o) => typeof v === "object" && middleKeyName in v);
        if (middleIndex < 0)
            return ['{', '}'];
        const prefixArray = valueArray.slice(0, middleIndex);
        const prefixResult = self.printArray(tree, prefixArray);
        const middleValue = valueArray[middleIndex];
        const middleResult = self.addIndent(self.print(tree, middleValue), self.getIndent());
        const suffixArray = valueArray.slice(middleIndex + 1);
        const suffixResult = self.printArray(tree, suffixArray);
        return [
            prefixResult.join(' '),
            ...middleResult,
            ...suffixResult,
        ];
    }
    containsKeysList(keysList, tree) {
        for (let keys of keysList) {
            if (tree.length >= keys.length) {
                const treeKeys = tree.slice(tree.length - keys.length, tree.length);
                if (this.isArrayEqual(treeKeys, keys))
                    return true;
            }
        }
        return false;
    }
    hasKeysInObject(obj, keys) {
        let target = obj;
        for (let key of keys) {
            if (typeof target === 'object' && key in target) {
                target = target[key];
            }
            else if (Array.isArray(target)) {
                const targetArray = target;
                const index = targetArray.findIndex(e => typeof e === 'object' && key in e);
                if (index < 0)
                    return false;
                target = targetArray[index][key];
            }
            else {
                return false;
            }
        }
        return true;
    }
}
exports.KotlinPrinter = KotlinPrinter;
//# sourceMappingURL=KotlinPrinter.js.map

/***/ }),

/***/ 2648:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TreeWalk = void 0;
class TreeWalk {
    static isEmptyObject(input) {
        return Object.keys(input).length < 1;
    }
    static isEmptyArray(input) {
        return input.length < 1;
    }
    static hasKey(key, target) {
        return typeof target === 'object' && key in target;
    }
    // key: 'a'
    // target: {a: [ {b: []} ]}
    // output: {b: []}
    static getArrayOrNull(key, target) {
        if (typeof target === 'object' && key in target)
            return target[key];
        return null;
    }
    // keys: ['a','b']
    // input: [ { a: [ { b: [ 'c' ] } ] } ]
    // return: ['c']
    static firstArrayOrNullByKeys(keys, input) {
        if (keys.length < 1)
            return input;
        const key = keys[0];
        for (let i = 0; i < input.length; i++) {
            const value = this.getArrayOrNull(key, input[i]);
            if (!value)
                continue;
            const result = this.firstArrayOrNullByKeys(keys.slice(1), value);
            if (result)
                return result;
        }
        return null;
    }
    // keys: [key1, key2]
    // input:
    //   [
    //     { key1: [ {key2: "ok" } ] },
    //     { key2: [ {b: 1 } ] },
    //   ]
    // output: "ok"
    static firstElementOrNullByKeys(keys, input) {
        const array = this.firstArrayOrNullByKeys(keys, input);
        if (!array || array.length < 1)
            return null;
        const element = array[0];
        if (typeof element === 'string')
            return element;
        return null;
    }
    // target: {a: [], b: []}
    // output: [a: []]
    static firstKeyValueOrNull(target) {
        if (typeof target === 'object') {
            const keys = Object.keys(target);
            if (keys.length < 1)
                return [null, []];
            const key = keys[0];
            const value = target[key];
            return [key, value];
        }
        return [null, []];
    }
    // keys: [statement, a]
    // input:
    //   [
    //     { statement: [ {a: 1 } ] },
    //     { statement: [ {b: 1 } ] },
    //     { statement: [ {a: 2 } ] },
    //   ]
    // output:
    //   [
    //     { statement: [ {a: 1 } ] },
    //     { statement: [ {a: 2 } ] },
    //   ]
    static filterRootByKeys(keys, input) {
        const results = [];
        if (keys.length <= 0)
            return results;
        const key = keys[0];
        for (let i = 0; i < input.length; i++) {
            const element = input[i];
            if (typeof element === 'object' && key in element) {
                const v = element[key];
                if (this.isMatchedRoot(keys.slice(1), v)) {
                    results.push(element);
                }
            }
        }
        return results;
    }
    static isMatchedRoot(keys, input) {
        if (keys.length <= 0)
            return true;
        const key = keys[0];
        for (let i = 0; i < input.length; i++) {
            const element = input[i];
            if (typeof element === 'object' && key in element) {
                const v = element[key];
                if (this.isMatchedRoot(keys.slice(1), v)) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.TreeWalk = TreeWalk;
//# sourceMappingURL=TreeWalk.js.map

/***/ }),

/***/ 9013:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GrammarVisitor = void 0;
const ANTLRv4ParserVisitor_1 = __importDefault(__webpack_require__(7164));
class GrammarVisitor extends ANTLRv4ParserVisitor_1.default {
    visitChildren(ctx) {
        if (!ctx)
            return null;
        // @ts-ignore
        if (ctx.children) {
            // @ts-ignore
            return ctx.children.map((child) => {
                let name = this.contextToName(child);
                if (child.children && child.children.length != 0) {
                    const result = {};
                    result[name] = child.accept(this);
                    return result;
                }
                else if (child.constructor.name === 'TerminalNodeImpl') {
                    const text = child.getText();
                    return text.match(/^(\n\r?)+$/) ? '' : text;
                }
                else {
                    const result = {};
                    result[name] = null;
                    return result;
                }
            });
        }
        return null;
    }
    contextToName(ctx) {
        return ctx.constructor.name
            .replace(/^(.)(.+)Context\d*$/, (substring, ...args) => {
            return args[0].toLowerCase() + args[1];
        });
    }
}
exports.GrammarVisitor = GrammarVisitor;
//# sourceMappingURL=GrammarVisitor.js.map

/***/ })

}]);